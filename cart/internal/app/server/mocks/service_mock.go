// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/cart/internal/app/server.Service -o service_mock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/cart/internal/domain/model"
	"github.com/gojuno/minimock/v3"
)

// ServiceMock implements mm_server.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, datas model.RequestData) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, datas model.RequestData)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mServiceMockAddItem

	funcDeleteItem          func(ctx context.Context, data model.RequestData) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, data model.RequestData)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mServiceMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, data model.RequestData) (err error)
	funcDeleteItemsByUserIDOrigin    string
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, data model.RequestData)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mServiceMockDeleteItemsByUserID

	funcGetItemsFromCart          func(ctx context.Context, data model.RequestData) (gp1 *model.GetItemsFromCartResponce, err error)
	funcGetItemsFromCartOrigin    string
	inspectFuncGetItemsFromCart   func(ctx context.Context, data model.RequestData)
	afterGetItemsFromCartCounter  uint64
	beforeGetItemsFromCartCounter uint64
	GetItemsFromCartMock          mServiceMockGetItemsFromCart

	funcOrderCreate          func(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce) (i1 int64, err error)
	funcOrderCreateOrigin    string
	inspectFuncOrderCreate   func(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mServiceMockOrderCreate
}

// NewServiceMock returns a mock for mm_server.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mServiceMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ServiceMockAddItemParams{}

	m.DeleteItemMock = mServiceMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ServiceMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mServiceMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*ServiceMockDeleteItemsByUserIDParams{}

	m.GetItemsFromCartMock = mServiceMockGetItemsFromCart{mock: m}
	m.GetItemsFromCartMock.callArgs = []*ServiceMockGetItemsFromCartParams{}

	m.OrderCreateMock = mServiceMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*ServiceMockOrderCreateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockAddItem struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockAddItemExpectation
	expectations       []*ServiceMockAddItemExpectation

	callArgs []*ServiceMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockAddItemExpectation specifies expectation struct of the Service.AddItem
type ServiceMockAddItemExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockAddItemParams
	paramPtrs          *ServiceMockAddItemParamPtrs
	expectationOrigins ServiceMockAddItemExpectationOrigins
	results            *ServiceMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockAddItemParams contains parameters of the Service.AddItem
type ServiceMockAddItemParams struct {
	ctx   context.Context
	datas model.RequestData
}

// ServiceMockAddItemParamPtrs contains pointers to parameters of the Service.AddItem
type ServiceMockAddItemParamPtrs struct {
	ctx   *context.Context
	datas *model.RequestData
}

// ServiceMockAddItemResults contains results of the Service.AddItem
type ServiceMockAddItemResults struct {
	err error
}

// ServiceMockAddItemOrigins contains origins of expectations of the Service.AddItem
type ServiceMockAddItemExpectationOrigins struct {
	origin      string
	originCtx   string
	originDatas string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mServiceMockAddItem) Optional() *mServiceMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for Service.AddItem
func (mmAddItem *mServiceMockAddItem) Expect(ctx context.Context, datas model.RequestData) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ServiceMockAddItemParams{ctx, datas}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for Service.AddItem
func (mmAddItem *mServiceMockAddItem) ExpectCtxParam1(ctx context.Context) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ServiceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectDatasParam2 sets up expected param datas for Service.AddItem
func (mmAddItem *mServiceMockAddItem) ExpectDatasParam2(datas model.RequestData) *mServiceMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ServiceMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.datas = &datas
	mmAddItem.defaultExpectation.expectationOrigins.originDatas = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the Service.AddItem
func (mmAddItem *mServiceMockAddItem) Inspect(f func(ctx context.Context, datas model.RequestData)) *mServiceMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ServiceMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by Service.AddItem
func (mmAddItem *mServiceMockAddItem) Return(err error) *ServiceMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ServiceMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ServiceMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the Service.AddItem method
func (mmAddItem *mServiceMockAddItem) Set(f func(ctx context.Context, datas model.RequestData) (err error)) *ServiceMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the Service.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the Service.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the Service.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mServiceMockAddItem) When(ctx context.Context, datas model.RequestData) *ServiceMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ServiceMock.AddItem mock is already set by Set")
	}

	expectation := &ServiceMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &ServiceMockAddItemParams{ctx, datas},
		expectationOrigins: ServiceMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up Service.AddItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockAddItemExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockAddItemResults{err}
	return e.mock
}

// Times sets number of times Service.AddItem should be invoked
func (mmAddItem *mServiceMockAddItem) Times(n uint64) *mServiceMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ServiceMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mServiceMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_server.Service
func (mmAddItem *ServiceMock) AddItem(ctx context.Context, datas model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, datas)
	}

	mm_params := ServiceMockAddItemParams{ctx, datas}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockAddItemParams{ctx, datas}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.datas != nil && !minimock.Equal(*mm_want_ptrs.datas, mm_got.datas) {
				mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameter datas, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originDatas, *mm_want_ptrs.datas, mm_got.datas, minimock.Diff(*mm_want_ptrs.datas, mm_got.datas))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ServiceMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ServiceMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, datas)
	}
	mmAddItem.t.Fatalf("Unexpected call to ServiceMock.AddItem. %v %v", ctx, datas)
	return
}

// AddItemAfterCounter returns a count of finished ServiceMock.AddItem invocations
func (mmAddItem *ServiceMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ServiceMock.AddItem invocations
func (mmAddItem *ServiceMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mServiceMockAddItem) Calls() []*ServiceMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ServiceMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ServiceMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mServiceMockDeleteItem struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteItemExpectation
	expectations       []*ServiceMockDeleteItemExpectation

	callArgs []*ServiceMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteItemExpectation specifies expectation struct of the Service.DeleteItem
type ServiceMockDeleteItemExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteItemParams
	paramPtrs          *ServiceMockDeleteItemParamPtrs
	expectationOrigins ServiceMockDeleteItemExpectationOrigins
	results            *ServiceMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteItemParams contains parameters of the Service.DeleteItem
type ServiceMockDeleteItemParams struct {
	ctx  context.Context
	data model.RequestData
}

// ServiceMockDeleteItemParamPtrs contains pointers to parameters of the Service.DeleteItem
type ServiceMockDeleteItemParamPtrs struct {
	ctx  *context.Context
	data *model.RequestData
}

// ServiceMockDeleteItemResults contains results of the Service.DeleteItem
type ServiceMockDeleteItemResults struct {
	err error
}

// ServiceMockDeleteItemOrigins contains origins of expectations of the Service.DeleteItem
type ServiceMockDeleteItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mServiceMockDeleteItem) Optional() *mServiceMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for Service.DeleteItem
func (mmDeleteItem *mServiceMockDeleteItem) Expect(ctx context.Context, data model.RequestData) *mServiceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &ServiceMockDeleteItemParams{ctx, data}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteItem
func (mmDeleteItem *mServiceMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ServiceMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectDataParam2 sets up expected param data for Service.DeleteItem
func (mmDeleteItem *mServiceMockDeleteItem) ExpectDataParam2(data model.RequestData) *mServiceMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ServiceMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.data = &data
	mmDeleteItem.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteItem
func (mmDeleteItem *mServiceMockDeleteItem) Inspect(f func(ctx context.Context, data model.RequestData)) *mServiceMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by Service.DeleteItem
func (mmDeleteItem *mServiceMockDeleteItem) Return(err error) *ServiceMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ServiceMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &ServiceMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the Service.DeleteItem method
func (mmDeleteItem *mServiceMockDeleteItem) Set(f func(ctx context.Context, data model.RequestData) (err error)) *ServiceMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the Service.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the Service.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the Service.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mServiceMockDeleteItem) When(ctx context.Context, data model.RequestData) *ServiceMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ServiceMock.DeleteItem mock is already set by Set")
	}

	expectation := &ServiceMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &ServiceMockDeleteItemParams{ctx, data},
		expectationOrigins: ServiceMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteItemExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteItem should be invoked
func (mmDeleteItem *mServiceMockDeleteItem) Times(n uint64) *mServiceMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of ServiceMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mServiceMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_server.Service
func (mmDeleteItem *ServiceMock) DeleteItem(ctx context.Context, data model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, data)
	}

	mm_params := ServiceMockDeleteItemParams{ctx, data}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteItemParams{ctx, data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("ServiceMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmDeleteItem.t.Errorf("ServiceMock.DeleteItem got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ServiceMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the ServiceMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, data)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ServiceMock.DeleteItem. %v %v", ctx, data)
	return
}

// DeleteItemAfterCounter returns a count of finished ServiceMock.DeleteItem invocations
func (mmDeleteItem *ServiceMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ServiceMock.DeleteItem invocations
func (mmDeleteItem *ServiceMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mServiceMockDeleteItem) Calls() []*ServiceMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mServiceMockDeleteItemsByUserID struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteItemsByUserIDExpectation
	expectations       []*ServiceMockDeleteItemsByUserIDExpectation

	callArgs []*ServiceMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockDeleteItemsByUserIDExpectation specifies expectation struct of the Service.DeleteItemsByUserID
type ServiceMockDeleteItemsByUserIDExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockDeleteItemsByUserIDParams
	paramPtrs          *ServiceMockDeleteItemsByUserIDParamPtrs
	expectationOrigins ServiceMockDeleteItemsByUserIDExpectationOrigins
	results            *ServiceMockDeleteItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockDeleteItemsByUserIDParams contains parameters of the Service.DeleteItemsByUserID
type ServiceMockDeleteItemsByUserIDParams struct {
	ctx  context.Context
	data model.RequestData
}

// ServiceMockDeleteItemsByUserIDParamPtrs contains pointers to parameters of the Service.DeleteItemsByUserID
type ServiceMockDeleteItemsByUserIDParamPtrs struct {
	ctx  *context.Context
	data *model.RequestData
}

// ServiceMockDeleteItemsByUserIDResults contains results of the Service.DeleteItemsByUserID
type ServiceMockDeleteItemsByUserIDResults struct {
	err error
}

// ServiceMockDeleteItemsByUserIDOrigins contains origins of expectations of the Service.DeleteItemsByUserID
type ServiceMockDeleteItemsByUserIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Optional() *mServiceMockDeleteItemsByUserID {
	mmDeleteItemsByUserID.optional = true
	return mmDeleteItemsByUserID
}

// Expect sets up expected params for Service.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Expect(ctx context.Context, data model.RequestData) *mServiceMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &ServiceMockDeleteItemsByUserIDParams{ctx, data}
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Service.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) ExpectCtxParam1(ctx context.Context) *mServiceMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &ServiceMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// ExpectDataParam2 sets up expected param data for Service.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) ExpectDataParam2(data model.RequestData) *mServiceMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &ServiceMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.data = &data
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Service.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, data model.RequestData)) *mServiceMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by Service.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Return(err error) *ServiceMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ServiceMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &ServiceMockDeleteItemsByUserIDResults{err}
	mmDeleteItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the Service.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Set(f func(ctx context.Context, data model.RequestData) (err error)) *ServiceMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the Service.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the Service.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the Service.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) When(ctx context.Context, data model.RequestData) *ServiceMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ServiceMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &ServiceMockDeleteItemsByUserIDExpectation{
		mock:               mmDeleteItemsByUserID.mock,
		params:             &ServiceMockDeleteItemsByUserIDParams{ctx, data},
		expectationOrigins: ServiceMockDeleteItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Service.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteItemsByUserIDExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteItemsByUserIDResults{err}
	return e.mock
}

// Times sets number of times Service.DeleteItemsByUserID should be invoked
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Times(n uint64) *mServiceMockDeleteItemsByUserID {
	if n == 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Times of ServiceMock.DeleteItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsByUserID.expectedInvocations, n)
	mmDeleteItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID
}

func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) invocationsDone() bool {
	if len(mmDeleteItemsByUserID.expectations) == 0 && mmDeleteItemsByUserID.defaultExpectation == nil && mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.mock.afterDeleteItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsByUserID implements mm_server.Service
func (mmDeleteItemsByUserID *ServiceMock) DeleteItemsByUserID(ctx context.Context, data model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	mmDeleteItemsByUserID.t.Helper()

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, data)
	}

	mm_params := ServiceMockDeleteItemsByUserIDParams{ctx, data}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, &mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockDeleteItemsByUserIDParams{ctx, data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemsByUserID.t.Errorf("ServiceMock.DeleteItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmDeleteItemsByUserID.t.Errorf("ServiceMock.DeleteItemsByUserID got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("ServiceMock.DeleteItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the ServiceMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, data)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to ServiceMock.DeleteItemsByUserID. %v %v", ctx, data)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished ServiceMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ServiceMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of ServiceMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ServiceMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mServiceMockDeleteItemsByUserID) Calls() []*ServiceMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteItemsByUserIDDone() bool {
	if m.DeleteItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsByUserIDMock.invocationsDone()
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && afterDeleteItemsByUserIDCounter < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.DeleteItemsByUserID at\n%s", m.DeleteItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteItemsByUserID at\n%s with params: %#v", m.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && afterDeleteItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.DeleteItemsByUserID at\n%s", m.funcDeleteItemsByUserIDOrigin)
	}

	if !m.DeleteItemsByUserIDMock.invocationsDone() && afterDeleteItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.DeleteItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsByUserIDMock.expectedInvocations), m.DeleteItemsByUserIDMock.expectedInvocationsOrigin, afterDeleteItemsByUserIDCounter)
	}
}

type mServiceMockGetItemsFromCart struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetItemsFromCartExpectation
	expectations       []*ServiceMockGetItemsFromCartExpectation

	callArgs []*ServiceMockGetItemsFromCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockGetItemsFromCartExpectation specifies expectation struct of the Service.GetItemsFromCart
type ServiceMockGetItemsFromCartExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockGetItemsFromCartParams
	paramPtrs          *ServiceMockGetItemsFromCartParamPtrs
	expectationOrigins ServiceMockGetItemsFromCartExpectationOrigins
	results            *ServiceMockGetItemsFromCartResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockGetItemsFromCartParams contains parameters of the Service.GetItemsFromCart
type ServiceMockGetItemsFromCartParams struct {
	ctx  context.Context
	data model.RequestData
}

// ServiceMockGetItemsFromCartParamPtrs contains pointers to parameters of the Service.GetItemsFromCart
type ServiceMockGetItemsFromCartParamPtrs struct {
	ctx  *context.Context
	data *model.RequestData
}

// ServiceMockGetItemsFromCartResults contains results of the Service.GetItemsFromCart
type ServiceMockGetItemsFromCartResults struct {
	gp1 *model.GetItemsFromCartResponce
	err error
}

// ServiceMockGetItemsFromCartOrigins contains origins of expectations of the Service.GetItemsFromCart
type ServiceMockGetItemsFromCartExpectationOrigins struct {
	origin     string
	originCtx  string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Optional() *mServiceMockGetItemsFromCart {
	mmGetItemsFromCart.optional = true
	return mmGetItemsFromCart
}

// Expect sets up expected params for Service.GetItemsFromCart
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Expect(ctx context.Context, data model.RequestData) *mServiceMockGetItemsFromCart {
	if mmGetItemsFromCart.mock.funcGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Set")
	}

	if mmGetItemsFromCart.defaultExpectation == nil {
		mmGetItemsFromCart.defaultExpectation = &ServiceMockGetItemsFromCartExpectation{}
	}

	if mmGetItemsFromCart.defaultExpectation.paramPtrs != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by ExpectParams functions")
	}

	mmGetItemsFromCart.defaultExpectation.params = &ServiceMockGetItemsFromCartParams{ctx, data}
	mmGetItemsFromCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsFromCart.expectations {
		if minimock.Equal(e.params, mmGetItemsFromCart.defaultExpectation.params) {
			mmGetItemsFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsFromCart.defaultExpectation.params)
		}
	}

	return mmGetItemsFromCart
}

// ExpectCtxParam1 sets up expected param ctx for Service.GetItemsFromCart
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) ExpectCtxParam1(ctx context.Context) *mServiceMockGetItemsFromCart {
	if mmGetItemsFromCart.mock.funcGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Set")
	}

	if mmGetItemsFromCart.defaultExpectation == nil {
		mmGetItemsFromCart.defaultExpectation = &ServiceMockGetItemsFromCartExpectation{}
	}

	if mmGetItemsFromCart.defaultExpectation.params != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Expect")
	}

	if mmGetItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmGetItemsFromCart.defaultExpectation.paramPtrs = &ServiceMockGetItemsFromCartParamPtrs{}
	}
	mmGetItemsFromCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsFromCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsFromCart
}

// ExpectDataParam2 sets up expected param data for Service.GetItemsFromCart
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) ExpectDataParam2(data model.RequestData) *mServiceMockGetItemsFromCart {
	if mmGetItemsFromCart.mock.funcGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Set")
	}

	if mmGetItemsFromCart.defaultExpectation == nil {
		mmGetItemsFromCart.defaultExpectation = &ServiceMockGetItemsFromCartExpectation{}
	}

	if mmGetItemsFromCart.defaultExpectation.params != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Expect")
	}

	if mmGetItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmGetItemsFromCart.defaultExpectation.paramPtrs = &ServiceMockGetItemsFromCartParamPtrs{}
	}
	mmGetItemsFromCart.defaultExpectation.paramPtrs.data = &data
	mmGetItemsFromCart.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmGetItemsFromCart
}

// Inspect accepts an inspector function that has same arguments as the Service.GetItemsFromCart
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Inspect(f func(ctx context.Context, data model.RequestData)) *mServiceMockGetItemsFromCart {
	if mmGetItemsFromCart.mock.inspectFuncGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetItemsFromCart")
	}

	mmGetItemsFromCart.mock.inspectFuncGetItemsFromCart = f

	return mmGetItemsFromCart
}

// Return sets up results that will be returned by Service.GetItemsFromCart
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Return(gp1 *model.GetItemsFromCartResponce, err error) *ServiceMock {
	if mmGetItemsFromCart.mock.funcGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Set")
	}

	if mmGetItemsFromCart.defaultExpectation == nil {
		mmGetItemsFromCart.defaultExpectation = &ServiceMockGetItemsFromCartExpectation{mock: mmGetItemsFromCart.mock}
	}
	mmGetItemsFromCart.defaultExpectation.results = &ServiceMockGetItemsFromCartResults{gp1, err}
	mmGetItemsFromCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsFromCart.mock
}

// Set uses given function f to mock the Service.GetItemsFromCart method
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Set(f func(ctx context.Context, data model.RequestData) (gp1 *model.GetItemsFromCartResponce, err error)) *ServiceMock {
	if mmGetItemsFromCart.defaultExpectation != nil {
		mmGetItemsFromCart.mock.t.Fatalf("Default expectation is already set for the Service.GetItemsFromCart method")
	}

	if len(mmGetItemsFromCart.expectations) > 0 {
		mmGetItemsFromCart.mock.t.Fatalf("Some expectations are already set for the Service.GetItemsFromCart method")
	}

	mmGetItemsFromCart.mock.funcGetItemsFromCart = f
	mmGetItemsFromCart.mock.funcGetItemsFromCartOrigin = minimock.CallerInfo(1)
	return mmGetItemsFromCart.mock
}

// When sets expectation for the Service.GetItemsFromCart which will trigger the result defined by the following
// Then helper
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) When(ctx context.Context, data model.RequestData) *ServiceMockGetItemsFromCartExpectation {
	if mmGetItemsFromCart.mock.funcGetItemsFromCart != nil {
		mmGetItemsFromCart.mock.t.Fatalf("ServiceMock.GetItemsFromCart mock is already set by Set")
	}

	expectation := &ServiceMockGetItemsFromCartExpectation{
		mock:               mmGetItemsFromCart.mock,
		params:             &ServiceMockGetItemsFromCartParams{ctx, data},
		expectationOrigins: ServiceMockGetItemsFromCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsFromCart.expectations = append(mmGetItemsFromCart.expectations, expectation)
	return expectation
}

// Then sets up Service.GetItemsFromCart return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetItemsFromCartExpectation) Then(gp1 *model.GetItemsFromCartResponce, err error) *ServiceMock {
	e.results = &ServiceMockGetItemsFromCartResults{gp1, err}
	return e.mock
}

// Times sets number of times Service.GetItemsFromCart should be invoked
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Times(n uint64) *mServiceMockGetItemsFromCart {
	if n == 0 {
		mmGetItemsFromCart.mock.t.Fatalf("Times of ServiceMock.GetItemsFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsFromCart.expectedInvocations, n)
	mmGetItemsFromCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsFromCart
}

func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) invocationsDone() bool {
	if len(mmGetItemsFromCart.expectations) == 0 && mmGetItemsFromCart.defaultExpectation == nil && mmGetItemsFromCart.mock.funcGetItemsFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsFromCart.mock.afterGetItemsFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsFromCart implements mm_server.Service
func (mmGetItemsFromCart *ServiceMock) GetItemsFromCart(ctx context.Context, data model.RequestData) (gp1 *model.GetItemsFromCartResponce, err error) {
	mm_atomic.AddUint64(&mmGetItemsFromCart.beforeGetItemsFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsFromCart.afterGetItemsFromCartCounter, 1)

	mmGetItemsFromCart.t.Helper()

	if mmGetItemsFromCart.inspectFuncGetItemsFromCart != nil {
		mmGetItemsFromCart.inspectFuncGetItemsFromCart(ctx, data)
	}

	mm_params := ServiceMockGetItemsFromCartParams{ctx, data}

	// Record call args
	mmGetItemsFromCart.GetItemsFromCartMock.mutex.Lock()
	mmGetItemsFromCart.GetItemsFromCartMock.callArgs = append(mmGetItemsFromCart.GetItemsFromCartMock.callArgs, &mm_params)
	mmGetItemsFromCart.GetItemsFromCartMock.mutex.Unlock()

	for _, e := range mmGetItemsFromCart.GetItemsFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockGetItemsFromCartParams{ctx, data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsFromCart.t.Errorf("ServiceMock.GetItemsFromCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmGetItemsFromCart.t.Errorf("ServiceMock.GetItemsFromCart got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsFromCart.t.Errorf("ServiceMock.GetItemsFromCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsFromCart.GetItemsFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsFromCart.t.Fatal("No results are set for the ServiceMock.GetItemsFromCart")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetItemsFromCart.funcGetItemsFromCart != nil {
		return mmGetItemsFromCart.funcGetItemsFromCart(ctx, data)
	}
	mmGetItemsFromCart.t.Fatalf("Unexpected call to ServiceMock.GetItemsFromCart. %v %v", ctx, data)
	return
}

// GetItemsFromCartAfterCounter returns a count of finished ServiceMock.GetItemsFromCart invocations
func (mmGetItemsFromCart *ServiceMock) GetItemsFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsFromCart.afterGetItemsFromCartCounter)
}

// GetItemsFromCartBeforeCounter returns a count of ServiceMock.GetItemsFromCart invocations
func (mmGetItemsFromCart *ServiceMock) GetItemsFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsFromCart.beforeGetItemsFromCartCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetItemsFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsFromCart *mServiceMockGetItemsFromCart) Calls() []*ServiceMockGetItemsFromCartParams {
	mmGetItemsFromCart.mutex.RLock()

	argCopy := make([]*ServiceMockGetItemsFromCartParams, len(mmGetItemsFromCart.callArgs))
	copy(argCopy, mmGetItemsFromCart.callArgs)

	mmGetItemsFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsFromCartDone returns true if the count of the GetItemsFromCart invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetItemsFromCartDone() bool {
	if m.GetItemsFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsFromCartMock.invocationsDone()
}

// MinimockGetItemsFromCartInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetItemsFromCartInspect() {
	for _, e := range m.GetItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetItemsFromCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsFromCartCounter := mm_atomic.LoadUint64(&m.afterGetItemsFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsFromCartMock.defaultExpectation != nil && afterGetItemsFromCartCounter < 1 {
		if m.GetItemsFromCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.GetItemsFromCart at\n%s", m.GetItemsFromCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetItemsFromCart at\n%s with params: %#v", m.GetItemsFromCartMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsFromCart != nil && afterGetItemsFromCartCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.GetItemsFromCart at\n%s", m.funcGetItemsFromCartOrigin)
	}

	if !m.GetItemsFromCartMock.invocationsDone() && afterGetItemsFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.GetItemsFromCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsFromCartMock.expectedInvocations), m.GetItemsFromCartMock.expectedInvocationsOrigin, afterGetItemsFromCartCounter)
	}
}

type mServiceMockOrderCreate struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockOrderCreateExpectation
	expectations       []*ServiceMockOrderCreateExpectation

	callArgs []*ServiceMockOrderCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockOrderCreateExpectation specifies expectation struct of the Service.OrderCreate
type ServiceMockOrderCreateExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockOrderCreateParams
	paramPtrs          *ServiceMockOrderCreateParamPtrs
	expectationOrigins ServiceMockOrderCreateExpectationOrigins
	results            *ServiceMockOrderCreateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockOrderCreateParams contains parameters of the Service.OrderCreate
type ServiceMockOrderCreateParams struct {
	ctx    context.Context
	UserID int64
	items  *model.GetItemsFromCartResponce
}

// ServiceMockOrderCreateParamPtrs contains pointers to parameters of the Service.OrderCreate
type ServiceMockOrderCreateParamPtrs struct {
	ctx    *context.Context
	UserID *int64
	items  **model.GetItemsFromCartResponce
}

// ServiceMockOrderCreateResults contains results of the Service.OrderCreate
type ServiceMockOrderCreateResults struct {
	i1  int64
	err error
}

// ServiceMockOrderCreateOrigins contains origins of expectations of the Service.OrderCreate
type ServiceMockOrderCreateExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItems  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreate *mServiceMockOrderCreate) Optional() *mServiceMockOrderCreate {
	mmOrderCreate.optional = true
	return mmOrderCreate
}

// Expect sets up expected params for Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) Expect(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce) *mServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &ServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.paramPtrs != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by ExpectParams functions")
	}

	mmOrderCreate.defaultExpectation.params = &ServiceMockOrderCreateParams{ctx, UserID, items}
	mmOrderCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// ExpectCtxParam1 sets up expected param ctx for Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) ExpectCtxParam1(ctx context.Context) *mServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &ServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &ServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCreate
}

// ExpectUserIDParam2 sets up expected param UserID for Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) ExpectUserIDParam2(UserID int64) *mServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &ServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &ServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.UserID = &UserID
	mmOrderCreate.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmOrderCreate
}

// ExpectItemsParam3 sets up expected param items for Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) ExpectItemsParam3(items *model.GetItemsFromCartResponce) *mServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &ServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &ServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.items = &items
	mmOrderCreate.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) Inspect(f func(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce)) *mServiceMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for ServiceMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by Service.OrderCreate
func (mmOrderCreate *mServiceMockOrderCreate) Return(i1 int64, err error) *ServiceMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &ServiceMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &ServiceMockOrderCreateResults{i1, err}
	mmOrderCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// Set uses given function f to mock the Service.OrderCreate method
func (mmOrderCreate *mServiceMockOrderCreate) Set(f func(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce) (i1 int64, err error)) *ServiceMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the Service.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the Service.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	mmOrderCreate.mock.funcOrderCreateOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// When sets expectation for the Service.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mServiceMockOrderCreate) When(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce) *ServiceMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("ServiceMock.OrderCreate mock is already set by Set")
	}

	expectation := &ServiceMockOrderCreateExpectation{
		mock:               mmOrderCreate.mock,
		params:             &ServiceMockOrderCreateParams{ctx, UserID, items},
		expectationOrigins: ServiceMockOrderCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up Service.OrderCreate return parameters for the expectation previously defined by the When method
func (e *ServiceMockOrderCreateExpectation) Then(i1 int64, err error) *ServiceMock {
	e.results = &ServiceMockOrderCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Service.OrderCreate should be invoked
func (mmOrderCreate *mServiceMockOrderCreate) Times(n uint64) *mServiceMockOrderCreate {
	if n == 0 {
		mmOrderCreate.mock.t.Fatalf("Times of ServiceMock.OrderCreate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreate.expectedInvocations, n)
	mmOrderCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCreate
}

func (mmOrderCreate *mServiceMockOrderCreate) invocationsDone() bool {
	if len(mmOrderCreate.expectations) == 0 && mmOrderCreate.defaultExpectation == nil && mmOrderCreate.mock.funcOrderCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreate.mock.afterOrderCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreate implements mm_server.Service
func (mmOrderCreate *ServiceMock) OrderCreate(ctx context.Context, UserID int64, items *model.GetItemsFromCartResponce) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	mmOrderCreate.t.Helper()

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, UserID, items)
	}

	mm_params := ServiceMockOrderCreateParams{ctx, UserID, items}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreate.OrderCreateMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockOrderCreateParams{ctx, UserID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreate.t.Errorf("ServiceMock.OrderCreate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.UserID != nil && !minimock.Equal(*mm_want_ptrs.UserID, mm_got.UserID) {
				mmOrderCreate.t.Errorf("ServiceMock.OrderCreate got unexpected parameter UserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.UserID, mm_got.UserID, minimock.Diff(*mm_want_ptrs.UserID, mm_got.UserID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmOrderCreate.t.Errorf("ServiceMock.OrderCreate got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("ServiceMock.OrderCreate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the ServiceMock.OrderCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, UserID, items)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to ServiceMock.OrderCreate. %v %v %v", ctx, UserID, items)
	return
}

// OrderCreateAfterCounter returns a count of finished ServiceMock.OrderCreate invocations
func (mmOrderCreate *ServiceMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of ServiceMock.OrderCreate invocations
func (mmOrderCreate *ServiceMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mServiceMockOrderCreate) Calls() []*ServiceMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*ServiceMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockOrderCreateDone() bool {
	if m.OrderCreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateMock.invocationsDone()
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *ServiceMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.OrderCreate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCreateCounter := mm_atomic.LoadUint64(&m.afterOrderCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && afterOrderCreateCounter < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.OrderCreate at\n%s", m.OrderCreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.OrderCreate at\n%s with params: %#v", m.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && afterOrderCreateCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.OrderCreate at\n%s", m.funcOrderCreateOrigin)
	}

	if !m.OrderCreateMock.invocationsDone() && afterOrderCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.OrderCreate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateMock.expectedInvocations), m.OrderCreateMock.expectedInvocationsOrigin, afterOrderCreateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserIDInspect()

			m.MinimockGetItemsFromCartInspect()

			m.MinimockOrderCreateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetItemsFromCartDone() &&
		m.MinimockOrderCreateDone()
}
