// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/cart/internal/domain/service.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/cart/internal/domain/model"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_service.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, cartItems model.RequestData) (err error)
	funcAddOrigin    string
	inspectFuncAdd   func(ctx context.Context, cartItems model.RequestData)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mRepositoryMockAdd

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRepositoryMockClose

	funcDeleteAllItemsFromCart          func(ctx context.Context, cartItems model.RequestData) (err error)
	funcDeleteAllItemsFromCartOrigin    string
	inspectFuncDeleteAllItemsFromCart   func(ctx context.Context, cartItems model.RequestData)
	afterDeleteAllItemsFromCartCounter  uint64
	beforeDeleteAllItemsFromCartCounter uint64
	DeleteAllItemsFromCartMock          mRepositoryMockDeleteAllItemsFromCart

	funcDeleteItemsBySku          func(ctx context.Context, cartItems model.RequestData) (err error)
	funcDeleteItemsBySkuOrigin    string
	inspectFuncDeleteItemsBySku   func(ctx context.Context, cartItems model.RequestData)
	afterDeleteItemsBySkuCounter  uint64
	beforeDeleteItemsBySkuCounter uint64
	DeleteItemsBySkuMock          mRepositoryMockDeleteItemsBySku

	funcGetItemsByUserID          func(ctx context.Context, cartItems model.RequestData) (ca1 []model.Cart, err error)
	funcGetItemsByUserIDOrigin    string
	inspectFuncGetItemsByUserID   func(ctx context.Context, cartItems model.RequestData)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mRepositoryMockGetItemsByUserID
}

// NewRepositoryMock returns a mock for mm_service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*RepositoryMockAddParams{}

	m.CloseMock = mRepositoryMockClose{mock: m}

	m.DeleteAllItemsFromCartMock = mRepositoryMockDeleteAllItemsFromCart{mock: m}
	m.DeleteAllItemsFromCartMock.callArgs = []*RepositoryMockDeleteAllItemsFromCartParams{}

	m.DeleteItemsBySkuMock = mRepositoryMockDeleteItemsBySku{mock: m}
	m.DeleteItemsBySkuMock.callArgs = []*RepositoryMockDeleteItemsBySkuParams{}

	m.GetItemsByUserIDMock = mRepositoryMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*RepositoryMockGetItemsByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAdd struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddExpectation
	expectations       []*RepositoryMockAddExpectation

	callArgs []*RepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddExpectation specifies expectation struct of the Repository.Add
type RepositoryMockAddExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddParams
	paramPtrs          *RepositoryMockAddParamPtrs
	expectationOrigins RepositoryMockAddExpectationOrigins
	results            *RepositoryMockAddResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddParams contains parameters of the Repository.Add
type RepositoryMockAddParams struct {
	ctx       context.Context
	cartItems model.RequestData
}

// RepositoryMockAddParamPtrs contains pointers to parameters of the Repository.Add
type RepositoryMockAddParamPtrs struct {
	ctx       *context.Context
	cartItems *model.RequestData
}

// RepositoryMockAddResults contains results of the Repository.Add
type RepositoryMockAddResults struct {
	err error
}

// RepositoryMockAddOrigins contains origins of expectations of the Repository.Add
type RepositoryMockAddExpectationOrigins struct {
	origin          string
	originCtx       string
	originCartItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mRepositoryMockAdd) Optional() *mRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for Repository.Add
func (mmAdd *mRepositoryMockAdd) Expect(ctx context.Context, cartItems model.RequestData) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &RepositoryMockAddParams{ctx, cartItems}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Add
func (mmAdd *mRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &RepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectCartItemsParam2 sets up expected param cartItems for Repository.Add
func (mmAdd *mRepositoryMockAdd) ExpectCartItemsParam2(cartItems model.RequestData) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &RepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.cartItems = &cartItems
	mmAdd.defaultExpectation.expectationOrigins.originCartItems = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the Repository.Add
func (mmAdd *mRepositoryMockAdd) Inspect(f func(ctx context.Context, cartItems model.RequestData)) *mRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by Repository.Add
func (mmAdd *mRepositoryMockAdd) Return(err error) *RepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &RepositoryMockAddResults{err}
	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the Repository.Add method
func (mmAdd *mRepositoryMockAdd) Set(f func(ctx context.Context, cartItems model.RequestData) (err error)) *RepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the Repository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the Repository.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the Repository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mRepositoryMockAdd) When(ctx context.Context, cartItems model.RequestData) *RepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	expectation := &RepositoryMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &RepositoryMockAddParams{ctx, cartItems},
		expectationOrigins: RepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up Repository.Add return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddResults{err}
	return e.mock
}

// Times sets number of times Repository.Add should be invoked
func (mmAdd *mRepositoryMockAdd) Times(n uint64) *mRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of RepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_service.Repository
func (mmAdd *RepositoryMock) Add(ctx context.Context, cartItems model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, cartItems)
	}

	mm_params := RepositoryMockAddParams{ctx, cartItems}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddParams{ctx, cartItems}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItems != nil && !minimock.Equal(*mm_want_ptrs.cartItems, mm_got.cartItems) {
				mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameter cartItems, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCartItems, *mm_want_ptrs.cartItems, mm_got.cartItems, minimock.Diff(*mm_want_ptrs.cartItems, mm_got.cartItems))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the RepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, cartItems)
	}
	mmAdd.t.Fatalf("Unexpected call to RepositoryMock.Add. %v %v", ctx, cartItems)
	return
}

// AddAfterCounter returns a count of finished RepositoryMock.Add invocations
func (mmAdd *RepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of RepositoryMock.Add invocations
func (mmAdd *RepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mRepositoryMockAdd) Calls() []*RepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*RepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mRepositoryMockClose struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCloseExpectation
	expectations       []*RepositoryMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCloseExpectation specifies expectation struct of the Repository.Close
type RepositoryMockCloseExpectation struct {
	mock *RepositoryMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mRepositoryMockClose) Optional() *mRepositoryMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Repository.Close
func (mmClose *mRepositoryMockClose) Expect() *mRepositoryMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RepositoryMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RepositoryMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Repository.Close
func (mmClose *mRepositoryMockClose) Inspect(f func()) *mRepositoryMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Repository.Close
func (mmClose *mRepositoryMockClose) Return() *RepositoryMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RepositoryMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RepositoryMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Repository.Close method
func (mmClose *mRepositoryMockClose) Set(f func()) *RepositoryMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Repository.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Repository.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Repository.Close should be invoked
func (mmClose *mRepositoryMockClose) Times(n uint64) *mRepositoryMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of RepositoryMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mRepositoryMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_service.Repository
func (mmClose *RepositoryMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to RepositoryMock.Close.")

}

// CloseAfterCounter returns a count of finished RepositoryMock.Close invocations
func (mmClose *RepositoryMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RepositoryMock.Close invocations
func (mmClose *RepositoryMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mRepositoryMockDeleteAllItemsFromCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteAllItemsFromCartExpectation
	expectations       []*RepositoryMockDeleteAllItemsFromCartExpectation

	callArgs []*RepositoryMockDeleteAllItemsFromCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteAllItemsFromCartExpectation specifies expectation struct of the Repository.DeleteAllItemsFromCart
type RepositoryMockDeleteAllItemsFromCartExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteAllItemsFromCartParams
	paramPtrs          *RepositoryMockDeleteAllItemsFromCartParamPtrs
	expectationOrigins RepositoryMockDeleteAllItemsFromCartExpectationOrigins
	results            *RepositoryMockDeleteAllItemsFromCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteAllItemsFromCartParams contains parameters of the Repository.DeleteAllItemsFromCart
type RepositoryMockDeleteAllItemsFromCartParams struct {
	ctx       context.Context
	cartItems model.RequestData
}

// RepositoryMockDeleteAllItemsFromCartParamPtrs contains pointers to parameters of the Repository.DeleteAllItemsFromCart
type RepositoryMockDeleteAllItemsFromCartParamPtrs struct {
	ctx       *context.Context
	cartItems *model.RequestData
}

// RepositoryMockDeleteAllItemsFromCartResults contains results of the Repository.DeleteAllItemsFromCart
type RepositoryMockDeleteAllItemsFromCartResults struct {
	err error
}

// RepositoryMockDeleteAllItemsFromCartOrigins contains origins of expectations of the Repository.DeleteAllItemsFromCart
type RepositoryMockDeleteAllItemsFromCartExpectationOrigins struct {
	origin          string
	originCtx       string
	originCartItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Optional() *mRepositoryMockDeleteAllItemsFromCart {
	mmDeleteAllItemsFromCart.optional = true
	return mmDeleteAllItemsFromCart
}

// Expect sets up expected params for Repository.DeleteAllItemsFromCart
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Expect(ctx context.Context, cartItems model.RequestData) *mRepositoryMockDeleteAllItemsFromCart {
	if mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Set")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation == nil {
		mmDeleteAllItemsFromCart.defaultExpectation = &RepositoryMockDeleteAllItemsFromCartExpectation{}
	}

	if mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by ExpectParams functions")
	}

	mmDeleteAllItemsFromCart.defaultExpectation.params = &RepositoryMockDeleteAllItemsFromCartParams{ctx, cartItems}
	mmDeleteAllItemsFromCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAllItemsFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteAllItemsFromCart.defaultExpectation.params) {
			mmDeleteAllItemsFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAllItemsFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteAllItemsFromCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteAllItemsFromCart
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteAllItemsFromCart {
	if mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Set")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation == nil {
		mmDeleteAllItemsFromCart.defaultExpectation = &RepositoryMockDeleteAllItemsFromCartExpectation{}
	}

	if mmDeleteAllItemsFromCart.defaultExpectation.params != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Expect")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllItemsFromCartParamPtrs{}
	}
	mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAllItemsFromCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAllItemsFromCart
}

// ExpectCartItemsParam2 sets up expected param cartItems for Repository.DeleteAllItemsFromCart
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) ExpectCartItemsParam2(cartItems model.RequestData) *mRepositoryMockDeleteAllItemsFromCart {
	if mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Set")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation == nil {
		mmDeleteAllItemsFromCart.defaultExpectation = &RepositoryMockDeleteAllItemsFromCartExpectation{}
	}

	if mmDeleteAllItemsFromCart.defaultExpectation.params != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Expect")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteAllItemsFromCartParamPtrs{}
	}
	mmDeleteAllItemsFromCart.defaultExpectation.paramPtrs.cartItems = &cartItems
	mmDeleteAllItemsFromCart.defaultExpectation.expectationOrigins.originCartItems = minimock.CallerInfo(1)

	return mmDeleteAllItemsFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteAllItemsFromCart
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Inspect(f func(ctx context.Context, cartItems model.RequestData)) *mRepositoryMockDeleteAllItemsFromCart {
	if mmDeleteAllItemsFromCart.mock.inspectFuncDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteAllItemsFromCart")
	}

	mmDeleteAllItemsFromCart.mock.inspectFuncDeleteAllItemsFromCart = f

	return mmDeleteAllItemsFromCart
}

// Return sets up results that will be returned by Repository.DeleteAllItemsFromCart
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Return(err error) *RepositoryMock {
	if mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Set")
	}

	if mmDeleteAllItemsFromCart.defaultExpectation == nil {
		mmDeleteAllItemsFromCart.defaultExpectation = &RepositoryMockDeleteAllItemsFromCartExpectation{mock: mmDeleteAllItemsFromCart.mock}
	}
	mmDeleteAllItemsFromCart.defaultExpectation.results = &RepositoryMockDeleteAllItemsFromCartResults{err}
	mmDeleteAllItemsFromCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAllItemsFromCart.mock
}

// Set uses given function f to mock the Repository.DeleteAllItemsFromCart method
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Set(f func(ctx context.Context, cartItems model.RequestData) (err error)) *RepositoryMock {
	if mmDeleteAllItemsFromCart.defaultExpectation != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteAllItemsFromCart method")
	}

	if len(mmDeleteAllItemsFromCart.expectations) > 0 {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteAllItemsFromCart method")
	}

	mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart = f
	mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCartOrigin = minimock.CallerInfo(1)
	return mmDeleteAllItemsFromCart.mock
}

// When sets expectation for the Repository.DeleteAllItemsFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) When(ctx context.Context, cartItems model.RequestData) *RepositoryMockDeleteAllItemsFromCartExpectation {
	if mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("RepositoryMock.DeleteAllItemsFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteAllItemsFromCartExpectation{
		mock:               mmDeleteAllItemsFromCart.mock,
		params:             &RepositoryMockDeleteAllItemsFromCartParams{ctx, cartItems},
		expectationOrigins: RepositoryMockDeleteAllItemsFromCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAllItemsFromCart.expectations = append(mmDeleteAllItemsFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteAllItemsFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteAllItemsFromCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteAllItemsFromCartResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteAllItemsFromCart should be invoked
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Times(n uint64) *mRepositoryMockDeleteAllItemsFromCart {
	if n == 0 {
		mmDeleteAllItemsFromCart.mock.t.Fatalf("Times of RepositoryMock.DeleteAllItemsFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAllItemsFromCart.expectedInvocations, n)
	mmDeleteAllItemsFromCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAllItemsFromCart
}

func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) invocationsDone() bool {
	if len(mmDeleteAllItemsFromCart.expectations) == 0 && mmDeleteAllItemsFromCart.defaultExpectation == nil && mmDeleteAllItemsFromCart.mock.funcDeleteAllItemsFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAllItemsFromCart.mock.afterDeleteAllItemsFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAllItemsFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAllItemsFromCart implements mm_service.Repository
func (mmDeleteAllItemsFromCart *RepositoryMock) DeleteAllItemsFromCart(ctx context.Context, cartItems model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmDeleteAllItemsFromCart.beforeDeleteAllItemsFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAllItemsFromCart.afterDeleteAllItemsFromCartCounter, 1)

	mmDeleteAllItemsFromCart.t.Helper()

	if mmDeleteAllItemsFromCart.inspectFuncDeleteAllItemsFromCart != nil {
		mmDeleteAllItemsFromCart.inspectFuncDeleteAllItemsFromCart(ctx, cartItems)
	}

	mm_params := RepositoryMockDeleteAllItemsFromCartParams{ctx, cartItems}

	// Record call args
	mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.mutex.Lock()
	mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.callArgs = append(mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.callArgs, &mm_params)
	mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteAllItemsFromCartParams{ctx, cartItems}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAllItemsFromCart.t.Errorf("RepositoryMock.DeleteAllItemsFromCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItems != nil && !minimock.Equal(*mm_want_ptrs.cartItems, mm_got.cartItems) {
				mmDeleteAllItemsFromCart.t.Errorf("RepositoryMock.DeleteAllItemsFromCart got unexpected parameter cartItems, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.expectationOrigins.originCartItems, *mm_want_ptrs.cartItems, mm_got.cartItems, minimock.Diff(*mm_want_ptrs.cartItems, mm_got.cartItems))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAllItemsFromCart.t.Errorf("RepositoryMock.DeleteAllItemsFromCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAllItemsFromCart.DeleteAllItemsFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAllItemsFromCart.t.Fatal("No results are set for the RepositoryMock.DeleteAllItemsFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteAllItemsFromCart.funcDeleteAllItemsFromCart != nil {
		return mmDeleteAllItemsFromCart.funcDeleteAllItemsFromCart(ctx, cartItems)
	}
	mmDeleteAllItemsFromCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteAllItemsFromCart. %v %v", ctx, cartItems)
	return
}

// DeleteAllItemsFromCartAfterCounter returns a count of finished RepositoryMock.DeleteAllItemsFromCart invocations
func (mmDeleteAllItemsFromCart *RepositoryMock) DeleteAllItemsFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllItemsFromCart.afterDeleteAllItemsFromCartCounter)
}

// DeleteAllItemsFromCartBeforeCounter returns a count of RepositoryMock.DeleteAllItemsFromCart invocations
func (mmDeleteAllItemsFromCart *RepositoryMock) DeleteAllItemsFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAllItemsFromCart.beforeDeleteAllItemsFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteAllItemsFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAllItemsFromCart *mRepositoryMockDeleteAllItemsFromCart) Calls() []*RepositoryMockDeleteAllItemsFromCartParams {
	mmDeleteAllItemsFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteAllItemsFromCartParams, len(mmDeleteAllItemsFromCart.callArgs))
	copy(argCopy, mmDeleteAllItemsFromCart.callArgs)

	mmDeleteAllItemsFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAllItemsFromCartDone returns true if the count of the DeleteAllItemsFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteAllItemsFromCartDone() bool {
	if m.DeleteAllItemsFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAllItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAllItemsFromCartMock.invocationsDone()
}

// MinimockDeleteAllItemsFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteAllItemsFromCartInspect() {
	for _, e := range m.DeleteAllItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllItemsFromCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAllItemsFromCartCounter := mm_atomic.LoadUint64(&m.afterDeleteAllItemsFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAllItemsFromCartMock.defaultExpectation != nil && afterDeleteAllItemsFromCartCounter < 1 {
		if m.DeleteAllItemsFromCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllItemsFromCart at\n%s", m.DeleteAllItemsFromCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteAllItemsFromCart at\n%s with params: %#v", m.DeleteAllItemsFromCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAllItemsFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAllItemsFromCart != nil && afterDeleteAllItemsFromCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteAllItemsFromCart at\n%s", m.funcDeleteAllItemsFromCartOrigin)
	}

	if !m.DeleteAllItemsFromCartMock.invocationsDone() && afterDeleteAllItemsFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteAllItemsFromCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAllItemsFromCartMock.expectedInvocations), m.DeleteAllItemsFromCartMock.expectedInvocationsOrigin, afterDeleteAllItemsFromCartCounter)
	}
}

type mRepositoryMockDeleteItemsBySku struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemsBySkuExpectation
	expectations       []*RepositoryMockDeleteItemsBySkuExpectation

	callArgs []*RepositoryMockDeleteItemsBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteItemsBySkuExpectation specifies expectation struct of the Repository.DeleteItemsBySku
type RepositoryMockDeleteItemsBySkuExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteItemsBySkuParams
	paramPtrs          *RepositoryMockDeleteItemsBySkuParamPtrs
	expectationOrigins RepositoryMockDeleteItemsBySkuExpectationOrigins
	results            *RepositoryMockDeleteItemsBySkuResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteItemsBySkuParams contains parameters of the Repository.DeleteItemsBySku
type RepositoryMockDeleteItemsBySkuParams struct {
	ctx       context.Context
	cartItems model.RequestData
}

// RepositoryMockDeleteItemsBySkuParamPtrs contains pointers to parameters of the Repository.DeleteItemsBySku
type RepositoryMockDeleteItemsBySkuParamPtrs struct {
	ctx       *context.Context
	cartItems *model.RequestData
}

// RepositoryMockDeleteItemsBySkuResults contains results of the Repository.DeleteItemsBySku
type RepositoryMockDeleteItemsBySkuResults struct {
	err error
}

// RepositoryMockDeleteItemsBySkuOrigins contains origins of expectations of the Repository.DeleteItemsBySku
type RepositoryMockDeleteItemsBySkuExpectationOrigins struct {
	origin          string
	originCtx       string
	originCartItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Optional() *mRepositoryMockDeleteItemsBySku {
	mmDeleteItemsBySku.optional = true
	return mmDeleteItemsBySku
}

// Expect sets up expected params for Repository.DeleteItemsBySku
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Expect(ctx context.Context, cartItems model.RequestData) *mRepositoryMockDeleteItemsBySku {
	if mmDeleteItemsBySku.mock.funcDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Set")
	}

	if mmDeleteItemsBySku.defaultExpectation == nil {
		mmDeleteItemsBySku.defaultExpectation = &RepositoryMockDeleteItemsBySkuExpectation{}
	}

	if mmDeleteItemsBySku.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by ExpectParams functions")
	}

	mmDeleteItemsBySku.defaultExpectation.params = &RepositoryMockDeleteItemsBySkuParams{ctx, cartItems}
	mmDeleteItemsBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItemsBySku.expectations {
		if minimock.Equal(e.params, mmDeleteItemsBySku.defaultExpectation.params) {
			mmDeleteItemsBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsBySku.defaultExpectation.params)
		}
	}

	return mmDeleteItemsBySku
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteItemsBySku
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteItemsBySku {
	if mmDeleteItemsBySku.mock.funcDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Set")
	}

	if mmDeleteItemsBySku.defaultExpectation == nil {
		mmDeleteItemsBySku.defaultExpectation = &RepositoryMockDeleteItemsBySkuExpectation{}
	}

	if mmDeleteItemsBySku.defaultExpectation.params != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Expect")
	}

	if mmDeleteItemsBySku.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsBySku.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemsBySkuParamPtrs{}
	}
	mmDeleteItemsBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItemsBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItemsBySku
}

// ExpectCartItemsParam2 sets up expected param cartItems for Repository.DeleteItemsBySku
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) ExpectCartItemsParam2(cartItems model.RequestData) *mRepositoryMockDeleteItemsBySku {
	if mmDeleteItemsBySku.mock.funcDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Set")
	}

	if mmDeleteItemsBySku.defaultExpectation == nil {
		mmDeleteItemsBySku.defaultExpectation = &RepositoryMockDeleteItemsBySkuExpectation{}
	}

	if mmDeleteItemsBySku.defaultExpectation.params != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Expect")
	}

	if mmDeleteItemsBySku.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsBySku.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemsBySkuParamPtrs{}
	}
	mmDeleteItemsBySku.defaultExpectation.paramPtrs.cartItems = &cartItems
	mmDeleteItemsBySku.defaultExpectation.expectationOrigins.originCartItems = minimock.CallerInfo(1)

	return mmDeleteItemsBySku
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteItemsBySku
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Inspect(f func(ctx context.Context, cartItems model.RequestData)) *mRepositoryMockDeleteItemsBySku {
	if mmDeleteItemsBySku.mock.inspectFuncDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItemsBySku")
	}

	mmDeleteItemsBySku.mock.inspectFuncDeleteItemsBySku = f

	return mmDeleteItemsBySku
}

// Return sets up results that will be returned by Repository.DeleteItemsBySku
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Return(err error) *RepositoryMock {
	if mmDeleteItemsBySku.mock.funcDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Set")
	}

	if mmDeleteItemsBySku.defaultExpectation == nil {
		mmDeleteItemsBySku.defaultExpectation = &RepositoryMockDeleteItemsBySkuExpectation{mock: mmDeleteItemsBySku.mock}
	}
	mmDeleteItemsBySku.defaultExpectation.results = &RepositoryMockDeleteItemsBySkuResults{err}
	mmDeleteItemsBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsBySku.mock
}

// Set uses given function f to mock the Repository.DeleteItemsBySku method
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Set(f func(ctx context.Context, cartItems model.RequestData) (err error)) *RepositoryMock {
	if mmDeleteItemsBySku.defaultExpectation != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteItemsBySku method")
	}

	if len(mmDeleteItemsBySku.expectations) > 0 {
		mmDeleteItemsBySku.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteItemsBySku method")
	}

	mmDeleteItemsBySku.mock.funcDeleteItemsBySku = f
	mmDeleteItemsBySku.mock.funcDeleteItemsBySkuOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsBySku.mock
}

// When sets expectation for the Repository.DeleteItemsBySku which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) When(ctx context.Context, cartItems model.RequestData) *RepositoryMockDeleteItemsBySkuExpectation {
	if mmDeleteItemsBySku.mock.funcDeleteItemsBySku != nil {
		mmDeleteItemsBySku.mock.t.Fatalf("RepositoryMock.DeleteItemsBySku mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemsBySkuExpectation{
		mock:               mmDeleteItemsBySku.mock,
		params:             &RepositoryMockDeleteItemsBySkuParams{ctx, cartItems},
		expectationOrigins: RepositoryMockDeleteItemsBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItemsBySku.expectations = append(mmDeleteItemsBySku.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteItemsBySku return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemsBySkuExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemsBySkuResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteItemsBySku should be invoked
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Times(n uint64) *mRepositoryMockDeleteItemsBySku {
	if n == 0 {
		mmDeleteItemsBySku.mock.t.Fatalf("Times of RepositoryMock.DeleteItemsBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsBySku.expectedInvocations, n)
	mmDeleteItemsBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsBySku
}

func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) invocationsDone() bool {
	if len(mmDeleteItemsBySku.expectations) == 0 && mmDeleteItemsBySku.defaultExpectation == nil && mmDeleteItemsBySku.mock.funcDeleteItemsBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsBySku.mock.afterDeleteItemsBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsBySku implements mm_service.Repository
func (mmDeleteItemsBySku *RepositoryMock) DeleteItemsBySku(ctx context.Context, cartItems model.RequestData) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsBySku.beforeDeleteItemsBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsBySku.afterDeleteItemsBySkuCounter, 1)

	mmDeleteItemsBySku.t.Helper()

	if mmDeleteItemsBySku.inspectFuncDeleteItemsBySku != nil {
		mmDeleteItemsBySku.inspectFuncDeleteItemsBySku(ctx, cartItems)
	}

	mm_params := RepositoryMockDeleteItemsBySkuParams{ctx, cartItems}

	// Record call args
	mmDeleteItemsBySku.DeleteItemsBySkuMock.mutex.Lock()
	mmDeleteItemsBySku.DeleteItemsBySkuMock.callArgs = append(mmDeleteItemsBySku.DeleteItemsBySkuMock.callArgs, &mm_params)
	mmDeleteItemsBySku.DeleteItemsBySkuMock.mutex.Unlock()

	for _, e := range mmDeleteItemsBySku.DeleteItemsBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteItemsBySkuParams{ctx, cartItems}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemsBySku.t.Errorf("RepositoryMock.DeleteItemsBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItems != nil && !minimock.Equal(*mm_want_ptrs.cartItems, mm_got.cartItems) {
				mmDeleteItemsBySku.t.Errorf("RepositoryMock.DeleteItemsBySku got unexpected parameter cartItems, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.expectationOrigins.originCartItems, *mm_want_ptrs.cartItems, mm_got.cartItems, minimock.Diff(*mm_want_ptrs.cartItems, mm_got.cartItems))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsBySku.t.Errorf("RepositoryMock.DeleteItemsBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsBySku.DeleteItemsBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsBySku.t.Fatal("No results are set for the RepositoryMock.DeleteItemsBySku")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsBySku.funcDeleteItemsBySku != nil {
		return mmDeleteItemsBySku.funcDeleteItemsBySku(ctx, cartItems)
	}
	mmDeleteItemsBySku.t.Fatalf("Unexpected call to RepositoryMock.DeleteItemsBySku. %v %v", ctx, cartItems)
	return
}

// DeleteItemsBySkuAfterCounter returns a count of finished RepositoryMock.DeleteItemsBySku invocations
func (mmDeleteItemsBySku *RepositoryMock) DeleteItemsBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsBySku.afterDeleteItemsBySkuCounter)
}

// DeleteItemsBySkuBeforeCounter returns a count of RepositoryMock.DeleteItemsBySku invocations
func (mmDeleteItemsBySku *RepositoryMock) DeleteItemsBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsBySku.beforeDeleteItemsBySkuCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItemsBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsBySku *mRepositoryMockDeleteItemsBySku) Calls() []*RepositoryMockDeleteItemsBySkuParams {
	mmDeleteItemsBySku.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemsBySkuParams, len(mmDeleteItemsBySku.callArgs))
	copy(argCopy, mmDeleteItemsBySku.callArgs)

	mmDeleteItemsBySku.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsBySkuDone returns true if the count of the DeleteItemsBySku invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemsBySkuDone() bool {
	if m.DeleteItemsBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsBySkuMock.invocationsDone()
}

// MinimockDeleteItemsBySkuInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemsBySkuInspect() {
	for _, e := range m.DeleteItemsBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsBySkuCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsBySkuMock.defaultExpectation != nil && afterDeleteItemsBySkuCounter < 1 {
		if m.DeleteItemsBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsBySku at\n%s", m.DeleteItemsBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsBySku at\n%s with params: %#v", m.DeleteItemsBySkuMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsBySku != nil && afterDeleteItemsBySkuCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteItemsBySku at\n%s", m.funcDeleteItemsBySkuOrigin)
	}

	if !m.DeleteItemsBySkuMock.invocationsDone() && afterDeleteItemsBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteItemsBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsBySkuMock.expectedInvocations), m.DeleteItemsBySkuMock.expectedInvocationsOrigin, afterDeleteItemsBySkuCounter)
	}
}

type mRepositoryMockGetItemsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetItemsByUserIDExpectation
	expectations       []*RepositoryMockGetItemsByUserIDExpectation

	callArgs []*RepositoryMockGetItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetItemsByUserIDExpectation specifies expectation struct of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetItemsByUserIDParams
	paramPtrs          *RepositoryMockGetItemsByUserIDParamPtrs
	expectationOrigins RepositoryMockGetItemsByUserIDExpectationOrigins
	results            *RepositoryMockGetItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetItemsByUserIDParams contains parameters of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParams struct {
	ctx       context.Context
	cartItems model.RequestData
}

// RepositoryMockGetItemsByUserIDParamPtrs contains pointers to parameters of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParamPtrs struct {
	ctx       *context.Context
	cartItems *model.RequestData
}

// RepositoryMockGetItemsByUserIDResults contains results of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDResults struct {
	ca1 []model.Cart
	err error
}

// RepositoryMockGetItemsByUserIDOrigins contains origins of expectations of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originCartItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Optional() *mRepositoryMockGetItemsByUserID {
	mmGetItemsByUserID.optional = true
	return mmGetItemsByUserID
}

// Expect sets up expected params for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Expect(ctx context.Context, cartItems model.RequestData) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by ExpectParams functions")
	}

	mmGetItemsByUserID.defaultExpectation.params = &RepositoryMockGetItemsByUserIDParams{ctx, cartItems}
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// ExpectCartItemsParam2 sets up expected param cartItems for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectCartItemsParam2(cartItems model.RequestData) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.cartItems = &cartItems
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originCartItems = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Inspect(f func(ctx context.Context, cartItems model.RequestData)) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Return(ca1 []model.Cart, err error) *RepositoryMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &RepositoryMockGetItemsByUserIDResults{ca1, err}
	mmGetItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the Repository.GetItemsByUserID method
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Set(f func(ctx context.Context, cartItems model.RequestData) (ca1 []model.Cart, err error)) *RepositoryMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	mmGetItemsByUserID.mock.funcGetItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// When sets expectation for the Repository.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) When(ctx context.Context, cartItems model.RequestData) *RepositoryMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockGetItemsByUserIDExpectation{
		mock:               mmGetItemsByUserID.mock,
		params:             &RepositoryMockGetItemsByUserIDParams{ctx, cartItems},
		expectationOrigins: RepositoryMockGetItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetItemsByUserIDExpectation) Then(ca1 []model.Cart, err error) *RepositoryMock {
	e.results = &RepositoryMockGetItemsByUserIDResults{ca1, err}
	return e.mock
}

// Times sets number of times Repository.GetItemsByUserID should be invoked
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Times(n uint64) *mRepositoryMockGetItemsByUserID {
	if n == 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Times of RepositoryMock.GetItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUserID.expectedInvocations, n)
	mmGetItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID
}

func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) invocationsDone() bool {
	if len(mmGetItemsByUserID.expectations) == 0 && mmGetItemsByUserID.defaultExpectation == nil && mmGetItemsByUserID.mock.funcGetItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.mock.afterGetItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUserID implements mm_service.Repository
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserID(ctx context.Context, cartItems model.RequestData) (ca1 []model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	mmGetItemsByUserID.t.Helper()

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, cartItems)
	}

	mm_params := RepositoryMockGetItemsByUserIDParams{ctx, cartItems}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, &mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetItemsByUserIDParams{ctx, cartItems}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItems != nil && !minimock.Equal(*mm_want_ptrs.cartItems, mm_got.cartItems) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter cartItems, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originCartItems, *mm_want_ptrs.cartItems, mm_got.cartItems, minimock.Diff(*mm_want_ptrs.cartItems, mm_got.cartItems))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the RepositoryMock.GetItemsByUserID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, cartItems)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to RepositoryMock.GetItemsByUserID. %v %v", ctx, cartItems)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Calls() []*RepositoryMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetItemsByUserIDDone() bool {
	if m.GetItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserIDMock.invocationsDone()
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && afterGetItemsByUserIDCounter < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s", m.GetItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s with params: %#v", m.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && afterGetItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID at\n%s", m.funcGetItemsByUserIDOrigin)
	}

	if !m.GetItemsByUserIDMock.invocationsDone() && afterGetItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserIDMock.expectedInvocations), m.GetItemsByUserIDMock.expectedInvocationsOrigin, afterGetItemsByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockCloseInspect()

			m.MinimockDeleteAllItemsFromCartInspect()

			m.MinimockDeleteItemsBySkuInspect()

			m.MinimockGetItemsByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockCloseDone() &&
		m.MinimockDeleteAllItemsFromCartDone() &&
		m.MinimockDeleteItemsBySkuDone() &&
		m.MinimockGetItemsByUserIDDone()
}
