// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package repository_sqlc

import (
	"context"
)

const addOrderToOrders = `-- name: AddOrderToOrders :one
INSERT INTO orders (user_id) VALUES ($1) returning id
`

func (q *Queries) AddOrderToOrders(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, addOrderToOrders, userID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addOrderToOrdersItems = `-- name: AddOrderToOrdersItems :exec
INSERT INTO orders_items (order_id, sku, count) VALUES
($1, $2, $3),
($4, $5, $6),
($7, $8, $9),
($10, $11, $12),
($13, $14, $15)
`

type AddOrderToOrdersItemsParams struct {
	OrderID   int64
	Sku       int64
	Count     *int64
	OrderID_2 int64
	Sku_2     int64
	Count_2   *int64
	OrderID_3 int64
	Sku_3     int64
	Count_3   *int64
	OrderID_4 int64
	Sku_4     int64
	Count_4   *int64
	OrderID_5 int64
	Sku_5     int64
	Count_5   *int64
}

func (q *Queries) AddOrderToOrdersItems(ctx context.Context, arg *AddOrderToOrdersItemsParams) error {
	_, err := q.db.Exec(ctx, addOrderToOrdersItems,
		arg.OrderID,
		arg.Sku,
		arg.Count,
		arg.OrderID_2,
		arg.Sku_2,
		arg.Count_2,
		arg.OrderID_3,
		arg.Sku_3,
		arg.Count_3,
		arg.OrderID_4,
		arg.Sku_4,
		arg.Count_4,
		arg.OrderID_5,
		arg.Sku_5,
		arg.Count_5,
	)
	return err
}

const addOutbox = `-- name: AddOutbox :exec
INSERT INTO outbox (topic, key, payload) VALUES ($1, $2, $3)
`

type AddOutboxParams struct {
	Topic   string
	Key     *string
	Payload []byte
}

func (q *Queries) AddOutbox(ctx context.Context, arg *AddOutboxParams) error {
	_, err := q.db.Exec(ctx, addOutbox, arg.Topic, arg.Key, arg.Payload)
	return err
}

const deleteOrders = `-- name: DeleteOrders :exec
DELETE FROM orders WHERE id = $1
`

func (q *Queries) DeleteOrders(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrders, id)
	return err
}

const deleteOrdersItems = `-- name: DeleteOrdersItems :exec
DELETE FROM orders_items WHERE order_id = $1
`

func (q *Queries) DeleteOrdersItems(ctx context.Context, orderID int64) error {
	_, err := q.db.Exec(ctx, deleteOrdersItems, orderID)
	return err
}

const getInfoOrders = `-- name: GetInfoOrders :many
SELECT user_id, status FROM orders WHERE id = $1
`

type GetInfoOrdersRow struct {
	UserID int64
	Status string
}

func (q *Queries) GetInfoOrders(ctx context.Context, id int64) ([]*GetInfoOrdersRow, error) {
	rows, err := q.db.Query(ctx, getInfoOrders, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetInfoOrdersRow
	for rows.Next() {
		var i GetInfoOrdersRow
		if err := rows.Scan(&i.UserID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInfoOrdersItems = `-- name: GetInfoOrdersItems :many
SELECT sku, count FROM orders_items WHERE order_id = $1
`

type GetInfoOrdersItemsRow struct {
	Sku   int64
	Count *int64
}

func (q *Queries) GetInfoOrdersItems(ctx context.Context, orderID int64) ([]*GetInfoOrdersItemsRow, error) {
	rows, err := q.db.Query(ctx, getInfoOrdersItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetInfoOrdersItemsRow
	for rows.Next() {
		var i GetInfoOrdersItemsRow
		if err := rows.Scan(&i.Sku, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewMsgOutbox = `-- name: GetNewMsgOutbox :many
SELECT id, topic, key, payload FROM outbox WHERE status = 'new' ORDER BY created_at ASC, id ASC LIMIT 100 FOR UPDATE SKIP LOCKED
`

type GetNewMsgOutboxRow struct {
	ID      int64
	Topic   string
	Key     *string
	Payload []byte
}

func (q *Queries) GetNewMsgOutbox(ctx context.Context) ([]*GetNewMsgOutboxRow, error) {
	rows, err := q.db.Query(ctx, getNewMsgOutbox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewMsgOutboxRow
	for rows.Next() {
		var i GetNewMsgOutboxRow
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Key,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservedStocksBySku = `-- name: GetReservedStocksBySku :many
SELECT reserved FROM stocks WHERE sku = $1
`

func (q *Queries) GetReservedStocksBySku(ctx context.Context, sku int64) ([]*int64, error) {
	rows, err := q.db.Query(ctx, getReservedStocksBySku, sku)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*int64
	for rows.Next() {
		var reserved *int64
		if err := rows.Scan(&reserved); err != nil {
			return nil, err
		}
		items = append(items, reserved)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStocksBySku = `-- name: GetStocksBySku :many
SELECT total_count, reserved FROM stocks WHERE sku = $1
`

type GetStocksBySkuRow struct {
	TotalCount *int64
	Reserved   *int64
}

func (q *Queries) GetStocksBySku(ctx context.Context, sku int64) ([]*GetStocksBySkuRow, error) {
	rows, err := q.db.Query(ctx, getStocksBySku, sku)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStocksBySkuRow
	for rows.Next() {
		var i GetStocksBySkuRow
		if err := rows.Scan(&i.TotalCount, &i.Reserved); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStocksBySkuForUpdate = `-- name: GetStocksBySkuForUpdate :many
SELECT total_count, reserved FROM stocks WHERE sku = $1 FOR UPDATE
`

type GetStocksBySkuForUpdateRow struct {
	TotalCount *int64
	Reserved   *int64
}

func (q *Queries) GetStocksBySkuForUpdate(ctx context.Context, sku int64) ([]*GetStocksBySkuForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getStocksBySkuForUpdate, sku)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetStocksBySkuForUpdateRow
	for rows.Next() {
		var i GetStocksBySkuForUpdateRow
		if err := rows.Scan(&i.TotalCount, &i.Reserved); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reserveCancel = `-- name: ReserveCancel :exec
UPDATE stocks SET reserved = $1 WHERE sku = $2
`

type ReserveCancelParams struct {
	Reserved *int64
	Sku      int64
}

func (q *Queries) ReserveCancel(ctx context.Context, arg *ReserveCancelParams) error {
	_, err := q.db.Exec(ctx, reserveCancel, arg.Reserved, arg.Sku)
	return err
}

const reserveRemove = `-- name: ReserveRemove :exec
UPDATE stocks SET total_count = $1, reserved = $2 WHERE sku = $3
`

type ReserveRemoveParams struct {
	TotalCount *int64
	Reserved   *int64
	Sku        int64
}

func (q *Queries) ReserveRemove(ctx context.Context, arg *ReserveRemoveParams) error {
	_, err := q.db.Exec(ctx, reserveRemove, arg.TotalCount, arg.Reserved, arg.Sku)
	return err
}

const reserveStockBySku = `-- name: ReserveStockBySku :exec
UPDATE stocks SET reserved = $1 WHERE sku = $2
`

type ReserveStockBySkuParams struct {
	Reserved *int64
	Sku      int64
}

func (q *Queries) ReserveStockBySku(ctx context.Context, arg *ReserveStockBySkuParams) error {
	_, err := q.db.Exec(ctx, reserveStockBySku, arg.Reserved, arg.Sku)
	return err
}

const setStatusOrder = `-- name: SetStatusOrder :exec
UPDATE orders SET status = $1 WHERE id = $2
`

type SetStatusOrderParams struct {
	Status string
	ID     int64
}

func (q *Queries) SetStatusOrder(ctx context.Context, arg *SetStatusOrderParams) error {
	_, err := q.db.Exec(ctx, setStatusOrder, arg.Status, arg.ID)
	return err
}

const updateStatusMsgOutbox = `-- name: UpdateStatusMsgOutbox :exec
UPDATE outbox SET status=$1, sent_at=now() WHERE id = $2
`

type UpdateStatusMsgOutboxParams struct {
	Status string
	ID     int64
}

func (q *Queries) UpdateStatusMsgOutbox(ctx context.Context, arg *UpdateStatusMsgOutboxParams) error {
	_, err := q.db.Exec(ctx, updateStatusMsgOutbox, arg.Status, arg.ID)
	return err
}
