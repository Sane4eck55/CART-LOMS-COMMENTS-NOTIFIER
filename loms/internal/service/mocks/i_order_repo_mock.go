// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/service.IOrderRepo -o i_order_repo_mock.go -n IOrderRepoMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IOrderRepoMock implements mm_service.IOrderRepo
type IOrderRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, usersOrders model.Order) (i1 int64, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, usersOrders model.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mIOrderRepoMockCreateOrder

	funcGetInfoByOrderID          func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)
	funcGetInfoByOrderIDOrigin    string
	inspectFuncGetInfoByOrderID   func(ctx context.Context, orderID int64)
	afterGetInfoByOrderIDCounter  uint64
	beforeGetInfoByOrderIDCounter uint64
	GetInfoByOrderIDMock          mIOrderRepoMockGetInfoByOrderID

	funcSetStatusOrder          func(ctx context.Context, orderID int64, status string) (err error)
	funcSetStatusOrderOrigin    string
	inspectFuncSetStatusOrder   func(ctx context.Context, orderID int64, status string)
	afterSetStatusOrderCounter  uint64
	beforeSetStatusOrderCounter uint64
	SetStatusOrderMock          mIOrderRepoMockSetStatusOrder
}

// NewIOrderRepoMock returns a mock for mm_service.IOrderRepo
func NewIOrderRepoMock(t minimock.Tester) *IOrderRepoMock {
	m := &IOrderRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mIOrderRepoMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*IOrderRepoMockCreateOrderParams{}

	m.GetInfoByOrderIDMock = mIOrderRepoMockGetInfoByOrderID{mock: m}
	m.GetInfoByOrderIDMock.callArgs = []*IOrderRepoMockGetInfoByOrderIDParams{}

	m.SetStatusOrderMock = mIOrderRepoMockSetStatusOrder{mock: m}
	m.SetStatusOrderMock.callArgs = []*IOrderRepoMockSetStatusOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOrderRepoMockCreateOrder struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockCreateOrderExpectation
	expectations       []*IOrderRepoMockCreateOrderExpectation

	callArgs []*IOrderRepoMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockCreateOrderExpectation specifies expectation struct of the IOrderRepo.CreateOrder
type IOrderRepoMockCreateOrderExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockCreateOrderParams
	paramPtrs          *IOrderRepoMockCreateOrderParamPtrs
	expectationOrigins IOrderRepoMockCreateOrderExpectationOrigins
	results            *IOrderRepoMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockCreateOrderParams contains parameters of the IOrderRepo.CreateOrder
type IOrderRepoMockCreateOrderParams struct {
	ctx         context.Context
	usersOrders model.Order
}

// IOrderRepoMockCreateOrderParamPtrs contains pointers to parameters of the IOrderRepo.CreateOrder
type IOrderRepoMockCreateOrderParamPtrs struct {
	ctx         *context.Context
	usersOrders *model.Order
}

// IOrderRepoMockCreateOrderResults contains results of the IOrderRepo.CreateOrder
type IOrderRepoMockCreateOrderResults struct {
	i1  int64
	err error
}

// IOrderRepoMockCreateOrderOrigins contains origins of expectations of the IOrderRepo.CreateOrder
type IOrderRepoMockCreateOrderExpectationOrigins struct {
	origin            string
	originCtx         string
	originUsersOrders string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Optional() *mIOrderRepoMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for IOrderRepo.CreateOrder
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Expect(ctx context.Context, usersOrders model.Order) *mIOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &IOrderRepoMockCreateOrderParams{ctx, usersOrders}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.CreateOrder
func (mmCreateOrder *mIOrderRepoMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &IOrderRepoMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectUsersOrdersParam2 sets up expected param usersOrders for IOrderRepo.CreateOrder
func (mmCreateOrder *mIOrderRepoMockCreateOrder) ExpectUsersOrdersParam2(usersOrders model.Order) *mIOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &IOrderRepoMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.usersOrders = &usersOrders
	mmCreateOrder.defaultExpectation.expectationOrigins.originUsersOrders = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.CreateOrder
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Inspect(f func(ctx context.Context, usersOrders model.Order)) *mIOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by IOrderRepo.CreateOrder
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Return(i1 int64, err error) *IOrderRepoMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepoMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &IOrderRepoMockCreateOrderResults{i1, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the IOrderRepo.CreateOrder method
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Set(f func(ctx context.Context, usersOrders model.Order) (i1 int64, err error)) *IOrderRepoMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the IOrderRepo.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mIOrderRepoMockCreateOrder) When(ctx context.Context, usersOrders model.Order) *IOrderRepoMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepoMock.CreateOrder mock is already set by Set")
	}

	expectation := &IOrderRepoMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &IOrderRepoMockCreateOrderParams{ctx, usersOrders},
		expectationOrigins: IOrderRepoMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.CreateOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockCreateOrderExpectation) Then(i1 int64, err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockCreateOrderResults{i1, err}
	return e.mock
}

// Times sets number of times IOrderRepo.CreateOrder should be invoked
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Times(n uint64) *mIOrderRepoMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of IOrderRepoMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mIOrderRepoMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_service.IOrderRepo
func (mmCreateOrder *IOrderRepoMock) CreateOrder(ctx context.Context, usersOrders model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, usersOrders)
	}

	mm_params := IOrderRepoMockCreateOrderParams{ctx, usersOrders}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockCreateOrderParams{ctx, usersOrders}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("IOrderRepoMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.usersOrders != nil && !minimock.Equal(*mm_want_ptrs.usersOrders, mm_got.usersOrders) {
				mmCreateOrder.t.Errorf("IOrderRepoMock.CreateOrder got unexpected parameter usersOrders, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originUsersOrders, *mm_want_ptrs.usersOrders, mm_got.usersOrders, minimock.Diff(*mm_want_ptrs.usersOrders, mm_got.usersOrders))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("IOrderRepoMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the IOrderRepoMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, usersOrders)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to IOrderRepoMock.CreateOrder. %v %v", ctx, usersOrders)
	return
}

// CreateOrderAfterCounter returns a count of finished IOrderRepoMock.CreateOrder invocations
func (mmCreateOrder *IOrderRepoMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of IOrderRepoMock.CreateOrder invocations
func (mmCreateOrder *IOrderRepoMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mIOrderRepoMockCreateOrder) Calls() []*IOrderRepoMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*IOrderRepoMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mIOrderRepoMockGetInfoByOrderID struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockGetInfoByOrderIDExpectation
	expectations       []*IOrderRepoMockGetInfoByOrderIDExpectation

	callArgs []*IOrderRepoMockGetInfoByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockGetInfoByOrderIDExpectation specifies expectation struct of the IOrderRepo.GetInfoByOrderID
type IOrderRepoMockGetInfoByOrderIDExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockGetInfoByOrderIDParams
	paramPtrs          *IOrderRepoMockGetInfoByOrderIDParamPtrs
	expectationOrigins IOrderRepoMockGetInfoByOrderIDExpectationOrigins
	results            *IOrderRepoMockGetInfoByOrderIDResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockGetInfoByOrderIDParams contains parameters of the IOrderRepo.GetInfoByOrderID
type IOrderRepoMockGetInfoByOrderIDParams struct {
	ctx     context.Context
	orderID int64
}

// IOrderRepoMockGetInfoByOrderIDParamPtrs contains pointers to parameters of the IOrderRepo.GetInfoByOrderID
type IOrderRepoMockGetInfoByOrderIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// IOrderRepoMockGetInfoByOrderIDResults contains results of the IOrderRepo.GetInfoByOrderID
type IOrderRepoMockGetInfoByOrderIDResults struct {
	op1 *model.OrderInfo
	err error
}

// IOrderRepoMockGetInfoByOrderIDOrigins contains origins of expectations of the IOrderRepo.GetInfoByOrderID
type IOrderRepoMockGetInfoByOrderIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Optional() *mIOrderRepoMockGetInfoByOrderID {
	mmGetInfoByOrderID.optional = true
	return mmGetInfoByOrderID
}

// Expect sets up expected params for IOrderRepo.GetInfoByOrderID
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Expect(ctx context.Context, orderID int64) *mIOrderRepoMockGetInfoByOrderID {
	if mmGetInfoByOrderID.mock.funcGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Set")
	}

	if mmGetInfoByOrderID.defaultExpectation == nil {
		mmGetInfoByOrderID.defaultExpectation = &IOrderRepoMockGetInfoByOrderIDExpectation{}
	}

	if mmGetInfoByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by ExpectParams functions")
	}

	mmGetInfoByOrderID.defaultExpectation.params = &IOrderRepoMockGetInfoByOrderIDParams{ctx, orderID}
	mmGetInfoByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInfoByOrderID.expectations {
		if minimock.Equal(e.params, mmGetInfoByOrderID.defaultExpectation.params) {
			mmGetInfoByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInfoByOrderID.defaultExpectation.params)
		}
	}

	return mmGetInfoByOrderID
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.GetInfoByOrderID
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockGetInfoByOrderID {
	if mmGetInfoByOrderID.mock.funcGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Set")
	}

	if mmGetInfoByOrderID.defaultExpectation == nil {
		mmGetInfoByOrderID.defaultExpectation = &IOrderRepoMockGetInfoByOrderIDExpectation{}
	}

	if mmGetInfoByOrderID.defaultExpectation.params != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Expect")
	}

	if mmGetInfoByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderID.defaultExpectation.paramPtrs = &IOrderRepoMockGetInfoByOrderIDParamPtrs{}
	}
	mmGetInfoByOrderID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInfoByOrderID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInfoByOrderID
}

// ExpectOrderIDParam2 sets up expected param orderID for IOrderRepo.GetInfoByOrderID
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) ExpectOrderIDParam2(orderID int64) *mIOrderRepoMockGetInfoByOrderID {
	if mmGetInfoByOrderID.mock.funcGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Set")
	}

	if mmGetInfoByOrderID.defaultExpectation == nil {
		mmGetInfoByOrderID.defaultExpectation = &IOrderRepoMockGetInfoByOrderIDExpectation{}
	}

	if mmGetInfoByOrderID.defaultExpectation.params != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Expect")
	}

	if mmGetInfoByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderID.defaultExpectation.paramPtrs = &IOrderRepoMockGetInfoByOrderIDParamPtrs{}
	}
	mmGetInfoByOrderID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetInfoByOrderID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetInfoByOrderID
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.GetInfoByOrderID
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Inspect(f func(ctx context.Context, orderID int64)) *mIOrderRepoMockGetInfoByOrderID {
	if mmGetInfoByOrderID.mock.inspectFuncGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.GetInfoByOrderID")
	}

	mmGetInfoByOrderID.mock.inspectFuncGetInfoByOrderID = f

	return mmGetInfoByOrderID
}

// Return sets up results that will be returned by IOrderRepo.GetInfoByOrderID
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Return(op1 *model.OrderInfo, err error) *IOrderRepoMock {
	if mmGetInfoByOrderID.mock.funcGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Set")
	}

	if mmGetInfoByOrderID.defaultExpectation == nil {
		mmGetInfoByOrderID.defaultExpectation = &IOrderRepoMockGetInfoByOrderIDExpectation{mock: mmGetInfoByOrderID.mock}
	}
	mmGetInfoByOrderID.defaultExpectation.results = &IOrderRepoMockGetInfoByOrderIDResults{op1, err}
	mmGetInfoByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderID.mock
}

// Set uses given function f to mock the IOrderRepo.GetInfoByOrderID method
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Set(f func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)) *IOrderRepoMock {
	if mmGetInfoByOrderID.defaultExpectation != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.GetInfoByOrderID method")
	}

	if len(mmGetInfoByOrderID.expectations) > 0 {
		mmGetInfoByOrderID.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.GetInfoByOrderID method")
	}

	mmGetInfoByOrderID.mock.funcGetInfoByOrderID = f
	mmGetInfoByOrderID.mock.funcGetInfoByOrderIDOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderID.mock
}

// When sets expectation for the IOrderRepo.GetInfoByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) When(ctx context.Context, orderID int64) *IOrderRepoMockGetInfoByOrderIDExpectation {
	if mmGetInfoByOrderID.mock.funcGetInfoByOrderID != nil {
		mmGetInfoByOrderID.mock.t.Fatalf("IOrderRepoMock.GetInfoByOrderID mock is already set by Set")
	}

	expectation := &IOrderRepoMockGetInfoByOrderIDExpectation{
		mock:               mmGetInfoByOrderID.mock,
		params:             &IOrderRepoMockGetInfoByOrderIDParams{ctx, orderID},
		expectationOrigins: IOrderRepoMockGetInfoByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInfoByOrderID.expectations = append(mmGetInfoByOrderID.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.GetInfoByOrderID return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockGetInfoByOrderIDExpectation) Then(op1 *model.OrderInfo, err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockGetInfoByOrderIDResults{op1, err}
	return e.mock
}

// Times sets number of times IOrderRepo.GetInfoByOrderID should be invoked
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Times(n uint64) *mIOrderRepoMockGetInfoByOrderID {
	if n == 0 {
		mmGetInfoByOrderID.mock.t.Fatalf("Times of IOrderRepoMock.GetInfoByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInfoByOrderID.expectedInvocations, n)
	mmGetInfoByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderID
}

func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) invocationsDone() bool {
	if len(mmGetInfoByOrderID.expectations) == 0 && mmGetInfoByOrderID.defaultExpectation == nil && mmGetInfoByOrderID.mock.funcGetInfoByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderID.mock.afterGetInfoByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInfoByOrderID implements mm_service.IOrderRepo
func (mmGetInfoByOrderID *IOrderRepoMock) GetInfoByOrderID(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmGetInfoByOrderID.beforeGetInfoByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInfoByOrderID.afterGetInfoByOrderIDCounter, 1)

	mmGetInfoByOrderID.t.Helper()

	if mmGetInfoByOrderID.inspectFuncGetInfoByOrderID != nil {
		mmGetInfoByOrderID.inspectFuncGetInfoByOrderID(ctx, orderID)
	}

	mm_params := IOrderRepoMockGetInfoByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetInfoByOrderID.GetInfoByOrderIDMock.mutex.Lock()
	mmGetInfoByOrderID.GetInfoByOrderIDMock.callArgs = append(mmGetInfoByOrderID.GetInfoByOrderIDMock.callArgs, &mm_params)
	mmGetInfoByOrderID.GetInfoByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetInfoByOrderID.GetInfoByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockGetInfoByOrderIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInfoByOrderID.t.Errorf("IOrderRepoMock.GetInfoByOrderID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetInfoByOrderID.t.Errorf("IOrderRepoMock.GetInfoByOrderID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInfoByOrderID.t.Errorf("IOrderRepoMock.GetInfoByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInfoByOrderID.GetInfoByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInfoByOrderID.t.Fatal("No results are set for the IOrderRepoMock.GetInfoByOrderID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetInfoByOrderID.funcGetInfoByOrderID != nil {
		return mmGetInfoByOrderID.funcGetInfoByOrderID(ctx, orderID)
	}
	mmGetInfoByOrderID.t.Fatalf("Unexpected call to IOrderRepoMock.GetInfoByOrderID. %v %v", ctx, orderID)
	return
}

// GetInfoByOrderIDAfterCounter returns a count of finished IOrderRepoMock.GetInfoByOrderID invocations
func (mmGetInfoByOrderID *IOrderRepoMock) GetInfoByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderID.afterGetInfoByOrderIDCounter)
}

// GetInfoByOrderIDBeforeCounter returns a count of IOrderRepoMock.GetInfoByOrderID invocations
func (mmGetInfoByOrderID *IOrderRepoMock) GetInfoByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderID.beforeGetInfoByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.GetInfoByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInfoByOrderID *mIOrderRepoMockGetInfoByOrderID) Calls() []*IOrderRepoMockGetInfoByOrderIDParams {
	mmGetInfoByOrderID.mutex.RLock()

	argCopy := make([]*IOrderRepoMockGetInfoByOrderIDParams, len(mmGetInfoByOrderID.callArgs))
	copy(argCopy, mmGetInfoByOrderID.callArgs)

	mmGetInfoByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetInfoByOrderIDDone returns true if the count of the GetInfoByOrderID invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockGetInfoByOrderIDDone() bool {
	if m.GetInfoByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInfoByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInfoByOrderIDMock.invocationsDone()
}

// MinimockGetInfoByOrderIDInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockGetInfoByOrderIDInspect() {
	for _, e := range m.GetInfoByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.GetInfoByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInfoByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetInfoByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInfoByOrderIDMock.defaultExpectation != nil && afterGetInfoByOrderIDCounter < 1 {
		if m.GetInfoByOrderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.GetInfoByOrderID at\n%s", m.GetInfoByOrderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.GetInfoByOrderID at\n%s with params: %#v", m.GetInfoByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetInfoByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInfoByOrderID != nil && afterGetInfoByOrderIDCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.GetInfoByOrderID at\n%s", m.funcGetInfoByOrderIDOrigin)
	}

	if !m.GetInfoByOrderIDMock.invocationsDone() && afterGetInfoByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.GetInfoByOrderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInfoByOrderIDMock.expectedInvocations), m.GetInfoByOrderIDMock.expectedInvocationsOrigin, afterGetInfoByOrderIDCounter)
	}
}

type mIOrderRepoMockSetStatusOrder struct {
	optional           bool
	mock               *IOrderRepoMock
	defaultExpectation *IOrderRepoMockSetStatusOrderExpectation
	expectations       []*IOrderRepoMockSetStatusOrderExpectation

	callArgs []*IOrderRepoMockSetStatusOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepoMockSetStatusOrderExpectation specifies expectation struct of the IOrderRepo.SetStatusOrder
type IOrderRepoMockSetStatusOrderExpectation struct {
	mock               *IOrderRepoMock
	params             *IOrderRepoMockSetStatusOrderParams
	paramPtrs          *IOrderRepoMockSetStatusOrderParamPtrs
	expectationOrigins IOrderRepoMockSetStatusOrderExpectationOrigins
	results            *IOrderRepoMockSetStatusOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepoMockSetStatusOrderParams contains parameters of the IOrderRepo.SetStatusOrder
type IOrderRepoMockSetStatusOrderParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// IOrderRepoMockSetStatusOrderParamPtrs contains pointers to parameters of the IOrderRepo.SetStatusOrder
type IOrderRepoMockSetStatusOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *string
}

// IOrderRepoMockSetStatusOrderResults contains results of the IOrderRepo.SetStatusOrder
type IOrderRepoMockSetStatusOrderResults struct {
	err error
}

// IOrderRepoMockSetStatusOrderOrigins contains origins of expectations of the IOrderRepo.SetStatusOrder
type IOrderRepoMockSetStatusOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Optional() *mIOrderRepoMockSetStatusOrder {
	mmSetStatusOrder.optional = true
	return mmSetStatusOrder
}

// Expect sets up expected params for IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Expect(ctx context.Context, orderID int64, status string) *mIOrderRepoMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IOrderRepoMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by ExpectParams functions")
	}

	mmSetStatusOrder.defaultExpectation.params = &IOrderRepoMockSetStatusOrderParams{ctx, orderID, status}
	mmSetStatusOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatusOrder.expectations {
		if minimock.Equal(e.params, mmSetStatusOrder.defaultExpectation.params) {
			mmSetStatusOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatusOrder.defaultExpectation.params)
		}
	}

	return mmSetStatusOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) ExpectCtxParam1(ctx context.Context) *mIOrderRepoMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IOrderRepoMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IOrderRepoMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) ExpectOrderIDParam2(orderID int64) *mIOrderRepoMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IOrderRepoMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IOrderRepoMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// ExpectStatusParam3 sets up expected param status for IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) ExpectStatusParam3(status string) *mIOrderRepoMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IOrderRepoMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IOrderRepoMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.status = &status
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Inspect(f func(ctx context.Context, orderID int64, status string)) *mIOrderRepoMockSetStatusOrder {
	if mmSetStatusOrder.mock.inspectFuncSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepoMock.SetStatusOrder")
	}

	mmSetStatusOrder.mock.inspectFuncSetStatusOrder = f

	return mmSetStatusOrder
}

// Return sets up results that will be returned by IOrderRepo.SetStatusOrder
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Return(err error) *IOrderRepoMock {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IOrderRepoMockSetStatusOrderExpectation{mock: mmSetStatusOrder.mock}
	}
	mmSetStatusOrder.defaultExpectation.results = &IOrderRepoMockSetStatusOrderResults{err}
	mmSetStatusOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder.mock
}

// Set uses given function f to mock the IOrderRepo.SetStatusOrder method
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Set(f func(ctx context.Context, orderID int64, status string) (err error)) *IOrderRepoMock {
	if mmSetStatusOrder.defaultExpectation != nil {
		mmSetStatusOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.SetStatusOrder method")
	}

	if len(mmSetStatusOrder.expectations) > 0 {
		mmSetStatusOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.SetStatusOrder method")
	}

	mmSetStatusOrder.mock.funcSetStatusOrder = f
	mmSetStatusOrder.mock.funcSetStatusOrderOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder.mock
}

// When sets expectation for the IOrderRepo.SetStatusOrder which will trigger the result defined by the following
// Then helper
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) When(ctx context.Context, orderID int64, status string) *IOrderRepoMockSetStatusOrderExpectation {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IOrderRepoMock.SetStatusOrder mock is already set by Set")
	}

	expectation := &IOrderRepoMockSetStatusOrderExpectation{
		mock:               mmSetStatusOrder.mock,
		params:             &IOrderRepoMockSetStatusOrderParams{ctx, orderID, status},
		expectationOrigins: IOrderRepoMockSetStatusOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatusOrder.expectations = append(mmSetStatusOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.SetStatusOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepoMockSetStatusOrderExpectation) Then(err error) *IOrderRepoMock {
	e.results = &IOrderRepoMockSetStatusOrderResults{err}
	return e.mock
}

// Times sets number of times IOrderRepo.SetStatusOrder should be invoked
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Times(n uint64) *mIOrderRepoMockSetStatusOrder {
	if n == 0 {
		mmSetStatusOrder.mock.t.Fatalf("Times of IOrderRepoMock.SetStatusOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatusOrder.expectedInvocations, n)
	mmSetStatusOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder
}

func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) invocationsDone() bool {
	if len(mmSetStatusOrder.expectations) == 0 && mmSetStatusOrder.defaultExpectation == nil && mmSetStatusOrder.mock.funcSetStatusOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatusOrder.mock.afterSetStatusOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatusOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatusOrder implements mm_service.IOrderRepo
func (mmSetStatusOrder *IOrderRepoMock) SetStatusOrder(ctx context.Context, orderID int64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatusOrder.beforeSetStatusOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatusOrder.afterSetStatusOrderCounter, 1)

	mmSetStatusOrder.t.Helper()

	if mmSetStatusOrder.inspectFuncSetStatusOrder != nil {
		mmSetStatusOrder.inspectFuncSetStatusOrder(ctx, orderID, status)
	}

	mm_params := IOrderRepoMockSetStatusOrderParams{ctx, orderID, status}

	// Record call args
	mmSetStatusOrder.SetStatusOrderMock.mutex.Lock()
	mmSetStatusOrder.SetStatusOrderMock.callArgs = append(mmSetStatusOrder.SetStatusOrderMock.callArgs, &mm_params)
	mmSetStatusOrder.SetStatusOrderMock.mutex.Unlock()

	for _, e := range mmSetStatusOrder.SetStatusOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatusOrder.SetStatusOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepoMockSetStatusOrderParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatusOrder.t.Errorf("IOrderRepoMock.SetStatusOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatusOrder.t.Errorf("IOrderRepoMock.SetStatusOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatusOrder.t.Errorf("IOrderRepoMock.SetStatusOrder got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatusOrder.t.Errorf("IOrderRepoMock.SetStatusOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatusOrder.t.Fatal("No results are set for the IOrderRepoMock.SetStatusOrder")
		}
		return (*mm_results).err
	}
	if mmSetStatusOrder.funcSetStatusOrder != nil {
		return mmSetStatusOrder.funcSetStatusOrder(ctx, orderID, status)
	}
	mmSetStatusOrder.t.Fatalf("Unexpected call to IOrderRepoMock.SetStatusOrder. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusOrderAfterCounter returns a count of finished IOrderRepoMock.SetStatusOrder invocations
func (mmSetStatusOrder *IOrderRepoMock) SetStatusOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusOrder.afterSetStatusOrderCounter)
}

// SetStatusOrderBeforeCounter returns a count of IOrderRepoMock.SetStatusOrder invocations
func (mmSetStatusOrder *IOrderRepoMock) SetStatusOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusOrder.beforeSetStatusOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepoMock.SetStatusOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatusOrder *mIOrderRepoMockSetStatusOrder) Calls() []*IOrderRepoMockSetStatusOrderParams {
	mmSetStatusOrder.mutex.RLock()

	argCopy := make([]*IOrderRepoMockSetStatusOrderParams, len(mmSetStatusOrder.callArgs))
	copy(argCopy, mmSetStatusOrder.callArgs)

	mmSetStatusOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusOrderDone returns true if the count of the SetStatusOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepoMock) MinimockSetStatusOrderDone() bool {
	if m.SetStatusOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusOrderMock.invocationsDone()
}

// MinimockSetStatusOrderInspect logs each unmet expectation
func (m *IOrderRepoMock) MinimockSetStatusOrderInspect() {
	for _, e := range m.SetStatusOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepoMock.SetStatusOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusOrderCounter := mm_atomic.LoadUint64(&m.afterSetStatusOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusOrderMock.defaultExpectation != nil && afterSetStatusOrderCounter < 1 {
		if m.SetStatusOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepoMock.SetStatusOrder at\n%s", m.SetStatusOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepoMock.SetStatusOrder at\n%s with params: %#v", m.SetStatusOrderMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatusOrder != nil && afterSetStatusOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepoMock.SetStatusOrder at\n%s", m.funcSetStatusOrderOrigin)
	}

	if !m.SetStatusOrderMock.invocationsDone() && afterSetStatusOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepoMock.SetStatusOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusOrderMock.expectedInvocations), m.SetStatusOrderMock.expectedInvocationsOrigin, afterSetStatusOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOrderRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockGetInfoByOrderIDInspect()

			m.MinimockSetStatusOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOrderRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOrderRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetInfoByOrderIDDone() &&
		m.MinimockSetStatusOrderDone()
}
