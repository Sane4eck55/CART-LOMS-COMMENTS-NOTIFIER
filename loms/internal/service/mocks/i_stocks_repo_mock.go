// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/service.IStocksRepo -o i_stocks_repo_mock.go -n IStocksRepoMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IStocksRepoMock implements mm_service.IStocksRepo
type IStocksRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStocksBySku          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcGetStocksBySkuOrigin    string
	inspectFuncGetStocksBySku   func(ctx context.Context, sku int64)
	afterGetStocksBySkuCounter  uint64
	beforeGetStocksBySkuCounter uint64
	GetStocksBySkuMock          mIStocksRepoMockGetStocksBySku

	funcReserve          func(ctx context.Context, items []model.Item) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, items []model.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mIStocksRepoMockReserve

	funcReserveCancel          func(ctx context.Context, item model.Item) (err error)
	funcReserveCancelOrigin    string
	inspectFuncReserveCancel   func(ctx context.Context, item model.Item)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mIStocksRepoMockReserveCancel

	funcReserveRemove          func(ctx context.Context, item model.Item) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, item model.Item)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mIStocksRepoMockReserveRemove
}

// NewIStocksRepoMock returns a mock for mm_service.IStocksRepo
func NewIStocksRepoMock(t minimock.Tester) *IStocksRepoMock {
	m := &IStocksRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStocksBySkuMock = mIStocksRepoMockGetStocksBySku{mock: m}
	m.GetStocksBySkuMock.callArgs = []*IStocksRepoMockGetStocksBySkuParams{}

	m.ReserveMock = mIStocksRepoMockReserve{mock: m}
	m.ReserveMock.callArgs = []*IStocksRepoMockReserveParams{}

	m.ReserveCancelMock = mIStocksRepoMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*IStocksRepoMockReserveCancelParams{}

	m.ReserveRemoveMock = mIStocksRepoMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*IStocksRepoMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStocksRepoMockGetStocksBySku struct {
	optional           bool
	mock               *IStocksRepoMock
	defaultExpectation *IStocksRepoMockGetStocksBySkuExpectation
	expectations       []*IStocksRepoMockGetStocksBySkuExpectation

	callArgs []*IStocksRepoMockGetStocksBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStocksRepoMockGetStocksBySkuExpectation specifies expectation struct of the IStocksRepo.GetStocksBySku
type IStocksRepoMockGetStocksBySkuExpectation struct {
	mock               *IStocksRepoMock
	params             *IStocksRepoMockGetStocksBySkuParams
	paramPtrs          *IStocksRepoMockGetStocksBySkuParamPtrs
	expectationOrigins IStocksRepoMockGetStocksBySkuExpectationOrigins
	results            *IStocksRepoMockGetStocksBySkuResults
	returnOrigin       string
	Counter            uint64
}

// IStocksRepoMockGetStocksBySkuParams contains parameters of the IStocksRepo.GetStocksBySku
type IStocksRepoMockGetStocksBySkuParams struct {
	ctx context.Context
	sku int64
}

// IStocksRepoMockGetStocksBySkuParamPtrs contains pointers to parameters of the IStocksRepo.GetStocksBySku
type IStocksRepoMockGetStocksBySkuParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// IStocksRepoMockGetStocksBySkuResults contains results of the IStocksRepo.GetStocksBySku
type IStocksRepoMockGetStocksBySkuResults struct {
	u1  uint32
	err error
}

// IStocksRepoMockGetStocksBySkuOrigins contains origins of expectations of the IStocksRepo.GetStocksBySku
type IStocksRepoMockGetStocksBySkuExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Optional() *mIStocksRepoMockGetStocksBySku {
	mmGetStocksBySku.optional = true
	return mmGetStocksBySku
}

// Expect sets up expected params for IStocksRepo.GetStocksBySku
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Expect(ctx context.Context, sku int64) *mIStocksRepoMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &IStocksRepoMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by ExpectParams functions")
	}

	mmGetStocksBySku.defaultExpectation.params = &IStocksRepoMockGetStocksBySkuParams{ctx, sku}
	mmGetStocksBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStocksBySku.expectations {
		if minimock.Equal(e.params, mmGetStocksBySku.defaultExpectation.params) {
			mmGetStocksBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocksBySku.defaultExpectation.params)
		}
	}

	return mmGetStocksBySku
}

// ExpectCtxParam1 sets up expected param ctx for IStocksRepo.GetStocksBySku
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) ExpectCtxParam1(ctx context.Context) *mIStocksRepoMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &IStocksRepoMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &IStocksRepoMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStocksBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStocksBySku
}

// ExpectSkuParam2 sets up expected param sku for IStocksRepo.GetStocksBySku
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) ExpectSkuParam2(sku int64) *mIStocksRepoMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &IStocksRepoMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &IStocksRepoMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.sku = &sku
	mmGetStocksBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetStocksBySku
}

// Inspect accepts an inspector function that has same arguments as the IStocksRepo.GetStocksBySku
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Inspect(f func(ctx context.Context, sku int64)) *mIStocksRepoMockGetStocksBySku {
	if mmGetStocksBySku.mock.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("Inspect function is already set for IStocksRepoMock.GetStocksBySku")
	}

	mmGetStocksBySku.mock.inspectFuncGetStocksBySku = f

	return mmGetStocksBySku
}

// Return sets up results that will be returned by IStocksRepo.GetStocksBySku
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Return(u1 uint32, err error) *IStocksRepoMock {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &IStocksRepoMockGetStocksBySkuExpectation{mock: mmGetStocksBySku.mock}
	}
	mmGetStocksBySku.defaultExpectation.results = &IStocksRepoMockGetStocksBySkuResults{u1, err}
	mmGetStocksBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku.mock
}

// Set uses given function f to mock the IStocksRepo.GetStocksBySku method
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *IStocksRepoMock {
	if mmGetStocksBySku.defaultExpectation != nil {
		mmGetStocksBySku.mock.t.Fatalf("Default expectation is already set for the IStocksRepo.GetStocksBySku method")
	}

	if len(mmGetStocksBySku.expectations) > 0 {
		mmGetStocksBySku.mock.t.Fatalf("Some expectations are already set for the IStocksRepo.GetStocksBySku method")
	}

	mmGetStocksBySku.mock.funcGetStocksBySku = f
	mmGetStocksBySku.mock.funcGetStocksBySkuOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku.mock
}

// When sets expectation for the IStocksRepo.GetStocksBySku which will trigger the result defined by the following
// Then helper
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) When(ctx context.Context, sku int64) *IStocksRepoMockGetStocksBySkuExpectation {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("IStocksRepoMock.GetStocksBySku mock is already set by Set")
	}

	expectation := &IStocksRepoMockGetStocksBySkuExpectation{
		mock:               mmGetStocksBySku.mock,
		params:             &IStocksRepoMockGetStocksBySkuParams{ctx, sku},
		expectationOrigins: IStocksRepoMockGetStocksBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStocksBySku.expectations = append(mmGetStocksBySku.expectations, expectation)
	return expectation
}

// Then sets up IStocksRepo.GetStocksBySku return parameters for the expectation previously defined by the When method
func (e *IStocksRepoMockGetStocksBySkuExpectation) Then(u1 uint32, err error) *IStocksRepoMock {
	e.results = &IStocksRepoMockGetStocksBySkuResults{u1, err}
	return e.mock
}

// Times sets number of times IStocksRepo.GetStocksBySku should be invoked
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Times(n uint64) *mIStocksRepoMockGetStocksBySku {
	if n == 0 {
		mmGetStocksBySku.mock.t.Fatalf("Times of IStocksRepoMock.GetStocksBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStocksBySku.expectedInvocations, n)
	mmGetStocksBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku
}

func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) invocationsDone() bool {
	if len(mmGetStocksBySku.expectations) == 0 && mmGetStocksBySku.defaultExpectation == nil && mmGetStocksBySku.mock.funcGetStocksBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.mock.afterGetStocksBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStocksBySku implements mm_service.IStocksRepo
func (mmGetStocksBySku *IStocksRepoMock) GetStocksBySku(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter, 1)

	mmGetStocksBySku.t.Helper()

	if mmGetStocksBySku.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.inspectFuncGetStocksBySku(ctx, sku)
	}

	mm_params := IStocksRepoMockGetStocksBySkuParams{ctx, sku}

	// Record call args
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Lock()
	mmGetStocksBySku.GetStocksBySkuMock.callArgs = append(mmGetStocksBySku.GetStocksBySkuMock.callArgs, &mm_params)
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Unlock()

	for _, e := range mmGetStocksBySku.GetStocksBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.paramPtrs

		mm_got := IStocksRepoMockGetStocksBySkuParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStocksBySku.t.Errorf("IStocksRepoMock.GetStocksBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetStocksBySku.t.Errorf("IStocksRepoMock.GetStocksBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocksBySku.t.Errorf("IStocksRepoMock.GetStocksBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocksBySku.t.Fatal("No results are set for the IStocksRepoMock.GetStocksBySku")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetStocksBySku.funcGetStocksBySku != nil {
		return mmGetStocksBySku.funcGetStocksBySku(ctx, sku)
	}
	mmGetStocksBySku.t.Fatalf("Unexpected call to IStocksRepoMock.GetStocksBySku. %v %v", ctx, sku)
	return
}

// GetStocksBySkuAfterCounter returns a count of finished IStocksRepoMock.GetStocksBySku invocations
func (mmGetStocksBySku *IStocksRepoMock) GetStocksBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter)
}

// GetStocksBySkuBeforeCounter returns a count of IStocksRepoMock.GetStocksBySku invocations
func (mmGetStocksBySku *IStocksRepoMock) GetStocksBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter)
}

// Calls returns a list of arguments used in each call to IStocksRepoMock.GetStocksBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocksBySku *mIStocksRepoMockGetStocksBySku) Calls() []*IStocksRepoMockGetStocksBySkuParams {
	mmGetStocksBySku.mutex.RLock()

	argCopy := make([]*IStocksRepoMockGetStocksBySkuParams, len(mmGetStocksBySku.callArgs))
	copy(argCopy, mmGetStocksBySku.callArgs)

	mmGetStocksBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksBySkuDone returns true if the count of the GetStocksBySku invocations corresponds
// the number of defined expectations
func (m *IStocksRepoMock) MinimockGetStocksBySkuDone() bool {
	if m.GetStocksBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStocksBySkuMock.invocationsDone()
}

// MinimockGetStocksBySkuInspect logs each unmet expectation
func (m *IStocksRepoMock) MinimockGetStocksBySkuInspect() {
	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStocksRepoMock.GetStocksBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStocksBySkuCounter := mm_atomic.LoadUint64(&m.afterGetStocksBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksBySkuMock.defaultExpectation != nil && afterGetStocksBySkuCounter < 1 {
		if m.GetStocksBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStocksRepoMock.GetStocksBySku at\n%s", m.GetStocksBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStocksRepoMock.GetStocksBySku at\n%s with params: %#v", m.GetStocksBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetStocksBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocksBySku != nil && afterGetStocksBySkuCounter < 1 {
		m.t.Errorf("Expected call to IStocksRepoMock.GetStocksBySku at\n%s", m.funcGetStocksBySkuOrigin)
	}

	if !m.GetStocksBySkuMock.invocationsDone() && afterGetStocksBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to IStocksRepoMock.GetStocksBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStocksBySkuMock.expectedInvocations), m.GetStocksBySkuMock.expectedInvocationsOrigin, afterGetStocksBySkuCounter)
	}
}

type mIStocksRepoMockReserve struct {
	optional           bool
	mock               *IStocksRepoMock
	defaultExpectation *IStocksRepoMockReserveExpectation
	expectations       []*IStocksRepoMockReserveExpectation

	callArgs []*IStocksRepoMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStocksRepoMockReserveExpectation specifies expectation struct of the IStocksRepo.Reserve
type IStocksRepoMockReserveExpectation struct {
	mock               *IStocksRepoMock
	params             *IStocksRepoMockReserveParams
	paramPtrs          *IStocksRepoMockReserveParamPtrs
	expectationOrigins IStocksRepoMockReserveExpectationOrigins
	results            *IStocksRepoMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// IStocksRepoMockReserveParams contains parameters of the IStocksRepo.Reserve
type IStocksRepoMockReserveParams struct {
	ctx   context.Context
	items []model.Item
}

// IStocksRepoMockReserveParamPtrs contains pointers to parameters of the IStocksRepo.Reserve
type IStocksRepoMockReserveParamPtrs struct {
	ctx   *context.Context
	items *[]model.Item
}

// IStocksRepoMockReserveResults contains results of the IStocksRepo.Reserve
type IStocksRepoMockReserveResults struct {
	err error
}

// IStocksRepoMockReserveOrigins contains origins of expectations of the IStocksRepo.Reserve
type IStocksRepoMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mIStocksRepoMockReserve) Optional() *mIStocksRepoMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for IStocksRepo.Reserve
func (mmReserve *mIStocksRepoMockReserve) Expect(ctx context.Context, items []model.Item) *mIStocksRepoMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IStocksRepoMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &IStocksRepoMockReserveParams{ctx, items}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for IStocksRepo.Reserve
func (mmReserve *mIStocksRepoMockReserve) ExpectCtxParam1(ctx context.Context) *mIStocksRepoMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IStocksRepoMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &IStocksRepoMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectItemsParam2 sets up expected param items for IStocksRepo.Reserve
func (mmReserve *mIStocksRepoMockReserve) ExpectItemsParam2(items []model.Item) *mIStocksRepoMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IStocksRepoMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &IStocksRepoMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.items = &items
	mmReserve.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the IStocksRepo.Reserve
func (mmReserve *mIStocksRepoMockReserve) Inspect(f func(ctx context.Context, items []model.Item)) *mIStocksRepoMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for IStocksRepoMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by IStocksRepo.Reserve
func (mmReserve *mIStocksRepoMockReserve) Return(err error) *IStocksRepoMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IStocksRepoMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &IStocksRepoMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the IStocksRepo.Reserve method
func (mmReserve *mIStocksRepoMockReserve) Set(f func(ctx context.Context, items []model.Item) (err error)) *IStocksRepoMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the IStocksRepo.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the IStocksRepo.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the IStocksRepo.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mIStocksRepoMockReserve) When(ctx context.Context, items []model.Item) *IStocksRepoMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IStocksRepoMock.Reserve mock is already set by Set")
	}

	expectation := &IStocksRepoMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &IStocksRepoMockReserveParams{ctx, items},
		expectationOrigins: IStocksRepoMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up IStocksRepo.Reserve return parameters for the expectation previously defined by the When method
func (e *IStocksRepoMockReserveExpectation) Then(err error) *IStocksRepoMock {
	e.results = &IStocksRepoMockReserveResults{err}
	return e.mock
}

// Times sets number of times IStocksRepo.Reserve should be invoked
func (mmReserve *mIStocksRepoMockReserve) Times(n uint64) *mIStocksRepoMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of IStocksRepoMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mIStocksRepoMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_service.IStocksRepo
func (mmReserve *IStocksRepoMock) Reserve(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := IStocksRepoMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := IStocksRepoMockReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("IStocksRepoMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserve.t.Errorf("IStocksRepoMock.Reserve got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("IStocksRepoMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the IStocksRepoMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to IStocksRepoMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished IStocksRepoMock.Reserve invocations
func (mmReserve *IStocksRepoMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of IStocksRepoMock.Reserve invocations
func (mmReserve *IStocksRepoMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to IStocksRepoMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mIStocksRepoMockReserve) Calls() []*IStocksRepoMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*IStocksRepoMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *IStocksRepoMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *IStocksRepoMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStocksRepoMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStocksRepoMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStocksRepoMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to IStocksRepoMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to IStocksRepoMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mIStocksRepoMockReserveCancel struct {
	optional           bool
	mock               *IStocksRepoMock
	defaultExpectation *IStocksRepoMockReserveCancelExpectation
	expectations       []*IStocksRepoMockReserveCancelExpectation

	callArgs []*IStocksRepoMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStocksRepoMockReserveCancelExpectation specifies expectation struct of the IStocksRepo.ReserveCancel
type IStocksRepoMockReserveCancelExpectation struct {
	mock               *IStocksRepoMock
	params             *IStocksRepoMockReserveCancelParams
	paramPtrs          *IStocksRepoMockReserveCancelParamPtrs
	expectationOrigins IStocksRepoMockReserveCancelExpectationOrigins
	results            *IStocksRepoMockReserveCancelResults
	returnOrigin       string
	Counter            uint64
}

// IStocksRepoMockReserveCancelParams contains parameters of the IStocksRepo.ReserveCancel
type IStocksRepoMockReserveCancelParams struct {
	ctx  context.Context
	item model.Item
}

// IStocksRepoMockReserveCancelParamPtrs contains pointers to parameters of the IStocksRepo.ReserveCancel
type IStocksRepoMockReserveCancelParamPtrs struct {
	ctx  *context.Context
	item *model.Item
}

// IStocksRepoMockReserveCancelResults contains results of the IStocksRepo.ReserveCancel
type IStocksRepoMockReserveCancelResults struct {
	err error
}

// IStocksRepoMockReserveCancelOrigins contains origins of expectations of the IStocksRepo.ReserveCancel
type IStocksRepoMockReserveCancelExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Optional() *mIStocksRepoMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for IStocksRepo.ReserveCancel
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Expect(ctx context.Context, item model.Item) *mIStocksRepoMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IStocksRepoMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &IStocksRepoMockReserveCancelParams{ctx, item}
	mmReserveCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for IStocksRepo.ReserveCancel
func (mmReserveCancel *mIStocksRepoMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mIStocksRepoMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IStocksRepoMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &IStocksRepoMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectItemParam2 sets up expected param item for IStocksRepo.ReserveCancel
func (mmReserveCancel *mIStocksRepoMockReserveCancel) ExpectItemParam2(item model.Item) *mIStocksRepoMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IStocksRepoMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &IStocksRepoMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.item = &item
	mmReserveCancel.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the IStocksRepo.ReserveCancel
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Inspect(f func(ctx context.Context, item model.Item)) *mIStocksRepoMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for IStocksRepoMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by IStocksRepo.ReserveCancel
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Return(err error) *IStocksRepoMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IStocksRepoMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &IStocksRepoMockReserveCancelResults{err}
	mmReserveCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// Set uses given function f to mock the IStocksRepo.ReserveCancel method
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Set(f func(ctx context.Context, item model.Item) (err error)) *IStocksRepoMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the IStocksRepo.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the IStocksRepo.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	mmReserveCancel.mock.funcReserveCancelOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// When sets expectation for the IStocksRepo.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mIStocksRepoMockReserveCancel) When(ctx context.Context, item model.Item) *IStocksRepoMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IStocksRepoMock.ReserveCancel mock is already set by Set")
	}

	expectation := &IStocksRepoMockReserveCancelExpectation{
		mock:               mmReserveCancel.mock,
		params:             &IStocksRepoMockReserveCancelParams{ctx, item},
		expectationOrigins: IStocksRepoMockReserveCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up IStocksRepo.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *IStocksRepoMockReserveCancelExpectation) Then(err error) *IStocksRepoMock {
	e.results = &IStocksRepoMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times IStocksRepo.ReserveCancel should be invoked
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Times(n uint64) *mIStocksRepoMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of IStocksRepoMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	mmReserveCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancel
}

func (mmReserveCancel *mIStocksRepoMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements mm_service.IStocksRepo
func (mmReserveCancel *IStocksRepoMock) ReserveCancel(ctx context.Context, item model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	mmReserveCancel.t.Helper()

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, item)
	}

	mm_params := IStocksRepoMockReserveCancelParams{ctx, item}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := IStocksRepoMockReserveCancelParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("IStocksRepoMock.ReserveCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmReserveCancel.t.Errorf("IStocksRepoMock.ReserveCancel got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("IStocksRepoMock.ReserveCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the IStocksRepoMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, item)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to IStocksRepoMock.ReserveCancel. %v %v", ctx, item)
	return
}

// ReserveCancelAfterCounter returns a count of finished IStocksRepoMock.ReserveCancel invocations
func (mmReserveCancel *IStocksRepoMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of IStocksRepoMock.ReserveCancel invocations
func (mmReserveCancel *IStocksRepoMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to IStocksRepoMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mIStocksRepoMockReserveCancel) Calls() []*IStocksRepoMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*IStocksRepoMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *IStocksRepoMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *IStocksRepoMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveCancel at\n%s", m.ReserveCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveCancel at\n%s with params: %#v", m.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Errorf("Expected call to IStocksRepoMock.ReserveCancel at\n%s", m.funcReserveCancelOrigin)
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to IStocksRepoMock.ReserveCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), m.ReserveCancelMock.expectedInvocationsOrigin, afterReserveCancelCounter)
	}
}

type mIStocksRepoMockReserveRemove struct {
	optional           bool
	mock               *IStocksRepoMock
	defaultExpectation *IStocksRepoMockReserveRemoveExpectation
	expectations       []*IStocksRepoMockReserveRemoveExpectation

	callArgs []*IStocksRepoMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStocksRepoMockReserveRemoveExpectation specifies expectation struct of the IStocksRepo.ReserveRemove
type IStocksRepoMockReserveRemoveExpectation struct {
	mock               *IStocksRepoMock
	params             *IStocksRepoMockReserveRemoveParams
	paramPtrs          *IStocksRepoMockReserveRemoveParamPtrs
	expectationOrigins IStocksRepoMockReserveRemoveExpectationOrigins
	results            *IStocksRepoMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// IStocksRepoMockReserveRemoveParams contains parameters of the IStocksRepo.ReserveRemove
type IStocksRepoMockReserveRemoveParams struct {
	ctx  context.Context
	item model.Item
}

// IStocksRepoMockReserveRemoveParamPtrs contains pointers to parameters of the IStocksRepo.ReserveRemove
type IStocksRepoMockReserveRemoveParamPtrs struct {
	ctx  *context.Context
	item *model.Item
}

// IStocksRepoMockReserveRemoveResults contains results of the IStocksRepo.ReserveRemove
type IStocksRepoMockReserveRemoveResults struct {
	err error
}

// IStocksRepoMockReserveRemoveOrigins contains origins of expectations of the IStocksRepo.ReserveRemove
type IStocksRepoMockReserveRemoveExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Optional() *mIStocksRepoMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for IStocksRepo.ReserveRemove
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Expect(ctx context.Context, item model.Item) *mIStocksRepoMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IStocksRepoMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &IStocksRepoMockReserveRemoveParams{ctx, item}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for IStocksRepo.ReserveRemove
func (mmReserveRemove *mIStocksRepoMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mIStocksRepoMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IStocksRepoMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &IStocksRepoMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectItemParam2 sets up expected param item for IStocksRepo.ReserveRemove
func (mmReserveRemove *mIStocksRepoMockReserveRemove) ExpectItemParam2(item model.Item) *mIStocksRepoMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IStocksRepoMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &IStocksRepoMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.item = &item
	mmReserveRemove.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the IStocksRepo.ReserveRemove
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Inspect(f func(ctx context.Context, item model.Item)) *mIStocksRepoMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for IStocksRepoMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by IStocksRepo.ReserveRemove
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Return(err error) *IStocksRepoMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IStocksRepoMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &IStocksRepoMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the IStocksRepo.ReserveRemove method
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Set(f func(ctx context.Context, item model.Item) (err error)) *IStocksRepoMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the IStocksRepo.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the IStocksRepo.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the IStocksRepo.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mIStocksRepoMockReserveRemove) When(ctx context.Context, item model.Item) *IStocksRepoMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IStocksRepoMock.ReserveRemove mock is already set by Set")
	}

	expectation := &IStocksRepoMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &IStocksRepoMockReserveRemoveParams{ctx, item},
		expectationOrigins: IStocksRepoMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up IStocksRepo.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *IStocksRepoMockReserveRemoveExpectation) Then(err error) *IStocksRepoMock {
	e.results = &IStocksRepoMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times IStocksRepo.ReserveRemove should be invoked
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Times(n uint64) *mIStocksRepoMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of IStocksRepoMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mIStocksRepoMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_service.IStocksRepo
func (mmReserveRemove *IStocksRepoMock) ReserveRemove(ctx context.Context, item model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, item)
	}

	mm_params := IStocksRepoMockReserveRemoveParams{ctx, item}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := IStocksRepoMockReserveRemoveParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("IStocksRepoMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmReserveRemove.t.Errorf("IStocksRepoMock.ReserveRemove got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("IStocksRepoMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the IStocksRepoMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, item)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to IStocksRepoMock.ReserveRemove. %v %v", ctx, item)
	return
}

// ReserveRemoveAfterCounter returns a count of finished IStocksRepoMock.ReserveRemove invocations
func (mmReserveRemove *IStocksRepoMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of IStocksRepoMock.ReserveRemove invocations
func (mmReserveRemove *IStocksRepoMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to IStocksRepoMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mIStocksRepoMockReserveRemove) Calls() []*IStocksRepoMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*IStocksRepoMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *IStocksRepoMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *IStocksRepoMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStocksRepoMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to IStocksRepoMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to IStocksRepoMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStocksRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStocksBySkuInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStocksRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStocksRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStocksBySkuDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone()
}
