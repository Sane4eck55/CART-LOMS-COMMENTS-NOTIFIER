// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/service.IProducerOrderEvent -o i_producer_order_event_mock.go -n IProducerOrderEventMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IProducerOrderEventMock implements mm_service.IProducerOrderEvent
type IProducerOrderEventMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSendMsg          func(msg *model.OrderEvent) (i1 int32, i2 int64, err error)
	funcSendMsgOrigin    string
	inspectFuncSendMsg   func(msg *model.OrderEvent)
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mIProducerOrderEventMockSendMsg
}

// NewIProducerOrderEventMock returns a mock for mm_service.IProducerOrderEvent
func NewIProducerOrderEventMock(t minimock.Tester) *IProducerOrderEventMock {
	m := &IProducerOrderEventMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SendMsgMock = mIProducerOrderEventMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*IProducerOrderEventMockSendMsgParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIProducerOrderEventMockSendMsg struct {
	optional           bool
	mock               *IProducerOrderEventMock
	defaultExpectation *IProducerOrderEventMockSendMsgExpectation
	expectations       []*IProducerOrderEventMockSendMsgExpectation

	callArgs []*IProducerOrderEventMockSendMsgParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IProducerOrderEventMockSendMsgExpectation specifies expectation struct of the IProducerOrderEvent.SendMsg
type IProducerOrderEventMockSendMsgExpectation struct {
	mock               *IProducerOrderEventMock
	params             *IProducerOrderEventMockSendMsgParams
	paramPtrs          *IProducerOrderEventMockSendMsgParamPtrs
	expectationOrigins IProducerOrderEventMockSendMsgExpectationOrigins
	results            *IProducerOrderEventMockSendMsgResults
	returnOrigin       string
	Counter            uint64
}

// IProducerOrderEventMockSendMsgParams contains parameters of the IProducerOrderEvent.SendMsg
type IProducerOrderEventMockSendMsgParams struct {
	msg *model.OrderEvent
}

// IProducerOrderEventMockSendMsgParamPtrs contains pointers to parameters of the IProducerOrderEvent.SendMsg
type IProducerOrderEventMockSendMsgParamPtrs struct {
	msg **model.OrderEvent
}

// IProducerOrderEventMockSendMsgResults contains results of the IProducerOrderEvent.SendMsg
type IProducerOrderEventMockSendMsgResults struct {
	i1  int32
	i2  int64
	err error
}

// IProducerOrderEventMockSendMsgOrigins contains origins of expectations of the IProducerOrderEvent.SendMsg
type IProducerOrderEventMockSendMsgExpectationOrigins struct {
	origin    string
	originMsg string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Optional() *mIProducerOrderEventMockSendMsg {
	mmSendMsg.optional = true
	return mmSendMsg
}

// Expect sets up expected params for IProducerOrderEvent.SendMsg
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Expect(msg *model.OrderEvent) *mIProducerOrderEventMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &IProducerOrderEventMockSendMsgExpectation{}
	}

	if mmSendMsg.defaultExpectation.paramPtrs != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by ExpectParams functions")
	}

	mmSendMsg.defaultExpectation.params = &IProducerOrderEventMockSendMsgParams{msg}
	mmSendMsg.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// ExpectMsgParam1 sets up expected param msg for IProducerOrderEvent.SendMsg
func (mmSendMsg *mIProducerOrderEventMockSendMsg) ExpectMsgParam1(msg *model.OrderEvent) *mIProducerOrderEventMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &IProducerOrderEventMockSendMsgExpectation{}
	}

	if mmSendMsg.defaultExpectation.params != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by Expect")
	}

	if mmSendMsg.defaultExpectation.paramPtrs == nil {
		mmSendMsg.defaultExpectation.paramPtrs = &IProducerOrderEventMockSendMsgParamPtrs{}
	}
	mmSendMsg.defaultExpectation.paramPtrs.msg = &msg
	mmSendMsg.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the IProducerOrderEvent.SendMsg
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Inspect(f func(msg *model.OrderEvent)) *mIProducerOrderEventMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for IProducerOrderEventMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by IProducerOrderEvent.SendMsg
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Return(i1 int32, i2 int64, err error) *IProducerOrderEventMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &IProducerOrderEventMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &IProducerOrderEventMockSendMsgResults{i1, i2, err}
	mmSendMsg.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMsg.mock
}

// Set uses given function f to mock the IProducerOrderEvent.SendMsg method
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Set(f func(msg *model.OrderEvent) (i1 int32, i2 int64, err error)) *IProducerOrderEventMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the IProducerOrderEvent.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the IProducerOrderEvent.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	mmSendMsg.mock.funcSendMsgOrigin = minimock.CallerInfo(1)
	return mmSendMsg.mock
}

// When sets expectation for the IProducerOrderEvent.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mIProducerOrderEventMockSendMsg) When(msg *model.OrderEvent) *IProducerOrderEventMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("IProducerOrderEventMock.SendMsg mock is already set by Set")
	}

	expectation := &IProducerOrderEventMockSendMsgExpectation{
		mock:               mmSendMsg.mock,
		params:             &IProducerOrderEventMockSendMsgParams{msg},
		expectationOrigins: IProducerOrderEventMockSendMsgExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up IProducerOrderEvent.SendMsg return parameters for the expectation previously defined by the When method
func (e *IProducerOrderEventMockSendMsgExpectation) Then(i1 int32, i2 int64, err error) *IProducerOrderEventMock {
	e.results = &IProducerOrderEventMockSendMsgResults{i1, i2, err}
	return e.mock
}

// Times sets number of times IProducerOrderEvent.SendMsg should be invoked
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Times(n uint64) *mIProducerOrderEventMockSendMsg {
	if n == 0 {
		mmSendMsg.mock.t.Fatalf("Times of IProducerOrderEventMock.SendMsg mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMsg.expectedInvocations, n)
	mmSendMsg.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMsg
}

func (mmSendMsg *mIProducerOrderEventMockSendMsg) invocationsDone() bool {
	if len(mmSendMsg.expectations) == 0 && mmSendMsg.defaultExpectation == nil && mmSendMsg.mock.funcSendMsg == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMsg.mock.afterSendMsgCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMsg.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMsg implements mm_service.IProducerOrderEvent
func (mmSendMsg *IProducerOrderEventMock) SendMsg(msg *model.OrderEvent) (i1 int32, i2 int64, err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	mmSendMsg.t.Helper()

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(msg)
	}

	mm_params := IProducerOrderEventMockSendMsgParams{msg}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, &mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.i2, e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_want_ptrs := mmSendMsg.SendMsgMock.defaultExpectation.paramPtrs

		mm_got := IProducerOrderEventMockSendMsgParams{msg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmSendMsg.t.Errorf("IProducerOrderEventMock.SendMsg got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMsg.SendMsgMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("IProducerOrderEventMock.SendMsg got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMsg.SendMsgMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the IProducerOrderEventMock.SendMsg")
		}
		return (*mm_results).i1, (*mm_results).i2, (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(msg)
	}
	mmSendMsg.t.Fatalf("Unexpected call to IProducerOrderEventMock.SendMsg. %v", msg)
	return
}

// SendMsgAfterCounter returns a count of finished IProducerOrderEventMock.SendMsg invocations
func (mmSendMsg *IProducerOrderEventMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of IProducerOrderEventMock.SendMsg invocations
func (mmSendMsg *IProducerOrderEventMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to IProducerOrderEventMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mIProducerOrderEventMockSendMsg) Calls() []*IProducerOrderEventMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*IProducerOrderEventMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *IProducerOrderEventMock) MinimockSendMsgDone() bool {
	if m.SendMsgMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMsgMock.invocationsDone()
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *IProducerOrderEventMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProducerOrderEventMock.SendMsg at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMsgCounter := mm_atomic.LoadUint64(&m.afterSendMsgCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && afterSendMsgCounter < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IProducerOrderEventMock.SendMsg at\n%s", m.SendMsgMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IProducerOrderEventMock.SendMsg at\n%s with params: %#v", m.SendMsgMock.defaultExpectation.expectationOrigins.origin, *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && afterSendMsgCounter < 1 {
		m.t.Errorf("Expected call to IProducerOrderEventMock.SendMsg at\n%s", m.funcSendMsgOrigin)
	}

	if !m.SendMsgMock.invocationsDone() && afterSendMsgCounter > 0 {
		m.t.Errorf("Expected %d calls to IProducerOrderEventMock.SendMsg at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMsgMock.expectedInvocations), m.SendMsgMock.expectedInvocationsOrigin, afterSendMsgCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IProducerOrderEventMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSendMsgInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IProducerOrderEventMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IProducerOrderEventMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSendMsgDone()
}
