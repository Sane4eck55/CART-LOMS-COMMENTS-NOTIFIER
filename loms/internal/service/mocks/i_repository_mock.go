// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/service.IRepository -o i_repository_mock.go -n IRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/model"
	repository_sqlc "github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/repository/sqlc/generated"
	pbKafka "github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/pkg/api/kafka"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// IRepositoryMock implements mm_service.IRepository
type IRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOutbox          func(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce) (err error)
	funcAddOutboxOrigin    string
	inspectFuncAddOutbox   func(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce)
	afterAddOutboxCounter  uint64
	beforeAddOutboxCounter uint64
	AddOutboxMock          mIRepositoryMockAddOutbox

	funcCreateOrder          func(ctx context.Context, usersOrders model.Order) (i1 int64, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, usersOrders model.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mIRepositoryMockCreateOrder

	funcDelete          func(ctx context.Context, orderID int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, orderID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIRepositoryMockDelete

	funcGetFreeStocksBySkuMaster          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcGetFreeStocksBySkuMasterOrigin    string
	inspectFuncGetFreeStocksBySkuMaster   func(ctx context.Context, sku int64)
	afterGetFreeStocksBySkuMasterCounter  uint64
	beforeGetFreeStocksBySkuMasterCounter uint64
	GetFreeStocksBySkuMasterMock          mIRepositoryMockGetFreeStocksBySkuMaster

	funcGetFreeStocksBySkuReplica          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcGetFreeStocksBySkuReplicaOrigin    string
	inspectFuncGetFreeStocksBySkuReplica   func(ctx context.Context, sku int64)
	afterGetFreeStocksBySkuReplicaCounter  uint64
	beforeGetFreeStocksBySkuReplicaCounter uint64
	GetFreeStocksBySkuReplicaMock          mIRepositoryMockGetFreeStocksBySkuReplica

	funcGetInfoByOrderIDMaster          func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)
	funcGetInfoByOrderIDMasterOrigin    string
	inspectFuncGetInfoByOrderIDMaster   func(ctx context.Context, orderID int64)
	afterGetInfoByOrderIDMasterCounter  uint64
	beforeGetInfoByOrderIDMasterCounter uint64
	GetInfoByOrderIDMasterMock          mIRepositoryMockGetInfoByOrderIDMaster

	funcGetInfoByOrderIDReplica          func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)
	funcGetInfoByOrderIDReplicaOrigin    string
	inspectFuncGetInfoByOrderIDReplica   func(ctx context.Context, orderID int64)
	afterGetInfoByOrderIDReplicaCounter  uint64
	beforeGetInfoByOrderIDReplicaCounter uint64
	GetInfoByOrderIDReplicaMock          mIRepositoryMockGetInfoByOrderIDReplica

	funcGetNewMsgOutbox          func(ctx context.Context) (gpa1 []*repository_sqlc.GetNewMsgOutboxRow, err error)
	funcGetNewMsgOutboxOrigin    string
	inspectFuncGetNewMsgOutbox   func(ctx context.Context)
	afterGetNewMsgOutboxCounter  uint64
	beforeGetNewMsgOutboxCounter uint64
	GetNewMsgOutboxMock          mIRepositoryMockGetNewMsgOutbox

	funcReserve          func(ctx context.Context, items []model.Item) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, items []model.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mIRepositoryMockReserve

	funcReserveCancel          func(ctx context.Context, item model.Item) (err error)
	funcReserveCancelOrigin    string
	inspectFuncReserveCancel   func(ctx context.Context, item model.Item)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mIRepositoryMockReserveCancel

	funcReserveRemove          func(ctx context.Context, item model.Item) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, item model.Item)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mIRepositoryMockReserveRemove

	funcSetStatusOrder          func(ctx context.Context, orderID int64, status string) (err error)
	funcSetStatusOrderOrigin    string
	inspectFuncSetStatusOrder   func(ctx context.Context, orderID int64, status string)
	afterSetStatusOrderCounter  uint64
	beforeSetStatusOrderCounter uint64
	SetStatusOrderMock          mIRepositoryMockSetStatusOrder

	funcUpdateStatusMsgOutbox          func(ctx context.Context, id int64, status string) (err error)
	funcUpdateStatusMsgOutboxOrigin    string
	inspectFuncUpdateStatusMsgOutbox   func(ctx context.Context, id int64, status string)
	afterUpdateStatusMsgOutboxCounter  uint64
	beforeUpdateStatusMsgOutboxCounter uint64
	UpdateStatusMsgOutboxMock          mIRepositoryMockUpdateStatusMsgOutbox

	funcUseMaster          func(typeReq string) (b1 bool)
	funcUseMasterOrigin    string
	inspectFuncUseMaster   func(typeReq string)
	afterUseMasterCounter  uint64
	beforeUseMasterCounter uint64
	UseMasterMock          mIRepositoryMockUseMaster
}

// NewIRepositoryMock returns a mock for mm_service.IRepository
func NewIRepositoryMock(t minimock.Tester) *IRepositoryMock {
	m := &IRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOutboxMock = mIRepositoryMockAddOutbox{mock: m}
	m.AddOutboxMock.callArgs = []*IRepositoryMockAddOutboxParams{}

	m.CreateOrderMock = mIRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*IRepositoryMockCreateOrderParams{}

	m.DeleteMock = mIRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IRepositoryMockDeleteParams{}

	m.GetFreeStocksBySkuMasterMock = mIRepositoryMockGetFreeStocksBySkuMaster{mock: m}
	m.GetFreeStocksBySkuMasterMock.callArgs = []*IRepositoryMockGetFreeStocksBySkuMasterParams{}

	m.GetFreeStocksBySkuReplicaMock = mIRepositoryMockGetFreeStocksBySkuReplica{mock: m}
	m.GetFreeStocksBySkuReplicaMock.callArgs = []*IRepositoryMockGetFreeStocksBySkuReplicaParams{}

	m.GetInfoByOrderIDMasterMock = mIRepositoryMockGetInfoByOrderIDMaster{mock: m}
	m.GetInfoByOrderIDMasterMock.callArgs = []*IRepositoryMockGetInfoByOrderIDMasterParams{}

	m.GetInfoByOrderIDReplicaMock = mIRepositoryMockGetInfoByOrderIDReplica{mock: m}
	m.GetInfoByOrderIDReplicaMock.callArgs = []*IRepositoryMockGetInfoByOrderIDReplicaParams{}

	m.GetNewMsgOutboxMock = mIRepositoryMockGetNewMsgOutbox{mock: m}
	m.GetNewMsgOutboxMock.callArgs = []*IRepositoryMockGetNewMsgOutboxParams{}

	m.ReserveMock = mIRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*IRepositoryMockReserveParams{}

	m.ReserveCancelMock = mIRepositoryMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*IRepositoryMockReserveCancelParams{}

	m.ReserveRemoveMock = mIRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*IRepositoryMockReserveRemoveParams{}

	m.SetStatusOrderMock = mIRepositoryMockSetStatusOrder{mock: m}
	m.SetStatusOrderMock.callArgs = []*IRepositoryMockSetStatusOrderParams{}

	m.UpdateStatusMsgOutboxMock = mIRepositoryMockUpdateStatusMsgOutbox{mock: m}
	m.UpdateStatusMsgOutboxMock.callArgs = []*IRepositoryMockUpdateStatusMsgOutboxParams{}

	m.UseMasterMock = mIRepositoryMockUseMaster{mock: m}
	m.UseMasterMock.callArgs = []*IRepositoryMockUseMasterParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIRepositoryMockAddOutbox struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockAddOutboxExpectation
	expectations       []*IRepositoryMockAddOutboxExpectation

	callArgs []*IRepositoryMockAddOutboxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockAddOutboxExpectation specifies expectation struct of the IRepository.AddOutbox
type IRepositoryMockAddOutboxExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockAddOutboxParams
	paramPtrs          *IRepositoryMockAddOutboxParamPtrs
	expectationOrigins IRepositoryMockAddOutboxExpectationOrigins
	results            *IRepositoryMockAddOutboxResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockAddOutboxParams contains parameters of the IRepository.AddOutbox
type IRepositoryMockAddOutboxParams struct {
	ctx   context.Context
	tx    pgx.Tx
	event *pbKafka.MsgProduce
}

// IRepositoryMockAddOutboxParamPtrs contains pointers to parameters of the IRepository.AddOutbox
type IRepositoryMockAddOutboxParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	event **pbKafka.MsgProduce
}

// IRepositoryMockAddOutboxResults contains results of the IRepository.AddOutbox
type IRepositoryMockAddOutboxResults struct {
	err error
}

// IRepositoryMockAddOutboxOrigins contains origins of expectations of the IRepository.AddOutbox
type IRepositoryMockAddOutboxExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOutbox *mIRepositoryMockAddOutbox) Optional() *mIRepositoryMockAddOutbox {
	mmAddOutbox.optional = true
	return mmAddOutbox
}

// Expect sets up expected params for IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) Expect(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce) *mIRepositoryMockAddOutbox {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	if mmAddOutbox.defaultExpectation == nil {
		mmAddOutbox.defaultExpectation = &IRepositoryMockAddOutboxExpectation{}
	}

	if mmAddOutbox.defaultExpectation.paramPtrs != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by ExpectParams functions")
	}

	mmAddOutbox.defaultExpectation.params = &IRepositoryMockAddOutboxParams{ctx, tx, event}
	mmAddOutbox.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOutbox.expectations {
		if minimock.Equal(e.params, mmAddOutbox.defaultExpectation.params) {
			mmAddOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOutbox.defaultExpectation.params)
		}
	}

	return mmAddOutbox
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockAddOutbox {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	if mmAddOutbox.defaultExpectation == nil {
		mmAddOutbox.defaultExpectation = &IRepositoryMockAddOutboxExpectation{}
	}

	if mmAddOutbox.defaultExpectation.params != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Expect")
	}

	if mmAddOutbox.defaultExpectation.paramPtrs == nil {
		mmAddOutbox.defaultExpectation.paramPtrs = &IRepositoryMockAddOutboxParamPtrs{}
	}
	mmAddOutbox.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOutbox.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOutbox
}

// ExpectTxParam2 sets up expected param tx for IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) ExpectTxParam2(tx pgx.Tx) *mIRepositoryMockAddOutbox {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	if mmAddOutbox.defaultExpectation == nil {
		mmAddOutbox.defaultExpectation = &IRepositoryMockAddOutboxExpectation{}
	}

	if mmAddOutbox.defaultExpectation.params != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Expect")
	}

	if mmAddOutbox.defaultExpectation.paramPtrs == nil {
		mmAddOutbox.defaultExpectation.paramPtrs = &IRepositoryMockAddOutboxParamPtrs{}
	}
	mmAddOutbox.defaultExpectation.paramPtrs.tx = &tx
	mmAddOutbox.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmAddOutbox
}

// ExpectEventParam3 sets up expected param event for IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) ExpectEventParam3(event *pbKafka.MsgProduce) *mIRepositoryMockAddOutbox {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	if mmAddOutbox.defaultExpectation == nil {
		mmAddOutbox.defaultExpectation = &IRepositoryMockAddOutboxExpectation{}
	}

	if mmAddOutbox.defaultExpectation.params != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Expect")
	}

	if mmAddOutbox.defaultExpectation.paramPtrs == nil {
		mmAddOutbox.defaultExpectation.paramPtrs = &IRepositoryMockAddOutboxParamPtrs{}
	}
	mmAddOutbox.defaultExpectation.paramPtrs.event = &event
	mmAddOutbox.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmAddOutbox
}

// Inspect accepts an inspector function that has same arguments as the IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) Inspect(f func(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce)) *mIRepositoryMockAddOutbox {
	if mmAddOutbox.mock.inspectFuncAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.AddOutbox")
	}

	mmAddOutbox.mock.inspectFuncAddOutbox = f

	return mmAddOutbox
}

// Return sets up results that will be returned by IRepository.AddOutbox
func (mmAddOutbox *mIRepositoryMockAddOutbox) Return(err error) *IRepositoryMock {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	if mmAddOutbox.defaultExpectation == nil {
		mmAddOutbox.defaultExpectation = &IRepositoryMockAddOutboxExpectation{mock: mmAddOutbox.mock}
	}
	mmAddOutbox.defaultExpectation.results = &IRepositoryMockAddOutboxResults{err}
	mmAddOutbox.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOutbox.mock
}

// Set uses given function f to mock the IRepository.AddOutbox method
func (mmAddOutbox *mIRepositoryMockAddOutbox) Set(f func(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce) (err error)) *IRepositoryMock {
	if mmAddOutbox.defaultExpectation != nil {
		mmAddOutbox.mock.t.Fatalf("Default expectation is already set for the IRepository.AddOutbox method")
	}

	if len(mmAddOutbox.expectations) > 0 {
		mmAddOutbox.mock.t.Fatalf("Some expectations are already set for the IRepository.AddOutbox method")
	}

	mmAddOutbox.mock.funcAddOutbox = f
	mmAddOutbox.mock.funcAddOutboxOrigin = minimock.CallerInfo(1)
	return mmAddOutbox.mock
}

// When sets expectation for the IRepository.AddOutbox which will trigger the result defined by the following
// Then helper
func (mmAddOutbox *mIRepositoryMockAddOutbox) When(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce) *IRepositoryMockAddOutboxExpectation {
	if mmAddOutbox.mock.funcAddOutbox != nil {
		mmAddOutbox.mock.t.Fatalf("IRepositoryMock.AddOutbox mock is already set by Set")
	}

	expectation := &IRepositoryMockAddOutboxExpectation{
		mock:               mmAddOutbox.mock,
		params:             &IRepositoryMockAddOutboxParams{ctx, tx, event},
		expectationOrigins: IRepositoryMockAddOutboxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOutbox.expectations = append(mmAddOutbox.expectations, expectation)
	return expectation
}

// Then sets up IRepository.AddOutbox return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockAddOutboxExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockAddOutboxResults{err}
	return e.mock
}

// Times sets number of times IRepository.AddOutbox should be invoked
func (mmAddOutbox *mIRepositoryMockAddOutbox) Times(n uint64) *mIRepositoryMockAddOutbox {
	if n == 0 {
		mmAddOutbox.mock.t.Fatalf("Times of IRepositoryMock.AddOutbox mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOutbox.expectedInvocations, n)
	mmAddOutbox.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOutbox
}

func (mmAddOutbox *mIRepositoryMockAddOutbox) invocationsDone() bool {
	if len(mmAddOutbox.expectations) == 0 && mmAddOutbox.defaultExpectation == nil && mmAddOutbox.mock.funcAddOutbox == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOutbox.mock.afterAddOutboxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOutbox.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOutbox implements mm_service.IRepository
func (mmAddOutbox *IRepositoryMock) AddOutbox(ctx context.Context, tx pgx.Tx, event *pbKafka.MsgProduce) (err error) {
	mm_atomic.AddUint64(&mmAddOutbox.beforeAddOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOutbox.afterAddOutboxCounter, 1)

	mmAddOutbox.t.Helper()

	if mmAddOutbox.inspectFuncAddOutbox != nil {
		mmAddOutbox.inspectFuncAddOutbox(ctx, tx, event)
	}

	mm_params := IRepositoryMockAddOutboxParams{ctx, tx, event}

	// Record call args
	mmAddOutbox.AddOutboxMock.mutex.Lock()
	mmAddOutbox.AddOutboxMock.callArgs = append(mmAddOutbox.AddOutboxMock.callArgs, &mm_params)
	mmAddOutbox.AddOutboxMock.mutex.Unlock()

	for _, e := range mmAddOutbox.AddOutboxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOutbox.AddOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOutbox.AddOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOutbox.AddOutboxMock.defaultExpectation.params
		mm_want_ptrs := mmAddOutbox.AddOutboxMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockAddOutboxParams{ctx, tx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOutbox.t.Errorf("IRepositoryMock.AddOutbox got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOutbox.AddOutboxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmAddOutbox.t.Errorf("IRepositoryMock.AddOutbox got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOutbox.AddOutboxMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmAddOutbox.t.Errorf("IRepositoryMock.AddOutbox got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOutbox.AddOutboxMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOutbox.t.Errorf("IRepositoryMock.AddOutbox got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOutbox.AddOutboxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOutbox.AddOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOutbox.t.Fatal("No results are set for the IRepositoryMock.AddOutbox")
		}
		return (*mm_results).err
	}
	if mmAddOutbox.funcAddOutbox != nil {
		return mmAddOutbox.funcAddOutbox(ctx, tx, event)
	}
	mmAddOutbox.t.Fatalf("Unexpected call to IRepositoryMock.AddOutbox. %v %v %v", ctx, tx, event)
	return
}

// AddOutboxAfterCounter returns a count of finished IRepositoryMock.AddOutbox invocations
func (mmAddOutbox *IRepositoryMock) AddOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOutbox.afterAddOutboxCounter)
}

// AddOutboxBeforeCounter returns a count of IRepositoryMock.AddOutbox invocations
func (mmAddOutbox *IRepositoryMock) AddOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOutbox.beforeAddOutboxCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.AddOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOutbox *mIRepositoryMockAddOutbox) Calls() []*IRepositoryMockAddOutboxParams {
	mmAddOutbox.mutex.RLock()

	argCopy := make([]*IRepositoryMockAddOutboxParams, len(mmAddOutbox.callArgs))
	copy(argCopy, mmAddOutbox.callArgs)

	mmAddOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockAddOutboxDone returns true if the count of the AddOutbox invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockAddOutboxDone() bool {
	if m.AddOutboxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOutboxMock.invocationsDone()
}

// MinimockAddOutboxInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockAddOutboxInspect() {
	for _, e := range m.AddOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.AddOutbox at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOutboxCounter := mm_atomic.LoadUint64(&m.afterAddOutboxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOutboxMock.defaultExpectation != nil && afterAddOutboxCounter < 1 {
		if m.AddOutboxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.AddOutbox at\n%s", m.AddOutboxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.AddOutbox at\n%s with params: %#v", m.AddOutboxMock.defaultExpectation.expectationOrigins.origin, *m.AddOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOutbox != nil && afterAddOutboxCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.AddOutbox at\n%s", m.funcAddOutboxOrigin)
	}

	if !m.AddOutboxMock.invocationsDone() && afterAddOutboxCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.AddOutbox at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOutboxMock.expectedInvocations), m.AddOutboxMock.expectedInvocationsOrigin, afterAddOutboxCounter)
	}
}

type mIRepositoryMockCreateOrder struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockCreateOrderExpectation
	expectations       []*IRepositoryMockCreateOrderExpectation

	callArgs []*IRepositoryMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockCreateOrderExpectation specifies expectation struct of the IRepository.CreateOrder
type IRepositoryMockCreateOrderExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockCreateOrderParams
	paramPtrs          *IRepositoryMockCreateOrderParamPtrs
	expectationOrigins IRepositoryMockCreateOrderExpectationOrigins
	results            *IRepositoryMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockCreateOrderParams contains parameters of the IRepository.CreateOrder
type IRepositoryMockCreateOrderParams struct {
	ctx         context.Context
	usersOrders model.Order
}

// IRepositoryMockCreateOrderParamPtrs contains pointers to parameters of the IRepository.CreateOrder
type IRepositoryMockCreateOrderParamPtrs struct {
	ctx         *context.Context
	usersOrders *model.Order
}

// IRepositoryMockCreateOrderResults contains results of the IRepository.CreateOrder
type IRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// IRepositoryMockCreateOrderOrigins contains origins of expectations of the IRepository.CreateOrder
type IRepositoryMockCreateOrderExpectationOrigins struct {
	origin            string
	originCtx         string
	originUsersOrders string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mIRepositoryMockCreateOrder) Optional() *mIRepositoryMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for IRepository.CreateOrder
func (mmCreateOrder *mIRepositoryMockCreateOrder) Expect(ctx context.Context, usersOrders model.Order) *mIRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &IRepositoryMockCreateOrderParams{ctx, usersOrders}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.CreateOrder
func (mmCreateOrder *mIRepositoryMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &IRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectUsersOrdersParam2 sets up expected param usersOrders for IRepository.CreateOrder
func (mmCreateOrder *mIRepositoryMockCreateOrder) ExpectUsersOrdersParam2(usersOrders model.Order) *mIRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &IRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.usersOrders = &usersOrders
	mmCreateOrder.defaultExpectation.expectationOrigins.originUsersOrders = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the IRepository.CreateOrder
func (mmCreateOrder *mIRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, usersOrders model.Order)) *mIRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by IRepository.CreateOrder
func (mmCreateOrder *mIRepositoryMockCreateOrder) Return(i1 int64, err error) *IRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &IRepositoryMockCreateOrderResults{i1, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the IRepository.CreateOrder method
func (mmCreateOrder *mIRepositoryMockCreateOrder) Set(f func(ctx context.Context, usersOrders model.Order) (i1 int64, err error)) *IRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the IRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the IRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the IRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mIRepositoryMockCreateOrder) When(ctx context.Context, usersOrders model.Order) *IRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &IRepositoryMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &IRepositoryMockCreateOrderParams{ctx, usersOrders},
		expectationOrigins: IRepositoryMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up IRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *IRepositoryMock {
	e.results = &IRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// Times sets number of times IRepository.CreateOrder should be invoked
func (mmCreateOrder *mIRepositoryMockCreateOrder) Times(n uint64) *mIRepositoryMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of IRepositoryMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mIRepositoryMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_service.IRepository
func (mmCreateOrder *IRepositoryMock) CreateOrder(ctx context.Context, usersOrders model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, usersOrders)
	}

	mm_params := IRepositoryMockCreateOrderParams{ctx, usersOrders}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockCreateOrderParams{ctx, usersOrders}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("IRepositoryMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.usersOrders != nil && !minimock.Equal(*mm_want_ptrs.usersOrders, mm_got.usersOrders) {
				mmCreateOrder.t.Errorf("IRepositoryMock.CreateOrder got unexpected parameter usersOrders, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originUsersOrders, *mm_want_ptrs.usersOrders, mm_got.usersOrders, minimock.Diff(*mm_want_ptrs.usersOrders, mm_got.usersOrders))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("IRepositoryMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the IRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, usersOrders)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to IRepositoryMock.CreateOrder. %v %v", ctx, usersOrders)
	return
}

// CreateOrderAfterCounter returns a count of finished IRepositoryMock.CreateOrder invocations
func (mmCreateOrder *IRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of IRepositoryMock.CreateOrder invocations
func (mmCreateOrder *IRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mIRepositoryMockCreateOrder) Calls() []*IRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*IRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mIRepositoryMockDelete struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockDeleteExpectation
	expectations       []*IRepositoryMockDeleteExpectation

	callArgs []*IRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockDeleteExpectation specifies expectation struct of the IRepository.Delete
type IRepositoryMockDeleteExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockDeleteParams
	paramPtrs          *IRepositoryMockDeleteParamPtrs
	expectationOrigins IRepositoryMockDeleteExpectationOrigins
	results            *IRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockDeleteParams contains parameters of the IRepository.Delete
type IRepositoryMockDeleteParams struct {
	ctx     context.Context
	orderID int64
}

// IRepositoryMockDeleteParamPtrs contains pointers to parameters of the IRepository.Delete
type IRepositoryMockDeleteParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// IRepositoryMockDeleteResults contains results of the IRepository.Delete
type IRepositoryMockDeleteResults struct {
	err error
}

// IRepositoryMockDeleteOrigins contains origins of expectations of the IRepository.Delete
type IRepositoryMockDeleteExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mIRepositoryMockDelete) Optional() *mIRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for IRepository.Delete
func (mmDelete *mIRepositoryMockDelete) Expect(ctx context.Context, orderID int64) *mIRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &IRepositoryMockDeleteParams{ctx, orderID}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.Delete
func (mmDelete *mIRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &IRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectOrderIDParam2 sets up expected param orderID for IRepository.Delete
func (mmDelete *mIRepositoryMockDelete) ExpectOrderIDParam2(orderID int64) *mIRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &IRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.orderID = &orderID
	mmDelete.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Delete
func (mmDelete *mIRepositoryMockDelete) Inspect(f func(ctx context.Context, orderID int64)) *mIRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IRepository.Delete
func (mmDelete *mIRepositoryMockDelete) Return(err error) *IRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the IRepository.Delete method
func (mmDelete *mIRepositoryMockDelete) Set(f func(ctx context.Context, orderID int64) (err error)) *IRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the IRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIRepositoryMockDelete) When(ctx context.Context, orderID int64) *IRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &IRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &IRepositoryMockDeleteParams{ctx, orderID},
		expectationOrigins: IRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Delete return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockDeleteExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times IRepository.Delete should be invoked
func (mmDelete *mIRepositoryMockDelete) Times(n uint64) *mIRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of IRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mIRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_service.IRepository
func (mmDelete *IRepositoryMock) Delete(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, orderID)
	}

	mm_params := IRepositoryMockDeleteParams{ctx, orderID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockDeleteParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("IRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDelete.t.Errorf("IRepositoryMock.Delete got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, orderID)
	}
	mmDelete.t.Fatalf("Unexpected call to IRepositoryMock.Delete. %v %v", ctx, orderID)
	return
}

// DeleteAfterCounter returns a count of finished IRepositoryMock.Delete invocations
func (mmDelete *IRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IRepositoryMock.Delete invocations
func (mmDelete *IRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIRepositoryMockDelete) Calls() []*IRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mIRepositoryMockGetFreeStocksBySkuMaster struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetFreeStocksBySkuMasterExpectation
	expectations       []*IRepositoryMockGetFreeStocksBySkuMasterExpectation

	callArgs []*IRepositoryMockGetFreeStocksBySkuMasterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetFreeStocksBySkuMasterExpectation specifies expectation struct of the IRepository.GetFreeStocksBySkuMaster
type IRepositoryMockGetFreeStocksBySkuMasterExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetFreeStocksBySkuMasterParams
	paramPtrs          *IRepositoryMockGetFreeStocksBySkuMasterParamPtrs
	expectationOrigins IRepositoryMockGetFreeStocksBySkuMasterExpectationOrigins
	results            *IRepositoryMockGetFreeStocksBySkuMasterResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetFreeStocksBySkuMasterParams contains parameters of the IRepository.GetFreeStocksBySkuMaster
type IRepositoryMockGetFreeStocksBySkuMasterParams struct {
	ctx context.Context
	sku int64
}

// IRepositoryMockGetFreeStocksBySkuMasterParamPtrs contains pointers to parameters of the IRepository.GetFreeStocksBySkuMaster
type IRepositoryMockGetFreeStocksBySkuMasterParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// IRepositoryMockGetFreeStocksBySkuMasterResults contains results of the IRepository.GetFreeStocksBySkuMaster
type IRepositoryMockGetFreeStocksBySkuMasterResults struct {
	u1  uint32
	err error
}

// IRepositoryMockGetFreeStocksBySkuMasterOrigins contains origins of expectations of the IRepository.GetFreeStocksBySkuMaster
type IRepositoryMockGetFreeStocksBySkuMasterExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Optional() *mIRepositoryMockGetFreeStocksBySkuMaster {
	mmGetFreeStocksBySkuMaster.optional = true
	return mmGetFreeStocksBySkuMaster
}

// Expect sets up expected params for IRepository.GetFreeStocksBySkuMaster
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Expect(ctx context.Context, sku int64) *mIRepositoryMockGetFreeStocksBySkuMaster {
	if mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Set")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuMasterExpectation{}
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by ExpectParams functions")
	}

	mmGetFreeStocksBySkuMaster.defaultExpectation.params = &IRepositoryMockGetFreeStocksBySkuMasterParams{ctx, sku}
	mmGetFreeStocksBySkuMaster.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFreeStocksBySkuMaster.expectations {
		if minimock.Equal(e.params, mmGetFreeStocksBySkuMaster.defaultExpectation.params) {
			mmGetFreeStocksBySkuMaster.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFreeStocksBySkuMaster.defaultExpectation.params)
		}
	}

	return mmGetFreeStocksBySkuMaster
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetFreeStocksBySkuMaster
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetFreeStocksBySkuMaster {
	if mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Set")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuMasterExpectation{}
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation.params != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Expect")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs = &IRepositoryMockGetFreeStocksBySkuMasterParamPtrs{}
	}
	mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFreeStocksBySkuMaster.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFreeStocksBySkuMaster
}

// ExpectSkuParam2 sets up expected param sku for IRepository.GetFreeStocksBySkuMaster
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) ExpectSkuParam2(sku int64) *mIRepositoryMockGetFreeStocksBySkuMaster {
	if mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Set")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuMasterExpectation{}
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation.params != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Expect")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs = &IRepositoryMockGetFreeStocksBySkuMasterParamPtrs{}
	}
	mmGetFreeStocksBySkuMaster.defaultExpectation.paramPtrs.sku = &sku
	mmGetFreeStocksBySkuMaster.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetFreeStocksBySkuMaster
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetFreeStocksBySkuMaster
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Inspect(f func(ctx context.Context, sku int64)) *mIRepositoryMockGetFreeStocksBySkuMaster {
	if mmGetFreeStocksBySkuMaster.mock.inspectFuncGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetFreeStocksBySkuMaster")
	}

	mmGetFreeStocksBySkuMaster.mock.inspectFuncGetFreeStocksBySkuMaster = f

	return mmGetFreeStocksBySkuMaster
}

// Return sets up results that will be returned by IRepository.GetFreeStocksBySkuMaster
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Return(u1 uint32, err error) *IRepositoryMock {
	if mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Set")
	}

	if mmGetFreeStocksBySkuMaster.defaultExpectation == nil {
		mmGetFreeStocksBySkuMaster.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuMasterExpectation{mock: mmGetFreeStocksBySkuMaster.mock}
	}
	mmGetFreeStocksBySkuMaster.defaultExpectation.results = &IRepositoryMockGetFreeStocksBySkuMasterResults{u1, err}
	mmGetFreeStocksBySkuMaster.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuMaster.mock
}

// Set uses given function f to mock the IRepository.GetFreeStocksBySkuMaster method
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *IRepositoryMock {
	if mmGetFreeStocksBySkuMaster.defaultExpectation != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("Default expectation is already set for the IRepository.GetFreeStocksBySkuMaster method")
	}

	if len(mmGetFreeStocksBySkuMaster.expectations) > 0 {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("Some expectations are already set for the IRepository.GetFreeStocksBySkuMaster method")
	}

	mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster = f
	mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMasterOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuMaster.mock
}

// When sets expectation for the IRepository.GetFreeStocksBySkuMaster which will trigger the result defined by the following
// Then helper
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) When(ctx context.Context, sku int64) *IRepositoryMockGetFreeStocksBySkuMasterExpectation {
	if mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuMaster mock is already set by Set")
	}

	expectation := &IRepositoryMockGetFreeStocksBySkuMasterExpectation{
		mock:               mmGetFreeStocksBySkuMaster.mock,
		params:             &IRepositoryMockGetFreeStocksBySkuMasterParams{ctx, sku},
		expectationOrigins: IRepositoryMockGetFreeStocksBySkuMasterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFreeStocksBySkuMaster.expectations = append(mmGetFreeStocksBySkuMaster.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetFreeStocksBySkuMaster return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetFreeStocksBySkuMasterExpectation) Then(u1 uint32, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetFreeStocksBySkuMasterResults{u1, err}
	return e.mock
}

// Times sets number of times IRepository.GetFreeStocksBySkuMaster should be invoked
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Times(n uint64) *mIRepositoryMockGetFreeStocksBySkuMaster {
	if n == 0 {
		mmGetFreeStocksBySkuMaster.mock.t.Fatalf("Times of IRepositoryMock.GetFreeStocksBySkuMaster mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFreeStocksBySkuMaster.expectedInvocations, n)
	mmGetFreeStocksBySkuMaster.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuMaster
}

func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) invocationsDone() bool {
	if len(mmGetFreeStocksBySkuMaster.expectations) == 0 && mmGetFreeStocksBySkuMaster.defaultExpectation == nil && mmGetFreeStocksBySkuMaster.mock.funcGetFreeStocksBySkuMaster == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFreeStocksBySkuMaster.mock.afterGetFreeStocksBySkuMasterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFreeStocksBySkuMaster.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFreeStocksBySkuMaster implements mm_service.IRepository
func (mmGetFreeStocksBySkuMaster *IRepositoryMock) GetFreeStocksBySkuMaster(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetFreeStocksBySkuMaster.beforeGetFreeStocksBySkuMasterCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFreeStocksBySkuMaster.afterGetFreeStocksBySkuMasterCounter, 1)

	mmGetFreeStocksBySkuMaster.t.Helper()

	if mmGetFreeStocksBySkuMaster.inspectFuncGetFreeStocksBySkuMaster != nil {
		mmGetFreeStocksBySkuMaster.inspectFuncGetFreeStocksBySkuMaster(ctx, sku)
	}

	mm_params := IRepositoryMockGetFreeStocksBySkuMasterParams{ctx, sku}

	// Record call args
	mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.mutex.Lock()
	mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.callArgs = append(mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.callArgs, &mm_params)
	mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.mutex.Unlock()

	for _, e := range mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.params
		mm_want_ptrs := mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetFreeStocksBySkuMasterParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFreeStocksBySkuMaster.t.Errorf("IRepositoryMock.GetFreeStocksBySkuMaster got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetFreeStocksBySkuMaster.t.Errorf("IRepositoryMock.GetFreeStocksBySkuMaster got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFreeStocksBySkuMaster.t.Errorf("IRepositoryMock.GetFreeStocksBySkuMaster got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFreeStocksBySkuMaster.GetFreeStocksBySkuMasterMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFreeStocksBySkuMaster.t.Fatal("No results are set for the IRepositoryMock.GetFreeStocksBySkuMaster")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetFreeStocksBySkuMaster.funcGetFreeStocksBySkuMaster != nil {
		return mmGetFreeStocksBySkuMaster.funcGetFreeStocksBySkuMaster(ctx, sku)
	}
	mmGetFreeStocksBySkuMaster.t.Fatalf("Unexpected call to IRepositoryMock.GetFreeStocksBySkuMaster. %v %v", ctx, sku)
	return
}

// GetFreeStocksBySkuMasterAfterCounter returns a count of finished IRepositoryMock.GetFreeStocksBySkuMaster invocations
func (mmGetFreeStocksBySkuMaster *IRepositoryMock) GetFreeStocksBySkuMasterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFreeStocksBySkuMaster.afterGetFreeStocksBySkuMasterCounter)
}

// GetFreeStocksBySkuMasterBeforeCounter returns a count of IRepositoryMock.GetFreeStocksBySkuMaster invocations
func (mmGetFreeStocksBySkuMaster *IRepositoryMock) GetFreeStocksBySkuMasterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFreeStocksBySkuMaster.beforeGetFreeStocksBySkuMasterCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetFreeStocksBySkuMaster.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFreeStocksBySkuMaster *mIRepositoryMockGetFreeStocksBySkuMaster) Calls() []*IRepositoryMockGetFreeStocksBySkuMasterParams {
	mmGetFreeStocksBySkuMaster.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetFreeStocksBySkuMasterParams, len(mmGetFreeStocksBySkuMaster.callArgs))
	copy(argCopy, mmGetFreeStocksBySkuMaster.callArgs)

	mmGetFreeStocksBySkuMaster.mutex.RUnlock()

	return argCopy
}

// MinimockGetFreeStocksBySkuMasterDone returns true if the count of the GetFreeStocksBySkuMaster invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetFreeStocksBySkuMasterDone() bool {
	if m.GetFreeStocksBySkuMasterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFreeStocksBySkuMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFreeStocksBySkuMasterMock.invocationsDone()
}

// MinimockGetFreeStocksBySkuMasterInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetFreeStocksBySkuMasterInspect() {
	for _, e := range m.GetFreeStocksBySkuMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuMaster at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFreeStocksBySkuMasterCounter := mm_atomic.LoadUint64(&m.afterGetFreeStocksBySkuMasterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFreeStocksBySkuMasterMock.defaultExpectation != nil && afterGetFreeStocksBySkuMasterCounter < 1 {
		if m.GetFreeStocksBySkuMasterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuMaster at\n%s", m.GetFreeStocksBySkuMasterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuMaster at\n%s with params: %#v", m.GetFreeStocksBySkuMasterMock.defaultExpectation.expectationOrigins.origin, *m.GetFreeStocksBySkuMasterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFreeStocksBySkuMaster != nil && afterGetFreeStocksBySkuMasterCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuMaster at\n%s", m.funcGetFreeStocksBySkuMasterOrigin)
	}

	if !m.GetFreeStocksBySkuMasterMock.invocationsDone() && afterGetFreeStocksBySkuMasterCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetFreeStocksBySkuMaster at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFreeStocksBySkuMasterMock.expectedInvocations), m.GetFreeStocksBySkuMasterMock.expectedInvocationsOrigin, afterGetFreeStocksBySkuMasterCounter)
	}
}

type mIRepositoryMockGetFreeStocksBySkuReplica struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetFreeStocksBySkuReplicaExpectation
	expectations       []*IRepositoryMockGetFreeStocksBySkuReplicaExpectation

	callArgs []*IRepositoryMockGetFreeStocksBySkuReplicaParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetFreeStocksBySkuReplicaExpectation specifies expectation struct of the IRepository.GetFreeStocksBySkuReplica
type IRepositoryMockGetFreeStocksBySkuReplicaExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetFreeStocksBySkuReplicaParams
	paramPtrs          *IRepositoryMockGetFreeStocksBySkuReplicaParamPtrs
	expectationOrigins IRepositoryMockGetFreeStocksBySkuReplicaExpectationOrigins
	results            *IRepositoryMockGetFreeStocksBySkuReplicaResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetFreeStocksBySkuReplicaParams contains parameters of the IRepository.GetFreeStocksBySkuReplica
type IRepositoryMockGetFreeStocksBySkuReplicaParams struct {
	ctx context.Context
	sku int64
}

// IRepositoryMockGetFreeStocksBySkuReplicaParamPtrs contains pointers to parameters of the IRepository.GetFreeStocksBySkuReplica
type IRepositoryMockGetFreeStocksBySkuReplicaParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// IRepositoryMockGetFreeStocksBySkuReplicaResults contains results of the IRepository.GetFreeStocksBySkuReplica
type IRepositoryMockGetFreeStocksBySkuReplicaResults struct {
	u1  uint32
	err error
}

// IRepositoryMockGetFreeStocksBySkuReplicaOrigins contains origins of expectations of the IRepository.GetFreeStocksBySkuReplica
type IRepositoryMockGetFreeStocksBySkuReplicaExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Optional() *mIRepositoryMockGetFreeStocksBySkuReplica {
	mmGetFreeStocksBySkuReplica.optional = true
	return mmGetFreeStocksBySkuReplica
}

// Expect sets up expected params for IRepository.GetFreeStocksBySkuReplica
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Expect(ctx context.Context, sku int64) *mIRepositoryMockGetFreeStocksBySkuReplica {
	if mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Set")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuReplicaExpectation{}
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by ExpectParams functions")
	}

	mmGetFreeStocksBySkuReplica.defaultExpectation.params = &IRepositoryMockGetFreeStocksBySkuReplicaParams{ctx, sku}
	mmGetFreeStocksBySkuReplica.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFreeStocksBySkuReplica.expectations {
		if minimock.Equal(e.params, mmGetFreeStocksBySkuReplica.defaultExpectation.params) {
			mmGetFreeStocksBySkuReplica.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFreeStocksBySkuReplica.defaultExpectation.params)
		}
	}

	return mmGetFreeStocksBySkuReplica
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetFreeStocksBySkuReplica
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetFreeStocksBySkuReplica {
	if mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Set")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuReplicaExpectation{}
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation.params != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Expect")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs = &IRepositoryMockGetFreeStocksBySkuReplicaParamPtrs{}
	}
	mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFreeStocksBySkuReplica.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFreeStocksBySkuReplica
}

// ExpectSkuParam2 sets up expected param sku for IRepository.GetFreeStocksBySkuReplica
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) ExpectSkuParam2(sku int64) *mIRepositoryMockGetFreeStocksBySkuReplica {
	if mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Set")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuReplicaExpectation{}
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation.params != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Expect")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs = &IRepositoryMockGetFreeStocksBySkuReplicaParamPtrs{}
	}
	mmGetFreeStocksBySkuReplica.defaultExpectation.paramPtrs.sku = &sku
	mmGetFreeStocksBySkuReplica.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetFreeStocksBySkuReplica
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetFreeStocksBySkuReplica
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Inspect(f func(ctx context.Context, sku int64)) *mIRepositoryMockGetFreeStocksBySkuReplica {
	if mmGetFreeStocksBySkuReplica.mock.inspectFuncGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetFreeStocksBySkuReplica")
	}

	mmGetFreeStocksBySkuReplica.mock.inspectFuncGetFreeStocksBySkuReplica = f

	return mmGetFreeStocksBySkuReplica
}

// Return sets up results that will be returned by IRepository.GetFreeStocksBySkuReplica
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Return(u1 uint32, err error) *IRepositoryMock {
	if mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Set")
	}

	if mmGetFreeStocksBySkuReplica.defaultExpectation == nil {
		mmGetFreeStocksBySkuReplica.defaultExpectation = &IRepositoryMockGetFreeStocksBySkuReplicaExpectation{mock: mmGetFreeStocksBySkuReplica.mock}
	}
	mmGetFreeStocksBySkuReplica.defaultExpectation.results = &IRepositoryMockGetFreeStocksBySkuReplicaResults{u1, err}
	mmGetFreeStocksBySkuReplica.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuReplica.mock
}

// Set uses given function f to mock the IRepository.GetFreeStocksBySkuReplica method
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *IRepositoryMock {
	if mmGetFreeStocksBySkuReplica.defaultExpectation != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("Default expectation is already set for the IRepository.GetFreeStocksBySkuReplica method")
	}

	if len(mmGetFreeStocksBySkuReplica.expectations) > 0 {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("Some expectations are already set for the IRepository.GetFreeStocksBySkuReplica method")
	}

	mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica = f
	mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplicaOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuReplica.mock
}

// When sets expectation for the IRepository.GetFreeStocksBySkuReplica which will trigger the result defined by the following
// Then helper
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) When(ctx context.Context, sku int64) *IRepositoryMockGetFreeStocksBySkuReplicaExpectation {
	if mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("IRepositoryMock.GetFreeStocksBySkuReplica mock is already set by Set")
	}

	expectation := &IRepositoryMockGetFreeStocksBySkuReplicaExpectation{
		mock:               mmGetFreeStocksBySkuReplica.mock,
		params:             &IRepositoryMockGetFreeStocksBySkuReplicaParams{ctx, sku},
		expectationOrigins: IRepositoryMockGetFreeStocksBySkuReplicaExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFreeStocksBySkuReplica.expectations = append(mmGetFreeStocksBySkuReplica.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetFreeStocksBySkuReplica return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetFreeStocksBySkuReplicaExpectation) Then(u1 uint32, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetFreeStocksBySkuReplicaResults{u1, err}
	return e.mock
}

// Times sets number of times IRepository.GetFreeStocksBySkuReplica should be invoked
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Times(n uint64) *mIRepositoryMockGetFreeStocksBySkuReplica {
	if n == 0 {
		mmGetFreeStocksBySkuReplica.mock.t.Fatalf("Times of IRepositoryMock.GetFreeStocksBySkuReplica mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFreeStocksBySkuReplica.expectedInvocations, n)
	mmGetFreeStocksBySkuReplica.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFreeStocksBySkuReplica
}

func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) invocationsDone() bool {
	if len(mmGetFreeStocksBySkuReplica.expectations) == 0 && mmGetFreeStocksBySkuReplica.defaultExpectation == nil && mmGetFreeStocksBySkuReplica.mock.funcGetFreeStocksBySkuReplica == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFreeStocksBySkuReplica.mock.afterGetFreeStocksBySkuReplicaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFreeStocksBySkuReplica.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFreeStocksBySkuReplica implements mm_service.IRepository
func (mmGetFreeStocksBySkuReplica *IRepositoryMock) GetFreeStocksBySkuReplica(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetFreeStocksBySkuReplica.beforeGetFreeStocksBySkuReplicaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFreeStocksBySkuReplica.afterGetFreeStocksBySkuReplicaCounter, 1)

	mmGetFreeStocksBySkuReplica.t.Helper()

	if mmGetFreeStocksBySkuReplica.inspectFuncGetFreeStocksBySkuReplica != nil {
		mmGetFreeStocksBySkuReplica.inspectFuncGetFreeStocksBySkuReplica(ctx, sku)
	}

	mm_params := IRepositoryMockGetFreeStocksBySkuReplicaParams{ctx, sku}

	// Record call args
	mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.mutex.Lock()
	mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.callArgs = append(mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.callArgs, &mm_params)
	mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.mutex.Unlock()

	for _, e := range mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.params
		mm_want_ptrs := mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetFreeStocksBySkuReplicaParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFreeStocksBySkuReplica.t.Errorf("IRepositoryMock.GetFreeStocksBySkuReplica got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetFreeStocksBySkuReplica.t.Errorf("IRepositoryMock.GetFreeStocksBySkuReplica got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFreeStocksBySkuReplica.t.Errorf("IRepositoryMock.GetFreeStocksBySkuReplica got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFreeStocksBySkuReplica.GetFreeStocksBySkuReplicaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFreeStocksBySkuReplica.t.Fatal("No results are set for the IRepositoryMock.GetFreeStocksBySkuReplica")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetFreeStocksBySkuReplica.funcGetFreeStocksBySkuReplica != nil {
		return mmGetFreeStocksBySkuReplica.funcGetFreeStocksBySkuReplica(ctx, sku)
	}
	mmGetFreeStocksBySkuReplica.t.Fatalf("Unexpected call to IRepositoryMock.GetFreeStocksBySkuReplica. %v %v", ctx, sku)
	return
}

// GetFreeStocksBySkuReplicaAfterCounter returns a count of finished IRepositoryMock.GetFreeStocksBySkuReplica invocations
func (mmGetFreeStocksBySkuReplica *IRepositoryMock) GetFreeStocksBySkuReplicaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFreeStocksBySkuReplica.afterGetFreeStocksBySkuReplicaCounter)
}

// GetFreeStocksBySkuReplicaBeforeCounter returns a count of IRepositoryMock.GetFreeStocksBySkuReplica invocations
func (mmGetFreeStocksBySkuReplica *IRepositoryMock) GetFreeStocksBySkuReplicaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFreeStocksBySkuReplica.beforeGetFreeStocksBySkuReplicaCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetFreeStocksBySkuReplica.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFreeStocksBySkuReplica *mIRepositoryMockGetFreeStocksBySkuReplica) Calls() []*IRepositoryMockGetFreeStocksBySkuReplicaParams {
	mmGetFreeStocksBySkuReplica.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetFreeStocksBySkuReplicaParams, len(mmGetFreeStocksBySkuReplica.callArgs))
	copy(argCopy, mmGetFreeStocksBySkuReplica.callArgs)

	mmGetFreeStocksBySkuReplica.mutex.RUnlock()

	return argCopy
}

// MinimockGetFreeStocksBySkuReplicaDone returns true if the count of the GetFreeStocksBySkuReplica invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetFreeStocksBySkuReplicaDone() bool {
	if m.GetFreeStocksBySkuReplicaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFreeStocksBySkuReplicaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFreeStocksBySkuReplicaMock.invocationsDone()
}

// MinimockGetFreeStocksBySkuReplicaInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetFreeStocksBySkuReplicaInspect() {
	for _, e := range m.GetFreeStocksBySkuReplicaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuReplica at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFreeStocksBySkuReplicaCounter := mm_atomic.LoadUint64(&m.afterGetFreeStocksBySkuReplicaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFreeStocksBySkuReplicaMock.defaultExpectation != nil && afterGetFreeStocksBySkuReplicaCounter < 1 {
		if m.GetFreeStocksBySkuReplicaMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuReplica at\n%s", m.GetFreeStocksBySkuReplicaMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuReplica at\n%s with params: %#v", m.GetFreeStocksBySkuReplicaMock.defaultExpectation.expectationOrigins.origin, *m.GetFreeStocksBySkuReplicaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFreeStocksBySkuReplica != nil && afterGetFreeStocksBySkuReplicaCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetFreeStocksBySkuReplica at\n%s", m.funcGetFreeStocksBySkuReplicaOrigin)
	}

	if !m.GetFreeStocksBySkuReplicaMock.invocationsDone() && afterGetFreeStocksBySkuReplicaCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetFreeStocksBySkuReplica at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFreeStocksBySkuReplicaMock.expectedInvocations), m.GetFreeStocksBySkuReplicaMock.expectedInvocationsOrigin, afterGetFreeStocksBySkuReplicaCounter)
	}
}

type mIRepositoryMockGetInfoByOrderIDMaster struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetInfoByOrderIDMasterExpectation
	expectations       []*IRepositoryMockGetInfoByOrderIDMasterExpectation

	callArgs []*IRepositoryMockGetInfoByOrderIDMasterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetInfoByOrderIDMasterExpectation specifies expectation struct of the IRepository.GetInfoByOrderIDMaster
type IRepositoryMockGetInfoByOrderIDMasterExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetInfoByOrderIDMasterParams
	paramPtrs          *IRepositoryMockGetInfoByOrderIDMasterParamPtrs
	expectationOrigins IRepositoryMockGetInfoByOrderIDMasterExpectationOrigins
	results            *IRepositoryMockGetInfoByOrderIDMasterResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetInfoByOrderIDMasterParams contains parameters of the IRepository.GetInfoByOrderIDMaster
type IRepositoryMockGetInfoByOrderIDMasterParams struct {
	ctx     context.Context
	orderID int64
}

// IRepositoryMockGetInfoByOrderIDMasterParamPtrs contains pointers to parameters of the IRepository.GetInfoByOrderIDMaster
type IRepositoryMockGetInfoByOrderIDMasterParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// IRepositoryMockGetInfoByOrderIDMasterResults contains results of the IRepository.GetInfoByOrderIDMaster
type IRepositoryMockGetInfoByOrderIDMasterResults struct {
	op1 *model.OrderInfo
	err error
}

// IRepositoryMockGetInfoByOrderIDMasterOrigins contains origins of expectations of the IRepository.GetInfoByOrderIDMaster
type IRepositoryMockGetInfoByOrderIDMasterExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Optional() *mIRepositoryMockGetInfoByOrderIDMaster {
	mmGetInfoByOrderIDMaster.optional = true
	return mmGetInfoByOrderIDMaster
}

// Expect sets up expected params for IRepository.GetInfoByOrderIDMaster
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Expect(ctx context.Context, orderID int64) *mIRepositoryMockGetInfoByOrderIDMaster {
	if mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Set")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation = &IRepositoryMockGetInfoByOrderIDMasterExpectation{}
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by ExpectParams functions")
	}

	mmGetInfoByOrderIDMaster.defaultExpectation.params = &IRepositoryMockGetInfoByOrderIDMasterParams{ctx, orderID}
	mmGetInfoByOrderIDMaster.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInfoByOrderIDMaster.expectations {
		if minimock.Equal(e.params, mmGetInfoByOrderIDMaster.defaultExpectation.params) {
			mmGetInfoByOrderIDMaster.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInfoByOrderIDMaster.defaultExpectation.params)
		}
	}

	return mmGetInfoByOrderIDMaster
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetInfoByOrderIDMaster
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetInfoByOrderIDMaster {
	if mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Set")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation = &IRepositoryMockGetInfoByOrderIDMasterExpectation{}
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation.params != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Expect")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs = &IRepositoryMockGetInfoByOrderIDMasterParamPtrs{}
	}
	mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInfoByOrderIDMaster.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInfoByOrderIDMaster
}

// ExpectOrderIDParam2 sets up expected param orderID for IRepository.GetInfoByOrderIDMaster
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) ExpectOrderIDParam2(orderID int64) *mIRepositoryMockGetInfoByOrderIDMaster {
	if mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Set")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation = &IRepositoryMockGetInfoByOrderIDMasterExpectation{}
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation.params != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Expect")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs = &IRepositoryMockGetInfoByOrderIDMasterParamPtrs{}
	}
	mmGetInfoByOrderIDMaster.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetInfoByOrderIDMaster.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetInfoByOrderIDMaster
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetInfoByOrderIDMaster
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Inspect(f func(ctx context.Context, orderID int64)) *mIRepositoryMockGetInfoByOrderIDMaster {
	if mmGetInfoByOrderIDMaster.mock.inspectFuncGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetInfoByOrderIDMaster")
	}

	mmGetInfoByOrderIDMaster.mock.inspectFuncGetInfoByOrderIDMaster = f

	return mmGetInfoByOrderIDMaster
}

// Return sets up results that will be returned by IRepository.GetInfoByOrderIDMaster
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Return(op1 *model.OrderInfo, err error) *IRepositoryMock {
	if mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Set")
	}

	if mmGetInfoByOrderIDMaster.defaultExpectation == nil {
		mmGetInfoByOrderIDMaster.defaultExpectation = &IRepositoryMockGetInfoByOrderIDMasterExpectation{mock: mmGetInfoByOrderIDMaster.mock}
	}
	mmGetInfoByOrderIDMaster.defaultExpectation.results = &IRepositoryMockGetInfoByOrderIDMasterResults{op1, err}
	mmGetInfoByOrderIDMaster.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDMaster.mock
}

// Set uses given function f to mock the IRepository.GetInfoByOrderIDMaster method
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Set(f func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)) *IRepositoryMock {
	if mmGetInfoByOrderIDMaster.defaultExpectation != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("Default expectation is already set for the IRepository.GetInfoByOrderIDMaster method")
	}

	if len(mmGetInfoByOrderIDMaster.expectations) > 0 {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("Some expectations are already set for the IRepository.GetInfoByOrderIDMaster method")
	}

	mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster = f
	mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMasterOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDMaster.mock
}

// When sets expectation for the IRepository.GetInfoByOrderIDMaster which will trigger the result defined by the following
// Then helper
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) When(ctx context.Context, orderID int64) *IRepositoryMockGetInfoByOrderIDMasterExpectation {
	if mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDMaster mock is already set by Set")
	}

	expectation := &IRepositoryMockGetInfoByOrderIDMasterExpectation{
		mock:               mmGetInfoByOrderIDMaster.mock,
		params:             &IRepositoryMockGetInfoByOrderIDMasterParams{ctx, orderID},
		expectationOrigins: IRepositoryMockGetInfoByOrderIDMasterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInfoByOrderIDMaster.expectations = append(mmGetInfoByOrderIDMaster.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetInfoByOrderIDMaster return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetInfoByOrderIDMasterExpectation) Then(op1 *model.OrderInfo, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetInfoByOrderIDMasterResults{op1, err}
	return e.mock
}

// Times sets number of times IRepository.GetInfoByOrderIDMaster should be invoked
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Times(n uint64) *mIRepositoryMockGetInfoByOrderIDMaster {
	if n == 0 {
		mmGetInfoByOrderIDMaster.mock.t.Fatalf("Times of IRepositoryMock.GetInfoByOrderIDMaster mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInfoByOrderIDMaster.expectedInvocations, n)
	mmGetInfoByOrderIDMaster.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDMaster
}

func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) invocationsDone() bool {
	if len(mmGetInfoByOrderIDMaster.expectations) == 0 && mmGetInfoByOrderIDMaster.defaultExpectation == nil && mmGetInfoByOrderIDMaster.mock.funcGetInfoByOrderIDMaster == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderIDMaster.mock.afterGetInfoByOrderIDMasterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderIDMaster.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInfoByOrderIDMaster implements mm_service.IRepository
func (mmGetInfoByOrderIDMaster *IRepositoryMock) GetInfoByOrderIDMaster(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmGetInfoByOrderIDMaster.beforeGetInfoByOrderIDMasterCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInfoByOrderIDMaster.afterGetInfoByOrderIDMasterCounter, 1)

	mmGetInfoByOrderIDMaster.t.Helper()

	if mmGetInfoByOrderIDMaster.inspectFuncGetInfoByOrderIDMaster != nil {
		mmGetInfoByOrderIDMaster.inspectFuncGetInfoByOrderIDMaster(ctx, orderID)
	}

	mm_params := IRepositoryMockGetInfoByOrderIDMasterParams{ctx, orderID}

	// Record call args
	mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.mutex.Lock()
	mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.callArgs = append(mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.callArgs, &mm_params)
	mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.mutex.Unlock()

	for _, e := range mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.params
		mm_want_ptrs := mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetInfoByOrderIDMasterParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInfoByOrderIDMaster.t.Errorf("IRepositoryMock.GetInfoByOrderIDMaster got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetInfoByOrderIDMaster.t.Errorf("IRepositoryMock.GetInfoByOrderIDMaster got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInfoByOrderIDMaster.t.Errorf("IRepositoryMock.GetInfoByOrderIDMaster got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInfoByOrderIDMaster.GetInfoByOrderIDMasterMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInfoByOrderIDMaster.t.Fatal("No results are set for the IRepositoryMock.GetInfoByOrderIDMaster")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetInfoByOrderIDMaster.funcGetInfoByOrderIDMaster != nil {
		return mmGetInfoByOrderIDMaster.funcGetInfoByOrderIDMaster(ctx, orderID)
	}
	mmGetInfoByOrderIDMaster.t.Fatalf("Unexpected call to IRepositoryMock.GetInfoByOrderIDMaster. %v %v", ctx, orderID)
	return
}

// GetInfoByOrderIDMasterAfterCounter returns a count of finished IRepositoryMock.GetInfoByOrderIDMaster invocations
func (mmGetInfoByOrderIDMaster *IRepositoryMock) GetInfoByOrderIDMasterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderIDMaster.afterGetInfoByOrderIDMasterCounter)
}

// GetInfoByOrderIDMasterBeforeCounter returns a count of IRepositoryMock.GetInfoByOrderIDMaster invocations
func (mmGetInfoByOrderIDMaster *IRepositoryMock) GetInfoByOrderIDMasterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderIDMaster.beforeGetInfoByOrderIDMasterCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetInfoByOrderIDMaster.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInfoByOrderIDMaster *mIRepositoryMockGetInfoByOrderIDMaster) Calls() []*IRepositoryMockGetInfoByOrderIDMasterParams {
	mmGetInfoByOrderIDMaster.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetInfoByOrderIDMasterParams, len(mmGetInfoByOrderIDMaster.callArgs))
	copy(argCopy, mmGetInfoByOrderIDMaster.callArgs)

	mmGetInfoByOrderIDMaster.mutex.RUnlock()

	return argCopy
}

// MinimockGetInfoByOrderIDMasterDone returns true if the count of the GetInfoByOrderIDMaster invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetInfoByOrderIDMasterDone() bool {
	if m.GetInfoByOrderIDMasterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInfoByOrderIDMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInfoByOrderIDMasterMock.invocationsDone()
}

// MinimockGetInfoByOrderIDMasterInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetInfoByOrderIDMasterInspect() {
	for _, e := range m.GetInfoByOrderIDMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDMaster at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInfoByOrderIDMasterCounter := mm_atomic.LoadUint64(&m.afterGetInfoByOrderIDMasterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInfoByOrderIDMasterMock.defaultExpectation != nil && afterGetInfoByOrderIDMasterCounter < 1 {
		if m.GetInfoByOrderIDMasterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDMaster at\n%s", m.GetInfoByOrderIDMasterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDMaster at\n%s with params: %#v", m.GetInfoByOrderIDMasterMock.defaultExpectation.expectationOrigins.origin, *m.GetInfoByOrderIDMasterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInfoByOrderIDMaster != nil && afterGetInfoByOrderIDMasterCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDMaster at\n%s", m.funcGetInfoByOrderIDMasterOrigin)
	}

	if !m.GetInfoByOrderIDMasterMock.invocationsDone() && afterGetInfoByOrderIDMasterCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetInfoByOrderIDMaster at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInfoByOrderIDMasterMock.expectedInvocations), m.GetInfoByOrderIDMasterMock.expectedInvocationsOrigin, afterGetInfoByOrderIDMasterCounter)
	}
}

type mIRepositoryMockGetInfoByOrderIDReplica struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetInfoByOrderIDReplicaExpectation
	expectations       []*IRepositoryMockGetInfoByOrderIDReplicaExpectation

	callArgs []*IRepositoryMockGetInfoByOrderIDReplicaParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetInfoByOrderIDReplicaExpectation specifies expectation struct of the IRepository.GetInfoByOrderIDReplica
type IRepositoryMockGetInfoByOrderIDReplicaExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetInfoByOrderIDReplicaParams
	paramPtrs          *IRepositoryMockGetInfoByOrderIDReplicaParamPtrs
	expectationOrigins IRepositoryMockGetInfoByOrderIDReplicaExpectationOrigins
	results            *IRepositoryMockGetInfoByOrderIDReplicaResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetInfoByOrderIDReplicaParams contains parameters of the IRepository.GetInfoByOrderIDReplica
type IRepositoryMockGetInfoByOrderIDReplicaParams struct {
	ctx     context.Context
	orderID int64
}

// IRepositoryMockGetInfoByOrderIDReplicaParamPtrs contains pointers to parameters of the IRepository.GetInfoByOrderIDReplica
type IRepositoryMockGetInfoByOrderIDReplicaParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// IRepositoryMockGetInfoByOrderIDReplicaResults contains results of the IRepository.GetInfoByOrderIDReplica
type IRepositoryMockGetInfoByOrderIDReplicaResults struct {
	op1 *model.OrderInfo
	err error
}

// IRepositoryMockGetInfoByOrderIDReplicaOrigins contains origins of expectations of the IRepository.GetInfoByOrderIDReplica
type IRepositoryMockGetInfoByOrderIDReplicaExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Optional() *mIRepositoryMockGetInfoByOrderIDReplica {
	mmGetInfoByOrderIDReplica.optional = true
	return mmGetInfoByOrderIDReplica
}

// Expect sets up expected params for IRepository.GetInfoByOrderIDReplica
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Expect(ctx context.Context, orderID int64) *mIRepositoryMockGetInfoByOrderIDReplica {
	if mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Set")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation = &IRepositoryMockGetInfoByOrderIDReplicaExpectation{}
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by ExpectParams functions")
	}

	mmGetInfoByOrderIDReplica.defaultExpectation.params = &IRepositoryMockGetInfoByOrderIDReplicaParams{ctx, orderID}
	mmGetInfoByOrderIDReplica.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInfoByOrderIDReplica.expectations {
		if minimock.Equal(e.params, mmGetInfoByOrderIDReplica.defaultExpectation.params) {
			mmGetInfoByOrderIDReplica.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInfoByOrderIDReplica.defaultExpectation.params)
		}
	}

	return mmGetInfoByOrderIDReplica
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetInfoByOrderIDReplica
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetInfoByOrderIDReplica {
	if mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Set")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation = &IRepositoryMockGetInfoByOrderIDReplicaExpectation{}
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation.params != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Expect")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs = &IRepositoryMockGetInfoByOrderIDReplicaParamPtrs{}
	}
	mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInfoByOrderIDReplica.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInfoByOrderIDReplica
}

// ExpectOrderIDParam2 sets up expected param orderID for IRepository.GetInfoByOrderIDReplica
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) ExpectOrderIDParam2(orderID int64) *mIRepositoryMockGetInfoByOrderIDReplica {
	if mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Set")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation = &IRepositoryMockGetInfoByOrderIDReplicaExpectation{}
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation.params != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Expect")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs = &IRepositoryMockGetInfoByOrderIDReplicaParamPtrs{}
	}
	mmGetInfoByOrderIDReplica.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetInfoByOrderIDReplica.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetInfoByOrderIDReplica
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetInfoByOrderIDReplica
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Inspect(f func(ctx context.Context, orderID int64)) *mIRepositoryMockGetInfoByOrderIDReplica {
	if mmGetInfoByOrderIDReplica.mock.inspectFuncGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetInfoByOrderIDReplica")
	}

	mmGetInfoByOrderIDReplica.mock.inspectFuncGetInfoByOrderIDReplica = f

	return mmGetInfoByOrderIDReplica
}

// Return sets up results that will be returned by IRepository.GetInfoByOrderIDReplica
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Return(op1 *model.OrderInfo, err error) *IRepositoryMock {
	if mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Set")
	}

	if mmGetInfoByOrderIDReplica.defaultExpectation == nil {
		mmGetInfoByOrderIDReplica.defaultExpectation = &IRepositoryMockGetInfoByOrderIDReplicaExpectation{mock: mmGetInfoByOrderIDReplica.mock}
	}
	mmGetInfoByOrderIDReplica.defaultExpectation.results = &IRepositoryMockGetInfoByOrderIDReplicaResults{op1, err}
	mmGetInfoByOrderIDReplica.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDReplica.mock
}

// Set uses given function f to mock the IRepository.GetInfoByOrderIDReplica method
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Set(f func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)) *IRepositoryMock {
	if mmGetInfoByOrderIDReplica.defaultExpectation != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("Default expectation is already set for the IRepository.GetInfoByOrderIDReplica method")
	}

	if len(mmGetInfoByOrderIDReplica.expectations) > 0 {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("Some expectations are already set for the IRepository.GetInfoByOrderIDReplica method")
	}

	mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica = f
	mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplicaOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDReplica.mock
}

// When sets expectation for the IRepository.GetInfoByOrderIDReplica which will trigger the result defined by the following
// Then helper
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) When(ctx context.Context, orderID int64) *IRepositoryMockGetInfoByOrderIDReplicaExpectation {
	if mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("IRepositoryMock.GetInfoByOrderIDReplica mock is already set by Set")
	}

	expectation := &IRepositoryMockGetInfoByOrderIDReplicaExpectation{
		mock:               mmGetInfoByOrderIDReplica.mock,
		params:             &IRepositoryMockGetInfoByOrderIDReplicaParams{ctx, orderID},
		expectationOrigins: IRepositoryMockGetInfoByOrderIDReplicaExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInfoByOrderIDReplica.expectations = append(mmGetInfoByOrderIDReplica.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetInfoByOrderIDReplica return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetInfoByOrderIDReplicaExpectation) Then(op1 *model.OrderInfo, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetInfoByOrderIDReplicaResults{op1, err}
	return e.mock
}

// Times sets number of times IRepository.GetInfoByOrderIDReplica should be invoked
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Times(n uint64) *mIRepositoryMockGetInfoByOrderIDReplica {
	if n == 0 {
		mmGetInfoByOrderIDReplica.mock.t.Fatalf("Times of IRepositoryMock.GetInfoByOrderIDReplica mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInfoByOrderIDReplica.expectedInvocations, n)
	mmGetInfoByOrderIDReplica.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInfoByOrderIDReplica
}

func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) invocationsDone() bool {
	if len(mmGetInfoByOrderIDReplica.expectations) == 0 && mmGetInfoByOrderIDReplica.defaultExpectation == nil && mmGetInfoByOrderIDReplica.mock.funcGetInfoByOrderIDReplica == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderIDReplica.mock.afterGetInfoByOrderIDReplicaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInfoByOrderIDReplica.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInfoByOrderIDReplica implements mm_service.IRepository
func (mmGetInfoByOrderIDReplica *IRepositoryMock) GetInfoByOrderIDReplica(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmGetInfoByOrderIDReplica.beforeGetInfoByOrderIDReplicaCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInfoByOrderIDReplica.afterGetInfoByOrderIDReplicaCounter, 1)

	mmGetInfoByOrderIDReplica.t.Helper()

	if mmGetInfoByOrderIDReplica.inspectFuncGetInfoByOrderIDReplica != nil {
		mmGetInfoByOrderIDReplica.inspectFuncGetInfoByOrderIDReplica(ctx, orderID)
	}

	mm_params := IRepositoryMockGetInfoByOrderIDReplicaParams{ctx, orderID}

	// Record call args
	mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.mutex.Lock()
	mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.callArgs = append(mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.callArgs, &mm_params)
	mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.mutex.Unlock()

	for _, e := range mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.params
		mm_want_ptrs := mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetInfoByOrderIDReplicaParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInfoByOrderIDReplica.t.Errorf("IRepositoryMock.GetInfoByOrderIDReplica got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetInfoByOrderIDReplica.t.Errorf("IRepositoryMock.GetInfoByOrderIDReplica got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInfoByOrderIDReplica.t.Errorf("IRepositoryMock.GetInfoByOrderIDReplica got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInfoByOrderIDReplica.GetInfoByOrderIDReplicaMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInfoByOrderIDReplica.t.Fatal("No results are set for the IRepositoryMock.GetInfoByOrderIDReplica")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetInfoByOrderIDReplica.funcGetInfoByOrderIDReplica != nil {
		return mmGetInfoByOrderIDReplica.funcGetInfoByOrderIDReplica(ctx, orderID)
	}
	mmGetInfoByOrderIDReplica.t.Fatalf("Unexpected call to IRepositoryMock.GetInfoByOrderIDReplica. %v %v", ctx, orderID)
	return
}

// GetInfoByOrderIDReplicaAfterCounter returns a count of finished IRepositoryMock.GetInfoByOrderIDReplica invocations
func (mmGetInfoByOrderIDReplica *IRepositoryMock) GetInfoByOrderIDReplicaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderIDReplica.afterGetInfoByOrderIDReplicaCounter)
}

// GetInfoByOrderIDReplicaBeforeCounter returns a count of IRepositoryMock.GetInfoByOrderIDReplica invocations
func (mmGetInfoByOrderIDReplica *IRepositoryMock) GetInfoByOrderIDReplicaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInfoByOrderIDReplica.beforeGetInfoByOrderIDReplicaCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetInfoByOrderIDReplica.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInfoByOrderIDReplica *mIRepositoryMockGetInfoByOrderIDReplica) Calls() []*IRepositoryMockGetInfoByOrderIDReplicaParams {
	mmGetInfoByOrderIDReplica.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetInfoByOrderIDReplicaParams, len(mmGetInfoByOrderIDReplica.callArgs))
	copy(argCopy, mmGetInfoByOrderIDReplica.callArgs)

	mmGetInfoByOrderIDReplica.mutex.RUnlock()

	return argCopy
}

// MinimockGetInfoByOrderIDReplicaDone returns true if the count of the GetInfoByOrderIDReplica invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetInfoByOrderIDReplicaDone() bool {
	if m.GetInfoByOrderIDReplicaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInfoByOrderIDReplicaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInfoByOrderIDReplicaMock.invocationsDone()
}

// MinimockGetInfoByOrderIDReplicaInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetInfoByOrderIDReplicaInspect() {
	for _, e := range m.GetInfoByOrderIDReplicaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDReplica at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInfoByOrderIDReplicaCounter := mm_atomic.LoadUint64(&m.afterGetInfoByOrderIDReplicaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInfoByOrderIDReplicaMock.defaultExpectation != nil && afterGetInfoByOrderIDReplicaCounter < 1 {
		if m.GetInfoByOrderIDReplicaMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDReplica at\n%s", m.GetInfoByOrderIDReplicaMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDReplica at\n%s with params: %#v", m.GetInfoByOrderIDReplicaMock.defaultExpectation.expectationOrigins.origin, *m.GetInfoByOrderIDReplicaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInfoByOrderIDReplica != nil && afterGetInfoByOrderIDReplicaCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetInfoByOrderIDReplica at\n%s", m.funcGetInfoByOrderIDReplicaOrigin)
	}

	if !m.GetInfoByOrderIDReplicaMock.invocationsDone() && afterGetInfoByOrderIDReplicaCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetInfoByOrderIDReplica at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInfoByOrderIDReplicaMock.expectedInvocations), m.GetInfoByOrderIDReplicaMock.expectedInvocationsOrigin, afterGetInfoByOrderIDReplicaCounter)
	}
}

type mIRepositoryMockGetNewMsgOutbox struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetNewMsgOutboxExpectation
	expectations       []*IRepositoryMockGetNewMsgOutboxExpectation

	callArgs []*IRepositoryMockGetNewMsgOutboxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetNewMsgOutboxExpectation specifies expectation struct of the IRepository.GetNewMsgOutbox
type IRepositoryMockGetNewMsgOutboxExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetNewMsgOutboxParams
	paramPtrs          *IRepositoryMockGetNewMsgOutboxParamPtrs
	expectationOrigins IRepositoryMockGetNewMsgOutboxExpectationOrigins
	results            *IRepositoryMockGetNewMsgOutboxResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetNewMsgOutboxParams contains parameters of the IRepository.GetNewMsgOutbox
type IRepositoryMockGetNewMsgOutboxParams struct {
	ctx context.Context
}

// IRepositoryMockGetNewMsgOutboxParamPtrs contains pointers to parameters of the IRepository.GetNewMsgOutbox
type IRepositoryMockGetNewMsgOutboxParamPtrs struct {
	ctx *context.Context
}

// IRepositoryMockGetNewMsgOutboxResults contains results of the IRepository.GetNewMsgOutbox
type IRepositoryMockGetNewMsgOutboxResults struct {
	gpa1 []*repository_sqlc.GetNewMsgOutboxRow
	err  error
}

// IRepositoryMockGetNewMsgOutboxOrigins contains origins of expectations of the IRepository.GetNewMsgOutbox
type IRepositoryMockGetNewMsgOutboxExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Optional() *mIRepositoryMockGetNewMsgOutbox {
	mmGetNewMsgOutbox.optional = true
	return mmGetNewMsgOutbox
}

// Expect sets up expected params for IRepository.GetNewMsgOutbox
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Expect(ctx context.Context) *mIRepositoryMockGetNewMsgOutbox {
	if mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by Set")
	}

	if mmGetNewMsgOutbox.defaultExpectation == nil {
		mmGetNewMsgOutbox.defaultExpectation = &IRepositoryMockGetNewMsgOutboxExpectation{}
	}

	if mmGetNewMsgOutbox.defaultExpectation.paramPtrs != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by ExpectParams functions")
	}

	mmGetNewMsgOutbox.defaultExpectation.params = &IRepositoryMockGetNewMsgOutboxParams{ctx}
	mmGetNewMsgOutbox.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNewMsgOutbox.expectations {
		if minimock.Equal(e.params, mmGetNewMsgOutbox.defaultExpectation.params) {
			mmGetNewMsgOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNewMsgOutbox.defaultExpectation.params)
		}
	}

	return mmGetNewMsgOutbox
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetNewMsgOutbox
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetNewMsgOutbox {
	if mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by Set")
	}

	if mmGetNewMsgOutbox.defaultExpectation == nil {
		mmGetNewMsgOutbox.defaultExpectation = &IRepositoryMockGetNewMsgOutboxExpectation{}
	}

	if mmGetNewMsgOutbox.defaultExpectation.params != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by Expect")
	}

	if mmGetNewMsgOutbox.defaultExpectation.paramPtrs == nil {
		mmGetNewMsgOutbox.defaultExpectation.paramPtrs = &IRepositoryMockGetNewMsgOutboxParamPtrs{}
	}
	mmGetNewMsgOutbox.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNewMsgOutbox.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNewMsgOutbox
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetNewMsgOutbox
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Inspect(f func(ctx context.Context)) *mIRepositoryMockGetNewMsgOutbox {
	if mmGetNewMsgOutbox.mock.inspectFuncGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetNewMsgOutbox")
	}

	mmGetNewMsgOutbox.mock.inspectFuncGetNewMsgOutbox = f

	return mmGetNewMsgOutbox
}

// Return sets up results that will be returned by IRepository.GetNewMsgOutbox
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Return(gpa1 []*repository_sqlc.GetNewMsgOutboxRow, err error) *IRepositoryMock {
	if mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by Set")
	}

	if mmGetNewMsgOutbox.defaultExpectation == nil {
		mmGetNewMsgOutbox.defaultExpectation = &IRepositoryMockGetNewMsgOutboxExpectation{mock: mmGetNewMsgOutbox.mock}
	}
	mmGetNewMsgOutbox.defaultExpectation.results = &IRepositoryMockGetNewMsgOutboxResults{gpa1, err}
	mmGetNewMsgOutbox.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNewMsgOutbox.mock
}

// Set uses given function f to mock the IRepository.GetNewMsgOutbox method
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Set(f func(ctx context.Context) (gpa1 []*repository_sqlc.GetNewMsgOutboxRow, err error)) *IRepositoryMock {
	if mmGetNewMsgOutbox.defaultExpectation != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("Default expectation is already set for the IRepository.GetNewMsgOutbox method")
	}

	if len(mmGetNewMsgOutbox.expectations) > 0 {
		mmGetNewMsgOutbox.mock.t.Fatalf("Some expectations are already set for the IRepository.GetNewMsgOutbox method")
	}

	mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox = f
	mmGetNewMsgOutbox.mock.funcGetNewMsgOutboxOrigin = minimock.CallerInfo(1)
	return mmGetNewMsgOutbox.mock
}

// When sets expectation for the IRepository.GetNewMsgOutbox which will trigger the result defined by the following
// Then helper
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) When(ctx context.Context) *IRepositoryMockGetNewMsgOutboxExpectation {
	if mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.mock.t.Fatalf("IRepositoryMock.GetNewMsgOutbox mock is already set by Set")
	}

	expectation := &IRepositoryMockGetNewMsgOutboxExpectation{
		mock:               mmGetNewMsgOutbox.mock,
		params:             &IRepositoryMockGetNewMsgOutboxParams{ctx},
		expectationOrigins: IRepositoryMockGetNewMsgOutboxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNewMsgOutbox.expectations = append(mmGetNewMsgOutbox.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetNewMsgOutbox return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetNewMsgOutboxExpectation) Then(gpa1 []*repository_sqlc.GetNewMsgOutboxRow, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetNewMsgOutboxResults{gpa1, err}
	return e.mock
}

// Times sets number of times IRepository.GetNewMsgOutbox should be invoked
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Times(n uint64) *mIRepositoryMockGetNewMsgOutbox {
	if n == 0 {
		mmGetNewMsgOutbox.mock.t.Fatalf("Times of IRepositoryMock.GetNewMsgOutbox mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNewMsgOutbox.expectedInvocations, n)
	mmGetNewMsgOutbox.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNewMsgOutbox
}

func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) invocationsDone() bool {
	if len(mmGetNewMsgOutbox.expectations) == 0 && mmGetNewMsgOutbox.defaultExpectation == nil && mmGetNewMsgOutbox.mock.funcGetNewMsgOutbox == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNewMsgOutbox.mock.afterGetNewMsgOutboxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNewMsgOutbox.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNewMsgOutbox implements mm_service.IRepository
func (mmGetNewMsgOutbox *IRepositoryMock) GetNewMsgOutbox(ctx context.Context) (gpa1 []*repository_sqlc.GetNewMsgOutboxRow, err error) {
	mm_atomic.AddUint64(&mmGetNewMsgOutbox.beforeGetNewMsgOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNewMsgOutbox.afterGetNewMsgOutboxCounter, 1)

	mmGetNewMsgOutbox.t.Helper()

	if mmGetNewMsgOutbox.inspectFuncGetNewMsgOutbox != nil {
		mmGetNewMsgOutbox.inspectFuncGetNewMsgOutbox(ctx)
	}

	mm_params := IRepositoryMockGetNewMsgOutboxParams{ctx}

	// Record call args
	mmGetNewMsgOutbox.GetNewMsgOutboxMock.mutex.Lock()
	mmGetNewMsgOutbox.GetNewMsgOutboxMock.callArgs = append(mmGetNewMsgOutbox.GetNewMsgOutboxMock.callArgs, &mm_params)
	mmGetNewMsgOutbox.GetNewMsgOutboxMock.mutex.Unlock()

	for _, e := range mmGetNewMsgOutbox.GetNewMsgOutboxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gpa1, e.results.err
		}
	}

	if mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.params
		mm_want_ptrs := mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetNewMsgOutboxParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNewMsgOutbox.t.Errorf("IRepositoryMock.GetNewMsgOutbox got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNewMsgOutbox.t.Errorf("IRepositoryMock.GetNewMsgOutbox got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNewMsgOutbox.GetNewMsgOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNewMsgOutbox.t.Fatal("No results are set for the IRepositoryMock.GetNewMsgOutbox")
		}
		return (*mm_results).gpa1, (*mm_results).err
	}
	if mmGetNewMsgOutbox.funcGetNewMsgOutbox != nil {
		return mmGetNewMsgOutbox.funcGetNewMsgOutbox(ctx)
	}
	mmGetNewMsgOutbox.t.Fatalf("Unexpected call to IRepositoryMock.GetNewMsgOutbox. %v", ctx)
	return
}

// GetNewMsgOutboxAfterCounter returns a count of finished IRepositoryMock.GetNewMsgOutbox invocations
func (mmGetNewMsgOutbox *IRepositoryMock) GetNewMsgOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNewMsgOutbox.afterGetNewMsgOutboxCounter)
}

// GetNewMsgOutboxBeforeCounter returns a count of IRepositoryMock.GetNewMsgOutbox invocations
func (mmGetNewMsgOutbox *IRepositoryMock) GetNewMsgOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNewMsgOutbox.beforeGetNewMsgOutboxCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetNewMsgOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNewMsgOutbox *mIRepositoryMockGetNewMsgOutbox) Calls() []*IRepositoryMockGetNewMsgOutboxParams {
	mmGetNewMsgOutbox.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetNewMsgOutboxParams, len(mmGetNewMsgOutbox.callArgs))
	copy(argCopy, mmGetNewMsgOutbox.callArgs)

	mmGetNewMsgOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockGetNewMsgOutboxDone returns true if the count of the GetNewMsgOutbox invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetNewMsgOutboxDone() bool {
	if m.GetNewMsgOutboxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNewMsgOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNewMsgOutboxMock.invocationsDone()
}

// MinimockGetNewMsgOutboxInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetNewMsgOutboxInspect() {
	for _, e := range m.GetNewMsgOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetNewMsgOutbox at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNewMsgOutboxCounter := mm_atomic.LoadUint64(&m.afterGetNewMsgOutboxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNewMsgOutboxMock.defaultExpectation != nil && afterGetNewMsgOutboxCounter < 1 {
		if m.GetNewMsgOutboxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetNewMsgOutbox at\n%s", m.GetNewMsgOutboxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetNewMsgOutbox at\n%s with params: %#v", m.GetNewMsgOutboxMock.defaultExpectation.expectationOrigins.origin, *m.GetNewMsgOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNewMsgOutbox != nil && afterGetNewMsgOutboxCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetNewMsgOutbox at\n%s", m.funcGetNewMsgOutboxOrigin)
	}

	if !m.GetNewMsgOutboxMock.invocationsDone() && afterGetNewMsgOutboxCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetNewMsgOutbox at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNewMsgOutboxMock.expectedInvocations), m.GetNewMsgOutboxMock.expectedInvocationsOrigin, afterGetNewMsgOutboxCounter)
	}
}

type mIRepositoryMockReserve struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockReserveExpectation
	expectations       []*IRepositoryMockReserveExpectation

	callArgs []*IRepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockReserveExpectation specifies expectation struct of the IRepository.Reserve
type IRepositoryMockReserveExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockReserveParams
	paramPtrs          *IRepositoryMockReserveParamPtrs
	expectationOrigins IRepositoryMockReserveExpectationOrigins
	results            *IRepositoryMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockReserveParams contains parameters of the IRepository.Reserve
type IRepositoryMockReserveParams struct {
	ctx   context.Context
	items []model.Item
}

// IRepositoryMockReserveParamPtrs contains pointers to parameters of the IRepository.Reserve
type IRepositoryMockReserveParamPtrs struct {
	ctx   *context.Context
	items *[]model.Item
}

// IRepositoryMockReserveResults contains results of the IRepository.Reserve
type IRepositoryMockReserveResults struct {
	err error
}

// IRepositoryMockReserveOrigins contains origins of expectations of the IRepository.Reserve
type IRepositoryMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mIRepositoryMockReserve) Optional() *mIRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for IRepository.Reserve
func (mmReserve *mIRepositoryMockReserve) Expect(ctx context.Context, items []model.Item) *mIRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &IRepositoryMockReserveParams{ctx, items}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.Reserve
func (mmReserve *mIRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &IRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectItemsParam2 sets up expected param items for IRepository.Reserve
func (mmReserve *mIRepositoryMockReserve) ExpectItemsParam2(items []model.Item) *mIRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &IRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.items = &items
	mmReserve.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Reserve
func (mmReserve *mIRepositoryMockReserve) Inspect(f func(ctx context.Context, items []model.Item)) *mIRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by IRepository.Reserve
func (mmReserve *mIRepositoryMockReserve) Return(err error) *IRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &IRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &IRepositoryMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the IRepository.Reserve method
func (mmReserve *mIRepositoryMockReserve) Set(f func(ctx context.Context, items []model.Item) (err error)) *IRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the IRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the IRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the IRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mIRepositoryMockReserve) When(ctx context.Context, items []model.Item) *IRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("IRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &IRepositoryMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &IRepositoryMockReserveParams{ctx, items},
		expectationOrigins: IRepositoryMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up IRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockReserveExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockReserveResults{err}
	return e.mock
}

// Times sets number of times IRepository.Reserve should be invoked
func (mmReserve *mIRepositoryMockReserve) Times(n uint64) *mIRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of IRepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mIRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_service.IRepository
func (mmReserve *IRepositoryMock) Reserve(ctx context.Context, items []model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := IRepositoryMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("IRepositoryMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserve.t.Errorf("IRepositoryMock.Reserve got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("IRepositoryMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the IRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to IRepositoryMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished IRepositoryMock.Reserve invocations
func (mmReserve *IRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of IRepositoryMock.Reserve invocations
func (mmReserve *IRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mIRepositoryMockReserve) Calls() []*IRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*IRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mIRepositoryMockReserveCancel struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockReserveCancelExpectation
	expectations       []*IRepositoryMockReserveCancelExpectation

	callArgs []*IRepositoryMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockReserveCancelExpectation specifies expectation struct of the IRepository.ReserveCancel
type IRepositoryMockReserveCancelExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockReserveCancelParams
	paramPtrs          *IRepositoryMockReserveCancelParamPtrs
	expectationOrigins IRepositoryMockReserveCancelExpectationOrigins
	results            *IRepositoryMockReserveCancelResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockReserveCancelParams contains parameters of the IRepository.ReserveCancel
type IRepositoryMockReserveCancelParams struct {
	ctx  context.Context
	item model.Item
}

// IRepositoryMockReserveCancelParamPtrs contains pointers to parameters of the IRepository.ReserveCancel
type IRepositoryMockReserveCancelParamPtrs struct {
	ctx  *context.Context
	item *model.Item
}

// IRepositoryMockReserveCancelResults contains results of the IRepository.ReserveCancel
type IRepositoryMockReserveCancelResults struct {
	err error
}

// IRepositoryMockReserveCancelOrigins contains origins of expectations of the IRepository.ReserveCancel
type IRepositoryMockReserveCancelExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mIRepositoryMockReserveCancel) Optional() *mIRepositoryMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for IRepository.ReserveCancel
func (mmReserveCancel *mIRepositoryMockReserveCancel) Expect(ctx context.Context, item model.Item) *mIRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &IRepositoryMockReserveCancelParams{ctx, item}
	mmReserveCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.ReserveCancel
func (mmReserveCancel *mIRepositoryMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &IRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectItemParam2 sets up expected param item for IRepository.ReserveCancel
func (mmReserveCancel *mIRepositoryMockReserveCancel) ExpectItemParam2(item model.Item) *mIRepositoryMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IRepositoryMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &IRepositoryMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.item = &item
	mmReserveCancel.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the IRepository.ReserveCancel
func (mmReserveCancel *mIRepositoryMockReserveCancel) Inspect(f func(ctx context.Context, item model.Item)) *mIRepositoryMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by IRepository.ReserveCancel
func (mmReserveCancel *mIRepositoryMockReserveCancel) Return(err error) *IRepositoryMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &IRepositoryMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &IRepositoryMockReserveCancelResults{err}
	mmReserveCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// Set uses given function f to mock the IRepository.ReserveCancel method
func (mmReserveCancel *mIRepositoryMockReserveCancel) Set(f func(ctx context.Context, item model.Item) (err error)) *IRepositoryMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the IRepository.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the IRepository.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	mmReserveCancel.mock.funcReserveCancelOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// When sets expectation for the IRepository.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mIRepositoryMockReserveCancel) When(ctx context.Context, item model.Item) *IRepositoryMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("IRepositoryMock.ReserveCancel mock is already set by Set")
	}

	expectation := &IRepositoryMockReserveCancelExpectation{
		mock:               mmReserveCancel.mock,
		params:             &IRepositoryMockReserveCancelParams{ctx, item},
		expectationOrigins: IRepositoryMockReserveCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up IRepository.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockReserveCancelExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times IRepository.ReserveCancel should be invoked
func (mmReserveCancel *mIRepositoryMockReserveCancel) Times(n uint64) *mIRepositoryMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of IRepositoryMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	mmReserveCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancel
}

func (mmReserveCancel *mIRepositoryMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements mm_service.IRepository
func (mmReserveCancel *IRepositoryMock) ReserveCancel(ctx context.Context, item model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	mmReserveCancel.t.Helper()

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, item)
	}

	mm_params := IRepositoryMockReserveCancelParams{ctx, item}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockReserveCancelParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("IRepositoryMock.ReserveCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmReserveCancel.t.Errorf("IRepositoryMock.ReserveCancel got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("IRepositoryMock.ReserveCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the IRepositoryMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, item)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to IRepositoryMock.ReserveCancel. %v %v", ctx, item)
	return
}

// ReserveCancelAfterCounter returns a count of finished IRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *IRepositoryMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of IRepositoryMock.ReserveCancel invocations
func (mmReserveCancel *IRepositoryMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mIRepositoryMockReserveCancel) Calls() []*IRepositoryMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*IRepositoryMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveCancel at\n%s", m.ReserveCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveCancel at\n%s with params: %#v", m.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.ReserveCancel at\n%s", m.funcReserveCancelOrigin)
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.ReserveCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), m.ReserveCancelMock.expectedInvocationsOrigin, afterReserveCancelCounter)
	}
}

type mIRepositoryMockReserveRemove struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockReserveRemoveExpectation
	expectations       []*IRepositoryMockReserveRemoveExpectation

	callArgs []*IRepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockReserveRemoveExpectation specifies expectation struct of the IRepository.ReserveRemove
type IRepositoryMockReserveRemoveExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockReserveRemoveParams
	paramPtrs          *IRepositoryMockReserveRemoveParamPtrs
	expectationOrigins IRepositoryMockReserveRemoveExpectationOrigins
	results            *IRepositoryMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockReserveRemoveParams contains parameters of the IRepository.ReserveRemove
type IRepositoryMockReserveRemoveParams struct {
	ctx  context.Context
	item model.Item
}

// IRepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the IRepository.ReserveRemove
type IRepositoryMockReserveRemoveParamPtrs struct {
	ctx  *context.Context
	item *model.Item
}

// IRepositoryMockReserveRemoveResults contains results of the IRepository.ReserveRemove
type IRepositoryMockReserveRemoveResults struct {
	err error
}

// IRepositoryMockReserveRemoveOrigins contains origins of expectations of the IRepository.ReserveRemove
type IRepositoryMockReserveRemoveExpectationOrigins struct {
	origin     string
	originCtx  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mIRepositoryMockReserveRemove) Optional() *mIRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for IRepository.ReserveRemove
func (mmReserveRemove *mIRepositoryMockReserveRemove) Expect(ctx context.Context, item model.Item) *mIRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &IRepositoryMockReserveRemoveParams{ctx, item}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.ReserveRemove
func (mmReserveRemove *mIRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &IRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectItemParam2 sets up expected param item for IRepository.ReserveRemove
func (mmReserveRemove *mIRepositoryMockReserveRemove) ExpectItemParam2(item model.Item) *mIRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &IRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.item = &item
	mmReserveRemove.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the IRepository.ReserveRemove
func (mmReserveRemove *mIRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, item model.Item)) *mIRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by IRepository.ReserveRemove
func (mmReserveRemove *mIRepositoryMockReserveRemove) Return(err error) *IRepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &IRepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &IRepositoryMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the IRepository.ReserveRemove method
func (mmReserveRemove *mIRepositoryMockReserveRemove) Set(f func(ctx context.Context, item model.Item) (err error)) *IRepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the IRepository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the IRepository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the IRepository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mIRepositoryMockReserveRemove) When(ctx context.Context, item model.Item) *IRepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("IRepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &IRepositoryMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &IRepositoryMockReserveRemoveParams{ctx, item},
		expectationOrigins: IRepositoryMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up IRepository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockReserveRemoveExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times IRepository.ReserveRemove should be invoked
func (mmReserveRemove *mIRepositoryMockReserveRemove) Times(n uint64) *mIRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of IRepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mIRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_service.IRepository
func (mmReserveRemove *IRepositoryMock) ReserveRemove(ctx context.Context, item model.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, item)
	}

	mm_params := IRepositoryMockReserveRemoveParams{ctx, item}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockReserveRemoveParams{ctx, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("IRepositoryMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmReserveRemove.t.Errorf("IRepositoryMock.ReserveRemove got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("IRepositoryMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the IRepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, item)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to IRepositoryMock.ReserveRemove. %v %v", ctx, item)
	return
}

// ReserveRemoveAfterCounter returns a count of finished IRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *IRepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of IRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *IRepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mIRepositoryMockReserveRemove) Calls() []*IRepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*IRepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

type mIRepositoryMockSetStatusOrder struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockSetStatusOrderExpectation
	expectations       []*IRepositoryMockSetStatusOrderExpectation

	callArgs []*IRepositoryMockSetStatusOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockSetStatusOrderExpectation specifies expectation struct of the IRepository.SetStatusOrder
type IRepositoryMockSetStatusOrderExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockSetStatusOrderParams
	paramPtrs          *IRepositoryMockSetStatusOrderParamPtrs
	expectationOrigins IRepositoryMockSetStatusOrderExpectationOrigins
	results            *IRepositoryMockSetStatusOrderResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockSetStatusOrderParams contains parameters of the IRepository.SetStatusOrder
type IRepositoryMockSetStatusOrderParams struct {
	ctx     context.Context
	orderID int64
	status  string
}

// IRepositoryMockSetStatusOrderParamPtrs contains pointers to parameters of the IRepository.SetStatusOrder
type IRepositoryMockSetStatusOrderParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *string
}

// IRepositoryMockSetStatusOrderResults contains results of the IRepository.SetStatusOrder
type IRepositoryMockSetStatusOrderResults struct {
	err error
}

// IRepositoryMockSetStatusOrderOrigins contains origins of expectations of the IRepository.SetStatusOrder
type IRepositoryMockSetStatusOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Optional() *mIRepositoryMockSetStatusOrder {
	mmSetStatusOrder.optional = true
	return mmSetStatusOrder
}

// Expect sets up expected params for IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Expect(ctx context.Context, orderID int64, status string) *mIRepositoryMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IRepositoryMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by ExpectParams functions")
	}

	mmSetStatusOrder.defaultExpectation.params = &IRepositoryMockSetStatusOrderParams{ctx, orderID, status}
	mmSetStatusOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatusOrder.expectations {
		if minimock.Equal(e.params, mmSetStatusOrder.defaultExpectation.params) {
			mmSetStatusOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatusOrder.defaultExpectation.params)
		}
	}

	return mmSetStatusOrder
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IRepositoryMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IRepositoryMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) ExpectOrderIDParam2(orderID int64) *mIRepositoryMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IRepositoryMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IRepositoryMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// ExpectStatusParam3 sets up expected param status for IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) ExpectStatusParam3(status string) *mIRepositoryMockSetStatusOrder {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IRepositoryMockSetStatusOrderExpectation{}
	}

	if mmSetStatusOrder.defaultExpectation.params != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Expect")
	}

	if mmSetStatusOrder.defaultExpectation.paramPtrs == nil {
		mmSetStatusOrder.defaultExpectation.paramPtrs = &IRepositoryMockSetStatusOrderParamPtrs{}
	}
	mmSetStatusOrder.defaultExpectation.paramPtrs.status = &status
	mmSetStatusOrder.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatusOrder
}

// Inspect accepts an inspector function that has same arguments as the IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Inspect(f func(ctx context.Context, orderID int64, status string)) *mIRepositoryMockSetStatusOrder {
	if mmSetStatusOrder.mock.inspectFuncSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.SetStatusOrder")
	}

	mmSetStatusOrder.mock.inspectFuncSetStatusOrder = f

	return mmSetStatusOrder
}

// Return sets up results that will be returned by IRepository.SetStatusOrder
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Return(err error) *IRepositoryMock {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	if mmSetStatusOrder.defaultExpectation == nil {
		mmSetStatusOrder.defaultExpectation = &IRepositoryMockSetStatusOrderExpectation{mock: mmSetStatusOrder.mock}
	}
	mmSetStatusOrder.defaultExpectation.results = &IRepositoryMockSetStatusOrderResults{err}
	mmSetStatusOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder.mock
}

// Set uses given function f to mock the IRepository.SetStatusOrder method
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Set(f func(ctx context.Context, orderID int64, status string) (err error)) *IRepositoryMock {
	if mmSetStatusOrder.defaultExpectation != nil {
		mmSetStatusOrder.mock.t.Fatalf("Default expectation is already set for the IRepository.SetStatusOrder method")
	}

	if len(mmSetStatusOrder.expectations) > 0 {
		mmSetStatusOrder.mock.t.Fatalf("Some expectations are already set for the IRepository.SetStatusOrder method")
	}

	mmSetStatusOrder.mock.funcSetStatusOrder = f
	mmSetStatusOrder.mock.funcSetStatusOrderOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder.mock
}

// When sets expectation for the IRepository.SetStatusOrder which will trigger the result defined by the following
// Then helper
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) When(ctx context.Context, orderID int64, status string) *IRepositoryMockSetStatusOrderExpectation {
	if mmSetStatusOrder.mock.funcSetStatusOrder != nil {
		mmSetStatusOrder.mock.t.Fatalf("IRepositoryMock.SetStatusOrder mock is already set by Set")
	}

	expectation := &IRepositoryMockSetStatusOrderExpectation{
		mock:               mmSetStatusOrder.mock,
		params:             &IRepositoryMockSetStatusOrderParams{ctx, orderID, status},
		expectationOrigins: IRepositoryMockSetStatusOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatusOrder.expectations = append(mmSetStatusOrder.expectations, expectation)
	return expectation
}

// Then sets up IRepository.SetStatusOrder return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockSetStatusOrderExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockSetStatusOrderResults{err}
	return e.mock
}

// Times sets number of times IRepository.SetStatusOrder should be invoked
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Times(n uint64) *mIRepositoryMockSetStatusOrder {
	if n == 0 {
		mmSetStatusOrder.mock.t.Fatalf("Times of IRepositoryMock.SetStatusOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatusOrder.expectedInvocations, n)
	mmSetStatusOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatusOrder
}

func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) invocationsDone() bool {
	if len(mmSetStatusOrder.expectations) == 0 && mmSetStatusOrder.defaultExpectation == nil && mmSetStatusOrder.mock.funcSetStatusOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatusOrder.mock.afterSetStatusOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatusOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatusOrder implements mm_service.IRepository
func (mmSetStatusOrder *IRepositoryMock) SetStatusOrder(ctx context.Context, orderID int64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatusOrder.beforeSetStatusOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatusOrder.afterSetStatusOrderCounter, 1)

	mmSetStatusOrder.t.Helper()

	if mmSetStatusOrder.inspectFuncSetStatusOrder != nil {
		mmSetStatusOrder.inspectFuncSetStatusOrder(ctx, orderID, status)
	}

	mm_params := IRepositoryMockSetStatusOrderParams{ctx, orderID, status}

	// Record call args
	mmSetStatusOrder.SetStatusOrderMock.mutex.Lock()
	mmSetStatusOrder.SetStatusOrderMock.callArgs = append(mmSetStatusOrder.SetStatusOrderMock.callArgs, &mm_params)
	mmSetStatusOrder.SetStatusOrderMock.mutex.Unlock()

	for _, e := range mmSetStatusOrder.SetStatusOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatusOrder.SetStatusOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockSetStatusOrderParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatusOrder.t.Errorf("IRepositoryMock.SetStatusOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatusOrder.t.Errorf("IRepositoryMock.SetStatusOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatusOrder.t.Errorf("IRepositoryMock.SetStatusOrder got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatusOrder.t.Errorf("IRepositoryMock.SetStatusOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatusOrder.SetStatusOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatusOrder.t.Fatal("No results are set for the IRepositoryMock.SetStatusOrder")
		}
		return (*mm_results).err
	}
	if mmSetStatusOrder.funcSetStatusOrder != nil {
		return mmSetStatusOrder.funcSetStatusOrder(ctx, orderID, status)
	}
	mmSetStatusOrder.t.Fatalf("Unexpected call to IRepositoryMock.SetStatusOrder. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusOrderAfterCounter returns a count of finished IRepositoryMock.SetStatusOrder invocations
func (mmSetStatusOrder *IRepositoryMock) SetStatusOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusOrder.afterSetStatusOrderCounter)
}

// SetStatusOrderBeforeCounter returns a count of IRepositoryMock.SetStatusOrder invocations
func (mmSetStatusOrder *IRepositoryMock) SetStatusOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatusOrder.beforeSetStatusOrderCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.SetStatusOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatusOrder *mIRepositoryMockSetStatusOrder) Calls() []*IRepositoryMockSetStatusOrderParams {
	mmSetStatusOrder.mutex.RLock()

	argCopy := make([]*IRepositoryMockSetStatusOrderParams, len(mmSetStatusOrder.callArgs))
	copy(argCopy, mmSetStatusOrder.callArgs)

	mmSetStatusOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusOrderDone returns true if the count of the SetStatusOrder invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockSetStatusOrderDone() bool {
	if m.SetStatusOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusOrderMock.invocationsDone()
}

// MinimockSetStatusOrderInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockSetStatusOrderInspect() {
	for _, e := range m.SetStatusOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.SetStatusOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusOrderCounter := mm_atomic.LoadUint64(&m.afterSetStatusOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusOrderMock.defaultExpectation != nil && afterSetStatusOrderCounter < 1 {
		if m.SetStatusOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.SetStatusOrder at\n%s", m.SetStatusOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.SetStatusOrder at\n%s with params: %#v", m.SetStatusOrderMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatusOrder != nil && afterSetStatusOrderCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.SetStatusOrder at\n%s", m.funcSetStatusOrderOrigin)
	}

	if !m.SetStatusOrderMock.invocationsDone() && afterSetStatusOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.SetStatusOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusOrderMock.expectedInvocations), m.SetStatusOrderMock.expectedInvocationsOrigin, afterSetStatusOrderCounter)
	}
}

type mIRepositoryMockUpdateStatusMsgOutbox struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockUpdateStatusMsgOutboxExpectation
	expectations       []*IRepositoryMockUpdateStatusMsgOutboxExpectation

	callArgs []*IRepositoryMockUpdateStatusMsgOutboxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockUpdateStatusMsgOutboxExpectation specifies expectation struct of the IRepository.UpdateStatusMsgOutbox
type IRepositoryMockUpdateStatusMsgOutboxExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockUpdateStatusMsgOutboxParams
	paramPtrs          *IRepositoryMockUpdateStatusMsgOutboxParamPtrs
	expectationOrigins IRepositoryMockUpdateStatusMsgOutboxExpectationOrigins
	results            *IRepositoryMockUpdateStatusMsgOutboxResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockUpdateStatusMsgOutboxParams contains parameters of the IRepository.UpdateStatusMsgOutbox
type IRepositoryMockUpdateStatusMsgOutboxParams struct {
	ctx    context.Context
	id     int64
	status string
}

// IRepositoryMockUpdateStatusMsgOutboxParamPtrs contains pointers to parameters of the IRepository.UpdateStatusMsgOutbox
type IRepositoryMockUpdateStatusMsgOutboxParamPtrs struct {
	ctx    *context.Context
	id     *int64
	status *string
}

// IRepositoryMockUpdateStatusMsgOutboxResults contains results of the IRepository.UpdateStatusMsgOutbox
type IRepositoryMockUpdateStatusMsgOutboxResults struct {
	err error
}

// IRepositoryMockUpdateStatusMsgOutboxOrigins contains origins of expectations of the IRepository.UpdateStatusMsgOutbox
type IRepositoryMockUpdateStatusMsgOutboxExpectationOrigins struct {
	origin       string
	originCtx    string
	originId     string
	originStatus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Optional() *mIRepositoryMockUpdateStatusMsgOutbox {
	mmUpdateStatusMsgOutbox.optional = true
	return mmUpdateStatusMsgOutbox
}

// Expect sets up expected params for IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Expect(ctx context.Context, id int64, status string) *mIRepositoryMockUpdateStatusMsgOutbox {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation = &IRepositoryMockUpdateStatusMsgOutboxExpectation{}
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by ExpectParams functions")
	}

	mmUpdateStatusMsgOutbox.defaultExpectation.params = &IRepositoryMockUpdateStatusMsgOutboxParams{ctx, id, status}
	mmUpdateStatusMsgOutbox.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStatusMsgOutbox.expectations {
		if minimock.Equal(e.params, mmUpdateStatusMsgOutbox.defaultExpectation.params) {
			mmUpdateStatusMsgOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStatusMsgOutbox.defaultExpectation.params)
		}
	}

	return mmUpdateStatusMsgOutbox
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockUpdateStatusMsgOutbox {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation = &IRepositoryMockUpdateStatusMsgOutboxExpectation{}
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.params != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Expect")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs = &IRepositoryMockUpdateStatusMsgOutboxParamPtrs{}
	}
	mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStatusMsgOutbox.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStatusMsgOutbox
}

// ExpectIdParam2 sets up expected param id for IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) ExpectIdParam2(id int64) *mIRepositoryMockUpdateStatusMsgOutbox {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation = &IRepositoryMockUpdateStatusMsgOutboxExpectation{}
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.params != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Expect")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs = &IRepositoryMockUpdateStatusMsgOutboxParamPtrs{}
	}
	mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs.id = &id
	mmUpdateStatusMsgOutbox.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateStatusMsgOutbox
}

// ExpectStatusParam3 sets up expected param status for IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) ExpectStatusParam3(status string) *mIRepositoryMockUpdateStatusMsgOutbox {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation = &IRepositoryMockUpdateStatusMsgOutboxExpectation{}
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.params != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Expect")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs = &IRepositoryMockUpdateStatusMsgOutboxParamPtrs{}
	}
	mmUpdateStatusMsgOutbox.defaultExpectation.paramPtrs.status = &status
	mmUpdateStatusMsgOutbox.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmUpdateStatusMsgOutbox
}

// Inspect accepts an inspector function that has same arguments as the IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Inspect(f func(ctx context.Context, id int64, status string)) *mIRepositoryMockUpdateStatusMsgOutbox {
	if mmUpdateStatusMsgOutbox.mock.inspectFuncUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.UpdateStatusMsgOutbox")
	}

	mmUpdateStatusMsgOutbox.mock.inspectFuncUpdateStatusMsgOutbox = f

	return mmUpdateStatusMsgOutbox
}

// Return sets up results that will be returned by IRepository.UpdateStatusMsgOutbox
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Return(err error) *IRepositoryMock {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	if mmUpdateStatusMsgOutbox.defaultExpectation == nil {
		mmUpdateStatusMsgOutbox.defaultExpectation = &IRepositoryMockUpdateStatusMsgOutboxExpectation{mock: mmUpdateStatusMsgOutbox.mock}
	}
	mmUpdateStatusMsgOutbox.defaultExpectation.results = &IRepositoryMockUpdateStatusMsgOutboxResults{err}
	mmUpdateStatusMsgOutbox.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStatusMsgOutbox.mock
}

// Set uses given function f to mock the IRepository.UpdateStatusMsgOutbox method
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Set(f func(ctx context.Context, id int64, status string) (err error)) *IRepositoryMock {
	if mmUpdateStatusMsgOutbox.defaultExpectation != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("Default expectation is already set for the IRepository.UpdateStatusMsgOutbox method")
	}

	if len(mmUpdateStatusMsgOutbox.expectations) > 0 {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("Some expectations are already set for the IRepository.UpdateStatusMsgOutbox method")
	}

	mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox = f
	mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutboxOrigin = minimock.CallerInfo(1)
	return mmUpdateStatusMsgOutbox.mock
}

// When sets expectation for the IRepository.UpdateStatusMsgOutbox which will trigger the result defined by the following
// Then helper
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) When(ctx context.Context, id int64, status string) *IRepositoryMockUpdateStatusMsgOutboxExpectation {
	if mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("IRepositoryMock.UpdateStatusMsgOutbox mock is already set by Set")
	}

	expectation := &IRepositoryMockUpdateStatusMsgOutboxExpectation{
		mock:               mmUpdateStatusMsgOutbox.mock,
		params:             &IRepositoryMockUpdateStatusMsgOutboxParams{ctx, id, status},
		expectationOrigins: IRepositoryMockUpdateStatusMsgOutboxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStatusMsgOutbox.expectations = append(mmUpdateStatusMsgOutbox.expectations, expectation)
	return expectation
}

// Then sets up IRepository.UpdateStatusMsgOutbox return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockUpdateStatusMsgOutboxExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockUpdateStatusMsgOutboxResults{err}
	return e.mock
}

// Times sets number of times IRepository.UpdateStatusMsgOutbox should be invoked
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Times(n uint64) *mIRepositoryMockUpdateStatusMsgOutbox {
	if n == 0 {
		mmUpdateStatusMsgOutbox.mock.t.Fatalf("Times of IRepositoryMock.UpdateStatusMsgOutbox mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStatusMsgOutbox.expectedInvocations, n)
	mmUpdateStatusMsgOutbox.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStatusMsgOutbox
}

func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) invocationsDone() bool {
	if len(mmUpdateStatusMsgOutbox.expectations) == 0 && mmUpdateStatusMsgOutbox.defaultExpectation == nil && mmUpdateStatusMsgOutbox.mock.funcUpdateStatusMsgOutbox == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStatusMsgOutbox.mock.afterUpdateStatusMsgOutboxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStatusMsgOutbox.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStatusMsgOutbox implements mm_service.IRepository
func (mmUpdateStatusMsgOutbox *IRepositoryMock) UpdateStatusMsgOutbox(ctx context.Context, id int64, status string) (err error) {
	mm_atomic.AddUint64(&mmUpdateStatusMsgOutbox.beforeUpdateStatusMsgOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStatusMsgOutbox.afterUpdateStatusMsgOutboxCounter, 1)

	mmUpdateStatusMsgOutbox.t.Helper()

	if mmUpdateStatusMsgOutbox.inspectFuncUpdateStatusMsgOutbox != nil {
		mmUpdateStatusMsgOutbox.inspectFuncUpdateStatusMsgOutbox(ctx, id, status)
	}

	mm_params := IRepositoryMockUpdateStatusMsgOutboxParams{ctx, id, status}

	// Record call args
	mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.mutex.Lock()
	mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.callArgs = append(mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.callArgs, &mm_params)
	mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.mutex.Unlock()

	for _, e := range mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockUpdateStatusMsgOutboxParams{ctx, id, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStatusMsgOutbox.t.Errorf("IRepositoryMock.UpdateStatusMsgOutbox got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateStatusMsgOutbox.t.Errorf("IRepositoryMock.UpdateStatusMsgOutbox got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmUpdateStatusMsgOutbox.t.Errorf("IRepositoryMock.UpdateStatusMsgOutbox got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStatusMsgOutbox.t.Errorf("IRepositoryMock.UpdateStatusMsgOutbox got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStatusMsgOutbox.UpdateStatusMsgOutboxMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStatusMsgOutbox.t.Fatal("No results are set for the IRepositoryMock.UpdateStatusMsgOutbox")
		}
		return (*mm_results).err
	}
	if mmUpdateStatusMsgOutbox.funcUpdateStatusMsgOutbox != nil {
		return mmUpdateStatusMsgOutbox.funcUpdateStatusMsgOutbox(ctx, id, status)
	}
	mmUpdateStatusMsgOutbox.t.Fatalf("Unexpected call to IRepositoryMock.UpdateStatusMsgOutbox. %v %v %v", ctx, id, status)
	return
}

// UpdateStatusMsgOutboxAfterCounter returns a count of finished IRepositoryMock.UpdateStatusMsgOutbox invocations
func (mmUpdateStatusMsgOutbox *IRepositoryMock) UpdateStatusMsgOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatusMsgOutbox.afterUpdateStatusMsgOutboxCounter)
}

// UpdateStatusMsgOutboxBeforeCounter returns a count of IRepositoryMock.UpdateStatusMsgOutbox invocations
func (mmUpdateStatusMsgOutbox *IRepositoryMock) UpdateStatusMsgOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatusMsgOutbox.beforeUpdateStatusMsgOutboxCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.UpdateStatusMsgOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStatusMsgOutbox *mIRepositoryMockUpdateStatusMsgOutbox) Calls() []*IRepositoryMockUpdateStatusMsgOutboxParams {
	mmUpdateStatusMsgOutbox.mutex.RLock()

	argCopy := make([]*IRepositoryMockUpdateStatusMsgOutboxParams, len(mmUpdateStatusMsgOutbox.callArgs))
	copy(argCopy, mmUpdateStatusMsgOutbox.callArgs)

	mmUpdateStatusMsgOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStatusMsgOutboxDone returns true if the count of the UpdateStatusMsgOutbox invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockUpdateStatusMsgOutboxDone() bool {
	if m.UpdateStatusMsgOutboxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStatusMsgOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStatusMsgOutboxMock.invocationsDone()
}

// MinimockUpdateStatusMsgOutboxInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockUpdateStatusMsgOutboxInspect() {
	for _, e := range m.UpdateStatusMsgOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.UpdateStatusMsgOutbox at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStatusMsgOutboxCounter := mm_atomic.LoadUint64(&m.afterUpdateStatusMsgOutboxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMsgOutboxMock.defaultExpectation != nil && afterUpdateStatusMsgOutboxCounter < 1 {
		if m.UpdateStatusMsgOutboxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.UpdateStatusMsgOutbox at\n%s", m.UpdateStatusMsgOutboxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.UpdateStatusMsgOutbox at\n%s with params: %#v", m.UpdateStatusMsgOutboxMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStatusMsgOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatusMsgOutbox != nil && afterUpdateStatusMsgOutboxCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.UpdateStatusMsgOutbox at\n%s", m.funcUpdateStatusMsgOutboxOrigin)
	}

	if !m.UpdateStatusMsgOutboxMock.invocationsDone() && afterUpdateStatusMsgOutboxCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.UpdateStatusMsgOutbox at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStatusMsgOutboxMock.expectedInvocations), m.UpdateStatusMsgOutboxMock.expectedInvocationsOrigin, afterUpdateStatusMsgOutboxCounter)
	}
}

type mIRepositoryMockUseMaster struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockUseMasterExpectation
	expectations       []*IRepositoryMockUseMasterExpectation

	callArgs []*IRepositoryMockUseMasterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockUseMasterExpectation specifies expectation struct of the IRepository.UseMaster
type IRepositoryMockUseMasterExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockUseMasterParams
	paramPtrs          *IRepositoryMockUseMasterParamPtrs
	expectationOrigins IRepositoryMockUseMasterExpectationOrigins
	results            *IRepositoryMockUseMasterResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockUseMasterParams contains parameters of the IRepository.UseMaster
type IRepositoryMockUseMasterParams struct {
	typeReq string
}

// IRepositoryMockUseMasterParamPtrs contains pointers to parameters of the IRepository.UseMaster
type IRepositoryMockUseMasterParamPtrs struct {
	typeReq *string
}

// IRepositoryMockUseMasterResults contains results of the IRepository.UseMaster
type IRepositoryMockUseMasterResults struct {
	b1 bool
}

// IRepositoryMockUseMasterOrigins contains origins of expectations of the IRepository.UseMaster
type IRepositoryMockUseMasterExpectationOrigins struct {
	origin        string
	originTypeReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUseMaster *mIRepositoryMockUseMaster) Optional() *mIRepositoryMockUseMaster {
	mmUseMaster.optional = true
	return mmUseMaster
}

// Expect sets up expected params for IRepository.UseMaster
func (mmUseMaster *mIRepositoryMockUseMaster) Expect(typeReq string) *mIRepositoryMockUseMaster {
	if mmUseMaster.mock.funcUseMaster != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by Set")
	}

	if mmUseMaster.defaultExpectation == nil {
		mmUseMaster.defaultExpectation = &IRepositoryMockUseMasterExpectation{}
	}

	if mmUseMaster.defaultExpectation.paramPtrs != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by ExpectParams functions")
	}

	mmUseMaster.defaultExpectation.params = &IRepositoryMockUseMasterParams{typeReq}
	mmUseMaster.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUseMaster.expectations {
		if minimock.Equal(e.params, mmUseMaster.defaultExpectation.params) {
			mmUseMaster.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUseMaster.defaultExpectation.params)
		}
	}

	return mmUseMaster
}

// ExpectTypeReqParam1 sets up expected param typeReq for IRepository.UseMaster
func (mmUseMaster *mIRepositoryMockUseMaster) ExpectTypeReqParam1(typeReq string) *mIRepositoryMockUseMaster {
	if mmUseMaster.mock.funcUseMaster != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by Set")
	}

	if mmUseMaster.defaultExpectation == nil {
		mmUseMaster.defaultExpectation = &IRepositoryMockUseMasterExpectation{}
	}

	if mmUseMaster.defaultExpectation.params != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by Expect")
	}

	if mmUseMaster.defaultExpectation.paramPtrs == nil {
		mmUseMaster.defaultExpectation.paramPtrs = &IRepositoryMockUseMasterParamPtrs{}
	}
	mmUseMaster.defaultExpectation.paramPtrs.typeReq = &typeReq
	mmUseMaster.defaultExpectation.expectationOrigins.originTypeReq = minimock.CallerInfo(1)

	return mmUseMaster
}

// Inspect accepts an inspector function that has same arguments as the IRepository.UseMaster
func (mmUseMaster *mIRepositoryMockUseMaster) Inspect(f func(typeReq string)) *mIRepositoryMockUseMaster {
	if mmUseMaster.mock.inspectFuncUseMaster != nil {
		mmUseMaster.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.UseMaster")
	}

	mmUseMaster.mock.inspectFuncUseMaster = f

	return mmUseMaster
}

// Return sets up results that will be returned by IRepository.UseMaster
func (mmUseMaster *mIRepositoryMockUseMaster) Return(b1 bool) *IRepositoryMock {
	if mmUseMaster.mock.funcUseMaster != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by Set")
	}

	if mmUseMaster.defaultExpectation == nil {
		mmUseMaster.defaultExpectation = &IRepositoryMockUseMasterExpectation{mock: mmUseMaster.mock}
	}
	mmUseMaster.defaultExpectation.results = &IRepositoryMockUseMasterResults{b1}
	mmUseMaster.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUseMaster.mock
}

// Set uses given function f to mock the IRepository.UseMaster method
func (mmUseMaster *mIRepositoryMockUseMaster) Set(f func(typeReq string) (b1 bool)) *IRepositoryMock {
	if mmUseMaster.defaultExpectation != nil {
		mmUseMaster.mock.t.Fatalf("Default expectation is already set for the IRepository.UseMaster method")
	}

	if len(mmUseMaster.expectations) > 0 {
		mmUseMaster.mock.t.Fatalf("Some expectations are already set for the IRepository.UseMaster method")
	}

	mmUseMaster.mock.funcUseMaster = f
	mmUseMaster.mock.funcUseMasterOrigin = minimock.CallerInfo(1)
	return mmUseMaster.mock
}

// When sets expectation for the IRepository.UseMaster which will trigger the result defined by the following
// Then helper
func (mmUseMaster *mIRepositoryMockUseMaster) When(typeReq string) *IRepositoryMockUseMasterExpectation {
	if mmUseMaster.mock.funcUseMaster != nil {
		mmUseMaster.mock.t.Fatalf("IRepositoryMock.UseMaster mock is already set by Set")
	}

	expectation := &IRepositoryMockUseMasterExpectation{
		mock:               mmUseMaster.mock,
		params:             &IRepositoryMockUseMasterParams{typeReq},
		expectationOrigins: IRepositoryMockUseMasterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUseMaster.expectations = append(mmUseMaster.expectations, expectation)
	return expectation
}

// Then sets up IRepository.UseMaster return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockUseMasterExpectation) Then(b1 bool) *IRepositoryMock {
	e.results = &IRepositoryMockUseMasterResults{b1}
	return e.mock
}

// Times sets number of times IRepository.UseMaster should be invoked
func (mmUseMaster *mIRepositoryMockUseMaster) Times(n uint64) *mIRepositoryMockUseMaster {
	if n == 0 {
		mmUseMaster.mock.t.Fatalf("Times of IRepositoryMock.UseMaster mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUseMaster.expectedInvocations, n)
	mmUseMaster.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUseMaster
}

func (mmUseMaster *mIRepositoryMockUseMaster) invocationsDone() bool {
	if len(mmUseMaster.expectations) == 0 && mmUseMaster.defaultExpectation == nil && mmUseMaster.mock.funcUseMaster == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUseMaster.mock.afterUseMasterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUseMaster.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UseMaster implements mm_service.IRepository
func (mmUseMaster *IRepositoryMock) UseMaster(typeReq string) (b1 bool) {
	mm_atomic.AddUint64(&mmUseMaster.beforeUseMasterCounter, 1)
	defer mm_atomic.AddUint64(&mmUseMaster.afterUseMasterCounter, 1)

	mmUseMaster.t.Helper()

	if mmUseMaster.inspectFuncUseMaster != nil {
		mmUseMaster.inspectFuncUseMaster(typeReq)
	}

	mm_params := IRepositoryMockUseMasterParams{typeReq}

	// Record call args
	mmUseMaster.UseMasterMock.mutex.Lock()
	mmUseMaster.UseMasterMock.callArgs = append(mmUseMaster.UseMasterMock.callArgs, &mm_params)
	mmUseMaster.UseMasterMock.mutex.Unlock()

	for _, e := range mmUseMaster.UseMasterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUseMaster.UseMasterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUseMaster.UseMasterMock.defaultExpectation.Counter, 1)
		mm_want := mmUseMaster.UseMasterMock.defaultExpectation.params
		mm_want_ptrs := mmUseMaster.UseMasterMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockUseMasterParams{typeReq}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.typeReq != nil && !minimock.Equal(*mm_want_ptrs.typeReq, mm_got.typeReq) {
				mmUseMaster.t.Errorf("IRepositoryMock.UseMaster got unexpected parameter typeReq, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUseMaster.UseMasterMock.defaultExpectation.expectationOrigins.originTypeReq, *mm_want_ptrs.typeReq, mm_got.typeReq, minimock.Diff(*mm_want_ptrs.typeReq, mm_got.typeReq))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUseMaster.t.Errorf("IRepositoryMock.UseMaster got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUseMaster.UseMasterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUseMaster.UseMasterMock.defaultExpectation.results
		if mm_results == nil {
			mmUseMaster.t.Fatal("No results are set for the IRepositoryMock.UseMaster")
		}
		return (*mm_results).b1
	}
	if mmUseMaster.funcUseMaster != nil {
		return mmUseMaster.funcUseMaster(typeReq)
	}
	mmUseMaster.t.Fatalf("Unexpected call to IRepositoryMock.UseMaster. %v", typeReq)
	return
}

// UseMasterAfterCounter returns a count of finished IRepositoryMock.UseMaster invocations
func (mmUseMaster *IRepositoryMock) UseMasterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUseMaster.afterUseMasterCounter)
}

// UseMasterBeforeCounter returns a count of IRepositoryMock.UseMaster invocations
func (mmUseMaster *IRepositoryMock) UseMasterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUseMaster.beforeUseMasterCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.UseMaster.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUseMaster *mIRepositoryMockUseMaster) Calls() []*IRepositoryMockUseMasterParams {
	mmUseMaster.mutex.RLock()

	argCopy := make([]*IRepositoryMockUseMasterParams, len(mmUseMaster.callArgs))
	copy(argCopy, mmUseMaster.callArgs)

	mmUseMaster.mutex.RUnlock()

	return argCopy
}

// MinimockUseMasterDone returns true if the count of the UseMaster invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockUseMasterDone() bool {
	if m.UseMasterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UseMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UseMasterMock.invocationsDone()
}

// MinimockUseMasterInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockUseMasterInspect() {
	for _, e := range m.UseMasterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.UseMaster at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUseMasterCounter := mm_atomic.LoadUint64(&m.afterUseMasterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UseMasterMock.defaultExpectation != nil && afterUseMasterCounter < 1 {
		if m.UseMasterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.UseMaster at\n%s", m.UseMasterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.UseMaster at\n%s with params: %#v", m.UseMasterMock.defaultExpectation.expectationOrigins.origin, *m.UseMasterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUseMaster != nil && afterUseMasterCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.UseMaster at\n%s", m.funcUseMasterOrigin)
	}

	if !m.UseMasterMock.invocationsDone() && afterUseMasterCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.UseMaster at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UseMasterMock.expectedInvocations), m.UseMasterMock.expectedInvocationsOrigin, afterUseMasterCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOutboxInspect()

			m.MinimockCreateOrderInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetFreeStocksBySkuMasterInspect()

			m.MinimockGetFreeStocksBySkuReplicaInspect()

			m.MinimockGetInfoByOrderIDMasterInspect()

			m.MinimockGetInfoByOrderIDReplicaInspect()

			m.MinimockGetNewMsgOutboxInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()

			m.MinimockSetStatusOrderInspect()

			m.MinimockUpdateStatusMsgOutboxInspect()

			m.MinimockUseMasterInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOutboxDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetFreeStocksBySkuMasterDone() &&
		m.MinimockGetFreeStocksBySkuReplicaDone() &&
		m.MinimockGetInfoByOrderIDMasterDone() &&
		m.MinimockGetInfoByOrderIDReplicaDone() &&
		m.MinimockGetNewMsgOutboxDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone() &&
		m.MinimockSetStatusOrderDone() &&
		m.MinimockUpdateStatusMsgOutboxDone() &&
		m.MinimockUseMasterDone()
}
