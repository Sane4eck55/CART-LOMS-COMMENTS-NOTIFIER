// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/app/server.LomsService -o loms_service_mock.go -n LomsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/loms/internal/model"
	"github.com/gojuno/minimock/v3"
)

// LomsServiceMock implements mm_server.LomsService
type LomsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetStocksBySku          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcGetStocksBySkuOrigin    string
	inspectFuncGetStocksBySku   func(ctx context.Context, sku int64)
	afterGetStocksBySkuCounter  uint64
	beforeGetStocksBySkuCounter uint64
	GetStocksBySkuMock          mLomsServiceMockGetStocksBySku

	funcOrderCancel          func(ctx context.Context, orderID int64) (err error)
	funcOrderCancelOrigin    string
	inspectFuncOrderCancel   func(ctx context.Context, orderID int64)
	afterOrderCancelCounter  uint64
	beforeOrderCancelCounter uint64
	OrderCancelMock          mLomsServiceMockOrderCancel

	funcOrderCreate          func(ctx context.Context, order model.Order) (i1 int64, err error)
	funcOrderCreateOrigin    string
	inspectFuncOrderCreate   func(ctx context.Context, order model.Order)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mLomsServiceMockOrderCreate

	funcOrderInfo          func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)
	funcOrderInfoOrigin    string
	inspectFuncOrderInfo   func(ctx context.Context, orderID int64)
	afterOrderInfoCounter  uint64
	beforeOrderInfoCounter uint64
	OrderInfoMock          mLomsServiceMockOrderInfo

	funcOrderPay          func(ctx context.Context, orderID int64) (err error)
	funcOrderPayOrigin    string
	inspectFuncOrderPay   func(ctx context.Context, orderID int64)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mLomsServiceMockOrderPay

	funcProduceFromOutbox          func(ctx context.Context)
	funcProduceFromOutboxOrigin    string
	inspectFuncProduceFromOutbox   func(ctx context.Context)
	afterProduceFromOutboxCounter  uint64
	beforeProduceFromOutboxCounter uint64
	ProduceFromOutboxMock          mLomsServiceMockProduceFromOutbox
}

// NewLomsServiceMock returns a mock for mm_server.LomsService
func NewLomsServiceMock(t minimock.Tester) *LomsServiceMock {
	m := &LomsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetStocksBySkuMock = mLomsServiceMockGetStocksBySku{mock: m}
	m.GetStocksBySkuMock.callArgs = []*LomsServiceMockGetStocksBySkuParams{}

	m.OrderCancelMock = mLomsServiceMockOrderCancel{mock: m}
	m.OrderCancelMock.callArgs = []*LomsServiceMockOrderCancelParams{}

	m.OrderCreateMock = mLomsServiceMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*LomsServiceMockOrderCreateParams{}

	m.OrderInfoMock = mLomsServiceMockOrderInfo{mock: m}
	m.OrderInfoMock.callArgs = []*LomsServiceMockOrderInfoParams{}

	m.OrderPayMock = mLomsServiceMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*LomsServiceMockOrderPayParams{}

	m.ProduceFromOutboxMock = mLomsServiceMockProduceFromOutbox{mock: m}
	m.ProduceFromOutboxMock.callArgs = []*LomsServiceMockProduceFromOutboxParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLomsServiceMockGetStocksBySku struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockGetStocksBySkuExpectation
	expectations       []*LomsServiceMockGetStocksBySkuExpectation

	callArgs []*LomsServiceMockGetStocksBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockGetStocksBySkuExpectation specifies expectation struct of the LomsService.GetStocksBySku
type LomsServiceMockGetStocksBySkuExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockGetStocksBySkuParams
	paramPtrs          *LomsServiceMockGetStocksBySkuParamPtrs
	expectationOrigins LomsServiceMockGetStocksBySkuExpectationOrigins
	results            *LomsServiceMockGetStocksBySkuResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiceMockGetStocksBySkuParams contains parameters of the LomsService.GetStocksBySku
type LomsServiceMockGetStocksBySkuParams struct {
	ctx context.Context
	sku int64
}

// LomsServiceMockGetStocksBySkuParamPtrs contains pointers to parameters of the LomsService.GetStocksBySku
type LomsServiceMockGetStocksBySkuParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// LomsServiceMockGetStocksBySkuResults contains results of the LomsService.GetStocksBySku
type LomsServiceMockGetStocksBySkuResults struct {
	u1  uint32
	err error
}

// LomsServiceMockGetStocksBySkuOrigins contains origins of expectations of the LomsService.GetStocksBySku
type LomsServiceMockGetStocksBySkuExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Optional() *mLomsServiceMockGetStocksBySku {
	mmGetStocksBySku.optional = true
	return mmGetStocksBySku
}

// Expect sets up expected params for LomsService.GetStocksBySku
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Expect(ctx context.Context, sku int64) *mLomsServiceMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &LomsServiceMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by ExpectParams functions")
	}

	mmGetStocksBySku.defaultExpectation.params = &LomsServiceMockGetStocksBySkuParams{ctx, sku}
	mmGetStocksBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStocksBySku.expectations {
		if minimock.Equal(e.params, mmGetStocksBySku.defaultExpectation.params) {
			mmGetStocksBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocksBySku.defaultExpectation.params)
		}
	}

	return mmGetStocksBySku
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.GetStocksBySku
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &LomsServiceMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &LomsServiceMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStocksBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStocksBySku
}

// ExpectSkuParam2 sets up expected param sku for LomsService.GetStocksBySku
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) ExpectSkuParam2(sku int64) *mLomsServiceMockGetStocksBySku {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &LomsServiceMockGetStocksBySkuExpectation{}
	}

	if mmGetStocksBySku.defaultExpectation.params != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Expect")
	}

	if mmGetStocksBySku.defaultExpectation.paramPtrs == nil {
		mmGetStocksBySku.defaultExpectation.paramPtrs = &LomsServiceMockGetStocksBySkuParamPtrs{}
	}
	mmGetStocksBySku.defaultExpectation.paramPtrs.sku = &sku
	mmGetStocksBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetStocksBySku
}

// Inspect accepts an inspector function that has same arguments as the LomsService.GetStocksBySku
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Inspect(f func(ctx context.Context, sku int64)) *mLomsServiceMockGetStocksBySku {
	if mmGetStocksBySku.mock.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.GetStocksBySku")
	}

	mmGetStocksBySku.mock.inspectFuncGetStocksBySku = f

	return mmGetStocksBySku
}

// Return sets up results that will be returned by LomsService.GetStocksBySku
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Return(u1 uint32, err error) *LomsServiceMock {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Set")
	}

	if mmGetStocksBySku.defaultExpectation == nil {
		mmGetStocksBySku.defaultExpectation = &LomsServiceMockGetStocksBySkuExpectation{mock: mmGetStocksBySku.mock}
	}
	mmGetStocksBySku.defaultExpectation.results = &LomsServiceMockGetStocksBySkuResults{u1, err}
	mmGetStocksBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku.mock
}

// Set uses given function f to mock the LomsService.GetStocksBySku method
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *LomsServiceMock {
	if mmGetStocksBySku.defaultExpectation != nil {
		mmGetStocksBySku.mock.t.Fatalf("Default expectation is already set for the LomsService.GetStocksBySku method")
	}

	if len(mmGetStocksBySku.expectations) > 0 {
		mmGetStocksBySku.mock.t.Fatalf("Some expectations are already set for the LomsService.GetStocksBySku method")
	}

	mmGetStocksBySku.mock.funcGetStocksBySku = f
	mmGetStocksBySku.mock.funcGetStocksBySkuOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku.mock
}

// When sets expectation for the LomsService.GetStocksBySku which will trigger the result defined by the following
// Then helper
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) When(ctx context.Context, sku int64) *LomsServiceMockGetStocksBySkuExpectation {
	if mmGetStocksBySku.mock.funcGetStocksBySku != nil {
		mmGetStocksBySku.mock.t.Fatalf("LomsServiceMock.GetStocksBySku mock is already set by Set")
	}

	expectation := &LomsServiceMockGetStocksBySkuExpectation{
		mock:               mmGetStocksBySku.mock,
		params:             &LomsServiceMockGetStocksBySkuParams{ctx, sku},
		expectationOrigins: LomsServiceMockGetStocksBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStocksBySku.expectations = append(mmGetStocksBySku.expectations, expectation)
	return expectation
}

// Then sets up LomsService.GetStocksBySku return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockGetStocksBySkuExpectation) Then(u1 uint32, err error) *LomsServiceMock {
	e.results = &LomsServiceMockGetStocksBySkuResults{u1, err}
	return e.mock
}

// Times sets number of times LomsService.GetStocksBySku should be invoked
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Times(n uint64) *mLomsServiceMockGetStocksBySku {
	if n == 0 {
		mmGetStocksBySku.mock.t.Fatalf("Times of LomsServiceMock.GetStocksBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStocksBySku.expectedInvocations, n)
	mmGetStocksBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStocksBySku
}

func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) invocationsDone() bool {
	if len(mmGetStocksBySku.expectations) == 0 && mmGetStocksBySku.defaultExpectation == nil && mmGetStocksBySku.mock.funcGetStocksBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.mock.afterGetStocksBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStocksBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStocksBySku implements mm_server.LomsService
func (mmGetStocksBySku *LomsServiceMock) GetStocksBySku(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter, 1)

	mmGetStocksBySku.t.Helper()

	if mmGetStocksBySku.inspectFuncGetStocksBySku != nil {
		mmGetStocksBySku.inspectFuncGetStocksBySku(ctx, sku)
	}

	mm_params := LomsServiceMockGetStocksBySkuParams{ctx, sku}

	// Record call args
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Lock()
	mmGetStocksBySku.GetStocksBySkuMock.callArgs = append(mmGetStocksBySku.GetStocksBySkuMock.callArgs, &mm_params)
	mmGetStocksBySku.GetStocksBySkuMock.mutex.Unlock()

	for _, e := range mmGetStocksBySku.GetStocksBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockGetStocksBySkuParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStocksBySku.t.Errorf("LomsServiceMock.GetStocksBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetStocksBySku.t.Errorf("LomsServiceMock.GetStocksBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocksBySku.t.Errorf("LomsServiceMock.GetStocksBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocksBySku.GetStocksBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocksBySku.t.Fatal("No results are set for the LomsServiceMock.GetStocksBySku")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetStocksBySku.funcGetStocksBySku != nil {
		return mmGetStocksBySku.funcGetStocksBySku(ctx, sku)
	}
	mmGetStocksBySku.t.Fatalf("Unexpected call to LomsServiceMock.GetStocksBySku. %v %v", ctx, sku)
	return
}

// GetStocksBySkuAfterCounter returns a count of finished LomsServiceMock.GetStocksBySku invocations
func (mmGetStocksBySku *LomsServiceMock) GetStocksBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.afterGetStocksBySkuCounter)
}

// GetStocksBySkuBeforeCounter returns a count of LomsServiceMock.GetStocksBySku invocations
func (mmGetStocksBySku *LomsServiceMock) GetStocksBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksBySku.beforeGetStocksBySkuCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.GetStocksBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocksBySku *mLomsServiceMockGetStocksBySku) Calls() []*LomsServiceMockGetStocksBySkuParams {
	mmGetStocksBySku.mutex.RLock()

	argCopy := make([]*LomsServiceMockGetStocksBySkuParams, len(mmGetStocksBySku.callArgs))
	copy(argCopy, mmGetStocksBySku.callArgs)

	mmGetStocksBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksBySkuDone returns true if the count of the GetStocksBySku invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockGetStocksBySkuDone() bool {
	if m.GetStocksBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStocksBySkuMock.invocationsDone()
}

// MinimockGetStocksBySkuInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockGetStocksBySkuInspect() {
	for _, e := range m.GetStocksBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.GetStocksBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStocksBySkuCounter := mm_atomic.LoadUint64(&m.afterGetStocksBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksBySkuMock.defaultExpectation != nil && afterGetStocksBySkuCounter < 1 {
		if m.GetStocksBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.GetStocksBySku at\n%s", m.GetStocksBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.GetStocksBySku at\n%s with params: %#v", m.GetStocksBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetStocksBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocksBySku != nil && afterGetStocksBySkuCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.GetStocksBySku at\n%s", m.funcGetStocksBySkuOrigin)
	}

	if !m.GetStocksBySkuMock.invocationsDone() && afterGetStocksBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.GetStocksBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStocksBySkuMock.expectedInvocations), m.GetStocksBySkuMock.expectedInvocationsOrigin, afterGetStocksBySkuCounter)
	}
}

type mLomsServiceMockOrderCancel struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockOrderCancelExpectation
	expectations       []*LomsServiceMockOrderCancelExpectation

	callArgs []*LomsServiceMockOrderCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockOrderCancelExpectation specifies expectation struct of the LomsService.OrderCancel
type LomsServiceMockOrderCancelExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockOrderCancelParams
	paramPtrs          *LomsServiceMockOrderCancelParamPtrs
	expectationOrigins LomsServiceMockOrderCancelExpectationOrigins
	results            *LomsServiceMockOrderCancelResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiceMockOrderCancelParams contains parameters of the LomsService.OrderCancel
type LomsServiceMockOrderCancelParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServiceMockOrderCancelParamPtrs contains pointers to parameters of the LomsService.OrderCancel
type LomsServiceMockOrderCancelParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServiceMockOrderCancelResults contains results of the LomsService.OrderCancel
type LomsServiceMockOrderCancelResults struct {
	err error
}

// LomsServiceMockOrderCancelOrigins contains origins of expectations of the LomsService.OrderCancel
type LomsServiceMockOrderCancelExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCancel *mLomsServiceMockOrderCancel) Optional() *mLomsServiceMockOrderCancel {
	mmOrderCancel.optional = true
	return mmOrderCancel
}

// Expect sets up expected params for LomsService.OrderCancel
func (mmOrderCancel *mLomsServiceMockOrderCancel) Expect(ctx context.Context, orderID int64) *mLomsServiceMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiceMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.paramPtrs != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by ExpectParams functions")
	}

	mmOrderCancel.defaultExpectation.params = &LomsServiceMockOrderCancelParams{ctx, orderID}
	mmOrderCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCancel.expectations {
		if minimock.Equal(e.params, mmOrderCancel.defaultExpectation.params) {
			mmOrderCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancel.defaultExpectation.params)
		}
	}

	return mmOrderCancel
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.OrderCancel
func (mmOrderCancel *mLomsServiceMockOrderCancel) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiceMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServiceMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCancel
}

// ExpectOrderIDParam2 sets up expected param orderID for LomsService.OrderCancel
func (mmOrderCancel *mLomsServiceMockOrderCancel) ExpectOrderIDParam2(orderID int64) *mLomsServiceMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiceMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServiceMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.orderID = &orderID
	mmOrderCancel.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmOrderCancel
}

// Inspect accepts an inspector function that has same arguments as the LomsService.OrderCancel
func (mmOrderCancel *mLomsServiceMockOrderCancel) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServiceMockOrderCancel {
	if mmOrderCancel.mock.inspectFuncOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.OrderCancel")
	}

	mmOrderCancel.mock.inspectFuncOrderCancel = f

	return mmOrderCancel
}

// Return sets up results that will be returned by LomsService.OrderCancel
func (mmOrderCancel *mLomsServiceMockOrderCancel) Return(err error) *LomsServiceMock {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServiceMockOrderCancelExpectation{mock: mmOrderCancel.mock}
	}
	mmOrderCancel.defaultExpectation.results = &LomsServiceMockOrderCancelResults{err}
	mmOrderCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCancel.mock
}

// Set uses given function f to mock the LomsService.OrderCancel method
func (mmOrderCancel *mLomsServiceMockOrderCancel) Set(f func(ctx context.Context, orderID int64) (err error)) *LomsServiceMock {
	if mmOrderCancel.defaultExpectation != nil {
		mmOrderCancel.mock.t.Fatalf("Default expectation is already set for the LomsService.OrderCancel method")
	}

	if len(mmOrderCancel.expectations) > 0 {
		mmOrderCancel.mock.t.Fatalf("Some expectations are already set for the LomsService.OrderCancel method")
	}

	mmOrderCancel.mock.funcOrderCancel = f
	mmOrderCancel.mock.funcOrderCancelOrigin = minimock.CallerInfo(1)
	return mmOrderCancel.mock
}

// When sets expectation for the LomsService.OrderCancel which will trigger the result defined by the following
// Then helper
func (mmOrderCancel *mLomsServiceMockOrderCancel) When(ctx context.Context, orderID int64) *LomsServiceMockOrderCancelExpectation {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServiceMock.OrderCancel mock is already set by Set")
	}

	expectation := &LomsServiceMockOrderCancelExpectation{
		mock:               mmOrderCancel.mock,
		params:             &LomsServiceMockOrderCancelParams{ctx, orderID},
		expectationOrigins: LomsServiceMockOrderCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCancel.expectations = append(mmOrderCancel.expectations, expectation)
	return expectation
}

// Then sets up LomsService.OrderCancel return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockOrderCancelExpectation) Then(err error) *LomsServiceMock {
	e.results = &LomsServiceMockOrderCancelResults{err}
	return e.mock
}

// Times sets number of times LomsService.OrderCancel should be invoked
func (mmOrderCancel *mLomsServiceMockOrderCancel) Times(n uint64) *mLomsServiceMockOrderCancel {
	if n == 0 {
		mmOrderCancel.mock.t.Fatalf("Times of LomsServiceMock.OrderCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCancel.expectedInvocations, n)
	mmOrderCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCancel
}

func (mmOrderCancel *mLomsServiceMockOrderCancel) invocationsDone() bool {
	if len(mmOrderCancel.expectations) == 0 && mmOrderCancel.defaultExpectation == nil && mmOrderCancel.mock.funcOrderCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCancel.mock.afterOrderCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCancel implements mm_server.LomsService
func (mmOrderCancel *LomsServiceMock) OrderCancel(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmOrderCancel.beforeOrderCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancel.afterOrderCancelCounter, 1)

	mmOrderCancel.t.Helper()

	if mmOrderCancel.inspectFuncOrderCancel != nil {
		mmOrderCancel.inspectFuncOrderCancel(ctx, orderID)
	}

	mm_params := LomsServiceMockOrderCancelParams{ctx, orderID}

	// Record call args
	mmOrderCancel.OrderCancelMock.mutex.Lock()
	mmOrderCancel.OrderCancelMock.callArgs = append(mmOrderCancel.OrderCancelMock.callArgs, &mm_params)
	mmOrderCancel.OrderCancelMock.mutex.Unlock()

	for _, e := range mmOrderCancel.OrderCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderCancel.OrderCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancel.OrderCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancel.OrderCancelMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCancel.OrderCancelMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockOrderCancelParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCancel.t.Errorf("LomsServiceMock.OrderCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderCancel.t.Errorf("LomsServiceMock.OrderCancel got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancel.t.Errorf("LomsServiceMock.OrderCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCancel.OrderCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancel.OrderCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancel.t.Fatal("No results are set for the LomsServiceMock.OrderCancel")
		}
		return (*mm_results).err
	}
	if mmOrderCancel.funcOrderCancel != nil {
		return mmOrderCancel.funcOrderCancel(ctx, orderID)
	}
	mmOrderCancel.t.Fatalf("Unexpected call to LomsServiceMock.OrderCancel. %v %v", ctx, orderID)
	return
}

// OrderCancelAfterCounter returns a count of finished LomsServiceMock.OrderCancel invocations
func (mmOrderCancel *LomsServiceMock) OrderCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.afterOrderCancelCounter)
}

// OrderCancelBeforeCounter returns a count of LomsServiceMock.OrderCancel invocations
func (mmOrderCancel *LomsServiceMock) OrderCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.beforeOrderCancelCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.OrderCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancel *mLomsServiceMockOrderCancel) Calls() []*LomsServiceMockOrderCancelParams {
	mmOrderCancel.mutex.RLock()

	argCopy := make([]*LomsServiceMockOrderCancelParams, len(mmOrderCancel.callArgs))
	copy(argCopy, mmOrderCancel.callArgs)

	mmOrderCancel.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelDone returns true if the count of the OrderCancel invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockOrderCancelDone() bool {
	if m.OrderCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCancelMock.invocationsDone()
}

// MinimockOrderCancelInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockOrderCancelInspect() {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCancelCounter := mm_atomic.LoadUint64(&m.afterOrderCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && afterOrderCancelCounter < 1 {
		if m.OrderCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCancel at\n%s", m.OrderCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCancel at\n%s with params: %#v", m.OrderCancelMock.defaultExpectation.expectationOrigins.origin, *m.OrderCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && afterOrderCancelCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.OrderCancel at\n%s", m.funcOrderCancelOrigin)
	}

	if !m.OrderCancelMock.invocationsDone() && afterOrderCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.OrderCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCancelMock.expectedInvocations), m.OrderCancelMock.expectedInvocationsOrigin, afterOrderCancelCounter)
	}
}

type mLomsServiceMockOrderCreate struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockOrderCreateExpectation
	expectations       []*LomsServiceMockOrderCreateExpectation

	callArgs []*LomsServiceMockOrderCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockOrderCreateExpectation specifies expectation struct of the LomsService.OrderCreate
type LomsServiceMockOrderCreateExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockOrderCreateParams
	paramPtrs          *LomsServiceMockOrderCreateParamPtrs
	expectationOrigins LomsServiceMockOrderCreateExpectationOrigins
	results            *LomsServiceMockOrderCreateResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiceMockOrderCreateParams contains parameters of the LomsService.OrderCreate
type LomsServiceMockOrderCreateParams struct {
	ctx   context.Context
	order model.Order
}

// LomsServiceMockOrderCreateParamPtrs contains pointers to parameters of the LomsService.OrderCreate
type LomsServiceMockOrderCreateParamPtrs struct {
	ctx   *context.Context
	order *model.Order
}

// LomsServiceMockOrderCreateResults contains results of the LomsService.OrderCreate
type LomsServiceMockOrderCreateResults struct {
	i1  int64
	err error
}

// LomsServiceMockOrderCreateOrigins contains origins of expectations of the LomsService.OrderCreate
type LomsServiceMockOrderCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreate *mLomsServiceMockOrderCreate) Optional() *mLomsServiceMockOrderCreate {
	mmOrderCreate.optional = true
	return mmOrderCreate
}

// Expect sets up expected params for LomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Expect(ctx context.Context, order model.Order) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.paramPtrs != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by ExpectParams functions")
	}

	mmOrderCreate.defaultExpectation.params = &LomsServiceMockOrderCreateParams{ctx, order}
	mmOrderCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderCreate
}

// ExpectOrderParam2 sets up expected param order for LomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) ExpectOrderParam2(order model.Order) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServiceMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.order = &order
	mmOrderCreate.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the LomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Inspect(f func(ctx context.Context, order model.Order)) *mLomsServiceMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by LomsService.OrderCreate
func (mmOrderCreate *mLomsServiceMockOrderCreate) Return(i1 int64, err error) *LomsServiceMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServiceMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &LomsServiceMockOrderCreateResults{i1, err}
	mmOrderCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// Set uses given function f to mock the LomsService.OrderCreate method
func (mmOrderCreate *mLomsServiceMockOrderCreate) Set(f func(ctx context.Context, order model.Order) (i1 int64, err error)) *LomsServiceMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the LomsService.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the LomsService.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	mmOrderCreate.mock.funcOrderCreateOrigin = minimock.CallerInfo(1)
	return mmOrderCreate.mock
}

// When sets expectation for the LomsService.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mLomsServiceMockOrderCreate) When(ctx context.Context, order model.Order) *LomsServiceMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServiceMock.OrderCreate mock is already set by Set")
	}

	expectation := &LomsServiceMockOrderCreateExpectation{
		mock:               mmOrderCreate.mock,
		params:             &LomsServiceMockOrderCreateParams{ctx, order},
		expectationOrigins: LomsServiceMockOrderCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up LomsService.OrderCreate return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockOrderCreateExpectation) Then(i1 int64, err error) *LomsServiceMock {
	e.results = &LomsServiceMockOrderCreateResults{i1, err}
	return e.mock
}

// Times sets number of times LomsService.OrderCreate should be invoked
func (mmOrderCreate *mLomsServiceMockOrderCreate) Times(n uint64) *mLomsServiceMockOrderCreate {
	if n == 0 {
		mmOrderCreate.mock.t.Fatalf("Times of LomsServiceMock.OrderCreate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreate.expectedInvocations, n)
	mmOrderCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderCreate
}

func (mmOrderCreate *mLomsServiceMockOrderCreate) invocationsDone() bool {
	if len(mmOrderCreate.expectations) == 0 && mmOrderCreate.defaultExpectation == nil && mmOrderCreate.mock.funcOrderCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreate.mock.afterOrderCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreate implements mm_server.LomsService
func (mmOrderCreate *LomsServiceMock) OrderCreate(ctx context.Context, order model.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	mmOrderCreate.t.Helper()

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, order)
	}

	mm_params := LomsServiceMockOrderCreateParams{ctx, order}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreate.OrderCreateMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockOrderCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("LomsServiceMock.OrderCreate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderCreate.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the LomsServiceMock.OrderCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, order)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to LomsServiceMock.OrderCreate. %v %v", ctx, order)
	return
}

// OrderCreateAfterCounter returns a count of finished LomsServiceMock.OrderCreate invocations
func (mmOrderCreate *LomsServiceMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of LomsServiceMock.OrderCreate invocations
func (mmOrderCreate *LomsServiceMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mLomsServiceMockOrderCreate) Calls() []*LomsServiceMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*LomsServiceMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockOrderCreateDone() bool {
	if m.OrderCreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateMock.invocationsDone()
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCreate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCreateCounter := mm_atomic.LoadUint64(&m.afterOrderCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && afterOrderCreateCounter < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCreate at\n%s", m.OrderCreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.OrderCreate at\n%s with params: %#v", m.OrderCreateMock.defaultExpectation.expectationOrigins.origin, *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && afterOrderCreateCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.OrderCreate at\n%s", m.funcOrderCreateOrigin)
	}

	if !m.OrderCreateMock.invocationsDone() && afterOrderCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.OrderCreate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateMock.expectedInvocations), m.OrderCreateMock.expectedInvocationsOrigin, afterOrderCreateCounter)
	}
}

type mLomsServiceMockOrderInfo struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockOrderInfoExpectation
	expectations       []*LomsServiceMockOrderInfoExpectation

	callArgs []*LomsServiceMockOrderInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockOrderInfoExpectation specifies expectation struct of the LomsService.OrderInfo
type LomsServiceMockOrderInfoExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockOrderInfoParams
	paramPtrs          *LomsServiceMockOrderInfoParamPtrs
	expectationOrigins LomsServiceMockOrderInfoExpectationOrigins
	results            *LomsServiceMockOrderInfoResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiceMockOrderInfoParams contains parameters of the LomsService.OrderInfo
type LomsServiceMockOrderInfoParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServiceMockOrderInfoParamPtrs contains pointers to parameters of the LomsService.OrderInfo
type LomsServiceMockOrderInfoParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServiceMockOrderInfoResults contains results of the LomsService.OrderInfo
type LomsServiceMockOrderInfoResults struct {
	op1 *model.OrderInfo
	err error
}

// LomsServiceMockOrderInfoOrigins contains origins of expectations of the LomsService.OrderInfo
type LomsServiceMockOrderInfoExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderInfo *mLomsServiceMockOrderInfo) Optional() *mLomsServiceMockOrderInfo {
	mmOrderInfo.optional = true
	return mmOrderInfo
}

// Expect sets up expected params for LomsService.OrderInfo
func (mmOrderInfo *mLomsServiceMockOrderInfo) Expect(ctx context.Context, orderID int64) *mLomsServiceMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiceMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.paramPtrs != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by ExpectParams functions")
	}

	mmOrderInfo.defaultExpectation.params = &LomsServiceMockOrderInfoParams{ctx, orderID}
	mmOrderInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderInfo.expectations {
		if minimock.Equal(e.params, mmOrderInfo.defaultExpectation.params) {
			mmOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderInfo.defaultExpectation.params)
		}
	}

	return mmOrderInfo
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.OrderInfo
func (mmOrderInfo *mLomsServiceMockOrderInfo) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiceMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServiceMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderInfo
}

// ExpectOrderIDParam2 sets up expected param orderID for LomsService.OrderInfo
func (mmOrderInfo *mLomsServiceMockOrderInfo) ExpectOrderIDParam2(orderID int64) *mLomsServiceMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiceMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServiceMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.orderID = &orderID
	mmOrderInfo.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the LomsService.OrderInfo
func (mmOrderInfo *mLomsServiceMockOrderInfo) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServiceMockOrderInfo {
	if mmOrderInfo.mock.inspectFuncOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.OrderInfo")
	}

	mmOrderInfo.mock.inspectFuncOrderInfo = f

	return mmOrderInfo
}

// Return sets up results that will be returned by LomsService.OrderInfo
func (mmOrderInfo *mLomsServiceMockOrderInfo) Return(op1 *model.OrderInfo, err error) *LomsServiceMock {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServiceMockOrderInfoExpectation{mock: mmOrderInfo.mock}
	}
	mmOrderInfo.defaultExpectation.results = &LomsServiceMockOrderInfoResults{op1, err}
	mmOrderInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderInfo.mock
}

// Set uses given function f to mock the LomsService.OrderInfo method
func (mmOrderInfo *mLomsServiceMockOrderInfo) Set(f func(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error)) *LomsServiceMock {
	if mmOrderInfo.defaultExpectation != nil {
		mmOrderInfo.mock.t.Fatalf("Default expectation is already set for the LomsService.OrderInfo method")
	}

	if len(mmOrderInfo.expectations) > 0 {
		mmOrderInfo.mock.t.Fatalf("Some expectations are already set for the LomsService.OrderInfo method")
	}

	mmOrderInfo.mock.funcOrderInfo = f
	mmOrderInfo.mock.funcOrderInfoOrigin = minimock.CallerInfo(1)
	return mmOrderInfo.mock
}

// When sets expectation for the LomsService.OrderInfo which will trigger the result defined by the following
// Then helper
func (mmOrderInfo *mLomsServiceMockOrderInfo) When(ctx context.Context, orderID int64) *LomsServiceMockOrderInfoExpectation {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServiceMock.OrderInfo mock is already set by Set")
	}

	expectation := &LomsServiceMockOrderInfoExpectation{
		mock:               mmOrderInfo.mock,
		params:             &LomsServiceMockOrderInfoParams{ctx, orderID},
		expectationOrigins: LomsServiceMockOrderInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderInfo.expectations = append(mmOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up LomsService.OrderInfo return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockOrderInfoExpectation) Then(op1 *model.OrderInfo, err error) *LomsServiceMock {
	e.results = &LomsServiceMockOrderInfoResults{op1, err}
	return e.mock
}

// Times sets number of times LomsService.OrderInfo should be invoked
func (mmOrderInfo *mLomsServiceMockOrderInfo) Times(n uint64) *mLomsServiceMockOrderInfo {
	if n == 0 {
		mmOrderInfo.mock.t.Fatalf("Times of LomsServiceMock.OrderInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderInfo.expectedInvocations, n)
	mmOrderInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderInfo
}

func (mmOrderInfo *mLomsServiceMockOrderInfo) invocationsDone() bool {
	if len(mmOrderInfo.expectations) == 0 && mmOrderInfo.defaultExpectation == nil && mmOrderInfo.mock.funcOrderInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderInfo.mock.afterOrderInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderInfo implements mm_server.LomsService
func (mmOrderInfo *LomsServiceMock) OrderInfo(ctx context.Context, orderID int64) (op1 *model.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmOrderInfo.beforeOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderInfo.afterOrderInfoCounter, 1)

	mmOrderInfo.t.Helper()

	if mmOrderInfo.inspectFuncOrderInfo != nil {
		mmOrderInfo.inspectFuncOrderInfo(ctx, orderID)
	}

	mm_params := LomsServiceMockOrderInfoParams{ctx, orderID}

	// Record call args
	mmOrderInfo.OrderInfoMock.mutex.Lock()
	mmOrderInfo.OrderInfoMock.callArgs = append(mmOrderInfo.OrderInfoMock.callArgs, &mm_params)
	mmOrderInfo.OrderInfoMock.mutex.Unlock()

	for _, e := range mmOrderInfo.OrderInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderInfo.OrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderInfo.OrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderInfo.OrderInfoMock.defaultExpectation.params
		mm_want_ptrs := mmOrderInfo.OrderInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockOrderInfoParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderInfo.t.Errorf("LomsServiceMock.OrderInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderInfo.t.Errorf("LomsServiceMock.OrderInfo got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderInfo.t.Errorf("LomsServiceMock.OrderInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderInfo.OrderInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderInfo.OrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderInfo.t.Fatal("No results are set for the LomsServiceMock.OrderInfo")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderInfo.funcOrderInfo != nil {
		return mmOrderInfo.funcOrderInfo(ctx, orderID)
	}
	mmOrderInfo.t.Fatalf("Unexpected call to LomsServiceMock.OrderInfo. %v %v", ctx, orderID)
	return
}

// OrderInfoAfterCounter returns a count of finished LomsServiceMock.OrderInfo invocations
func (mmOrderInfo *LomsServiceMock) OrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.afterOrderInfoCounter)
}

// OrderInfoBeforeCounter returns a count of LomsServiceMock.OrderInfo invocations
func (mmOrderInfo *LomsServiceMock) OrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.beforeOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.OrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderInfo *mLomsServiceMockOrderInfo) Calls() []*LomsServiceMockOrderInfoParams {
	mmOrderInfo.mutex.RLock()

	argCopy := make([]*LomsServiceMockOrderInfoParams, len(mmOrderInfo.callArgs))
	copy(argCopy, mmOrderInfo.callArgs)

	mmOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderInfoDone returns true if the count of the OrderInfo invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockOrderInfoDone() bool {
	if m.OrderInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderInfoMock.invocationsDone()
}

// MinimockOrderInfoInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockOrderInfoInspect() {
	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.OrderInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderInfoCounter := mm_atomic.LoadUint64(&m.afterOrderInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoMock.defaultExpectation != nil && afterOrderInfoCounter < 1 {
		if m.OrderInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.OrderInfo at\n%s", m.OrderInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.OrderInfo at\n%s with params: %#v", m.OrderInfoMock.defaultExpectation.expectationOrigins.origin, *m.OrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfo != nil && afterOrderInfoCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.OrderInfo at\n%s", m.funcOrderInfoOrigin)
	}

	if !m.OrderInfoMock.invocationsDone() && afterOrderInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.OrderInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderInfoMock.expectedInvocations), m.OrderInfoMock.expectedInvocationsOrigin, afterOrderInfoCounter)
	}
}

type mLomsServiceMockOrderPay struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockOrderPayExpectation
	expectations       []*LomsServiceMockOrderPayExpectation

	callArgs []*LomsServiceMockOrderPayParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockOrderPayExpectation specifies expectation struct of the LomsService.OrderPay
type LomsServiceMockOrderPayExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockOrderPayParams
	paramPtrs          *LomsServiceMockOrderPayParamPtrs
	expectationOrigins LomsServiceMockOrderPayExpectationOrigins
	results            *LomsServiceMockOrderPayResults
	returnOrigin       string
	Counter            uint64
}

// LomsServiceMockOrderPayParams contains parameters of the LomsService.OrderPay
type LomsServiceMockOrderPayParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServiceMockOrderPayParamPtrs contains pointers to parameters of the LomsService.OrderPay
type LomsServiceMockOrderPayParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServiceMockOrderPayResults contains results of the LomsService.OrderPay
type LomsServiceMockOrderPayResults struct {
	err error
}

// LomsServiceMockOrderPayOrigins contains origins of expectations of the LomsService.OrderPay
type LomsServiceMockOrderPayExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderPay *mLomsServiceMockOrderPay) Optional() *mLomsServiceMockOrderPay {
	mmOrderPay.optional = true
	return mmOrderPay
}

// Expect sets up expected params for LomsService.OrderPay
func (mmOrderPay *mLomsServiceMockOrderPay) Expect(ctx context.Context, orderID int64) *mLomsServiceMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiceMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.paramPtrs != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by ExpectParams functions")
	}

	mmOrderPay.defaultExpectation.params = &LomsServiceMockOrderPayParams{ctx, orderID}
	mmOrderPay.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.OrderPay
func (mmOrderPay *mLomsServiceMockOrderPay) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiceMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServiceMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrderPay.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrderPay
}

// ExpectOrderIDParam2 sets up expected param orderID for LomsService.OrderPay
func (mmOrderPay *mLomsServiceMockOrderPay) ExpectOrderIDParam2(orderID int64) *mLomsServiceMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiceMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServiceMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.orderID = &orderID
	mmOrderPay.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the LomsService.OrderPay
func (mmOrderPay *mLomsServiceMockOrderPay) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServiceMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by LomsService.OrderPay
func (mmOrderPay *mLomsServiceMockOrderPay) Return(err error) *LomsServiceMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServiceMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &LomsServiceMockOrderPayResults{err}
	mmOrderPay.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrderPay.mock
}

// Set uses given function f to mock the LomsService.OrderPay method
func (mmOrderPay *mLomsServiceMockOrderPay) Set(f func(ctx context.Context, orderID int64) (err error)) *LomsServiceMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the LomsService.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the LomsService.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	mmOrderPay.mock.funcOrderPayOrigin = minimock.CallerInfo(1)
	return mmOrderPay.mock
}

// When sets expectation for the LomsService.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mLomsServiceMockOrderPay) When(ctx context.Context, orderID int64) *LomsServiceMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServiceMock.OrderPay mock is already set by Set")
	}

	expectation := &LomsServiceMockOrderPayExpectation{
		mock:               mmOrderPay.mock,
		params:             &LomsServiceMockOrderPayParams{ctx, orderID},
		expectationOrigins: LomsServiceMockOrderPayExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up LomsService.OrderPay return parameters for the expectation previously defined by the When method
func (e *LomsServiceMockOrderPayExpectation) Then(err error) *LomsServiceMock {
	e.results = &LomsServiceMockOrderPayResults{err}
	return e.mock
}

// Times sets number of times LomsService.OrderPay should be invoked
func (mmOrderPay *mLomsServiceMockOrderPay) Times(n uint64) *mLomsServiceMockOrderPay {
	if n == 0 {
		mmOrderPay.mock.t.Fatalf("Times of LomsServiceMock.OrderPay mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderPay.expectedInvocations, n)
	mmOrderPay.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrderPay
}

func (mmOrderPay *mLomsServiceMockOrderPay) invocationsDone() bool {
	if len(mmOrderPay.expectations) == 0 && mmOrderPay.defaultExpectation == nil && mmOrderPay.mock.funcOrderPay == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderPay.mock.afterOrderPayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderPay.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderPay implements mm_server.LomsService
func (mmOrderPay *LomsServiceMock) OrderPay(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	mmOrderPay.t.Helper()

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, orderID)
	}

	mm_params := LomsServiceMockOrderPayParams{ctx, orderID}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_want_ptrs := mmOrderPay.OrderPayMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockOrderPayParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderPay.t.Errorf("LomsServiceMock.OrderPay got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderPay.t.Errorf("LomsServiceMock.OrderPay got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("LomsServiceMock.OrderPay got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrderPay.OrderPayMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the LomsServiceMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, orderID)
	}
	mmOrderPay.t.Fatalf("Unexpected call to LomsServiceMock.OrderPay. %v %v", ctx, orderID)
	return
}

// OrderPayAfterCounter returns a count of finished LomsServiceMock.OrderPay invocations
func (mmOrderPay *LomsServiceMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of LomsServiceMock.OrderPay invocations
func (mmOrderPay *LomsServiceMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mLomsServiceMockOrderPay) Calls() []*LomsServiceMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*LomsServiceMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockOrderPayDone() bool {
	if m.OrderPayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderPayMock.invocationsDone()
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.OrderPay at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderPayCounter := mm_atomic.LoadUint64(&m.afterOrderPayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && afterOrderPayCounter < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.OrderPay at\n%s", m.OrderPayMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.OrderPay at\n%s with params: %#v", m.OrderPayMock.defaultExpectation.expectationOrigins.origin, *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && afterOrderPayCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.OrderPay at\n%s", m.funcOrderPayOrigin)
	}

	if !m.OrderPayMock.invocationsDone() && afterOrderPayCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.OrderPay at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderPayMock.expectedInvocations), m.OrderPayMock.expectedInvocationsOrigin, afterOrderPayCounter)
	}
}

type mLomsServiceMockProduceFromOutbox struct {
	optional           bool
	mock               *LomsServiceMock
	defaultExpectation *LomsServiceMockProduceFromOutboxExpectation
	expectations       []*LomsServiceMockProduceFromOutboxExpectation

	callArgs []*LomsServiceMockProduceFromOutboxParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsServiceMockProduceFromOutboxExpectation specifies expectation struct of the LomsService.ProduceFromOutbox
type LomsServiceMockProduceFromOutboxExpectation struct {
	mock               *LomsServiceMock
	params             *LomsServiceMockProduceFromOutboxParams
	paramPtrs          *LomsServiceMockProduceFromOutboxParamPtrs
	expectationOrigins LomsServiceMockProduceFromOutboxExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LomsServiceMockProduceFromOutboxParams contains parameters of the LomsService.ProduceFromOutbox
type LomsServiceMockProduceFromOutboxParams struct {
	ctx context.Context
}

// LomsServiceMockProduceFromOutboxParamPtrs contains pointers to parameters of the LomsService.ProduceFromOutbox
type LomsServiceMockProduceFromOutboxParamPtrs struct {
	ctx *context.Context
}

// LomsServiceMockProduceFromOutboxOrigins contains origins of expectations of the LomsService.ProduceFromOutbox
type LomsServiceMockProduceFromOutboxExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Optional() *mLomsServiceMockProduceFromOutbox {
	mmProduceFromOutbox.optional = true
	return mmProduceFromOutbox
}

// Expect sets up expected params for LomsService.ProduceFromOutbox
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Expect(ctx context.Context) *mLomsServiceMockProduceFromOutbox {
	if mmProduceFromOutbox.mock.funcProduceFromOutbox != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by Set")
	}

	if mmProduceFromOutbox.defaultExpectation == nil {
		mmProduceFromOutbox.defaultExpectation = &LomsServiceMockProduceFromOutboxExpectation{}
	}

	if mmProduceFromOutbox.defaultExpectation.paramPtrs != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by ExpectParams functions")
	}

	mmProduceFromOutbox.defaultExpectation.params = &LomsServiceMockProduceFromOutboxParams{ctx}
	mmProduceFromOutbox.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProduceFromOutbox.expectations {
		if minimock.Equal(e.params, mmProduceFromOutbox.defaultExpectation.params) {
			mmProduceFromOutbox.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProduceFromOutbox.defaultExpectation.params)
		}
	}

	return mmProduceFromOutbox
}

// ExpectCtxParam1 sets up expected param ctx for LomsService.ProduceFromOutbox
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) ExpectCtxParam1(ctx context.Context) *mLomsServiceMockProduceFromOutbox {
	if mmProduceFromOutbox.mock.funcProduceFromOutbox != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by Set")
	}

	if mmProduceFromOutbox.defaultExpectation == nil {
		mmProduceFromOutbox.defaultExpectation = &LomsServiceMockProduceFromOutboxExpectation{}
	}

	if mmProduceFromOutbox.defaultExpectation.params != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by Expect")
	}

	if mmProduceFromOutbox.defaultExpectation.paramPtrs == nil {
		mmProduceFromOutbox.defaultExpectation.paramPtrs = &LomsServiceMockProduceFromOutboxParamPtrs{}
	}
	mmProduceFromOutbox.defaultExpectation.paramPtrs.ctx = &ctx
	mmProduceFromOutbox.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProduceFromOutbox
}

// Inspect accepts an inspector function that has same arguments as the LomsService.ProduceFromOutbox
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Inspect(f func(ctx context.Context)) *mLomsServiceMockProduceFromOutbox {
	if mmProduceFromOutbox.mock.inspectFuncProduceFromOutbox != nil {
		mmProduceFromOutbox.mock.t.Fatalf("Inspect function is already set for LomsServiceMock.ProduceFromOutbox")
	}

	mmProduceFromOutbox.mock.inspectFuncProduceFromOutbox = f

	return mmProduceFromOutbox
}

// Return sets up results that will be returned by LomsService.ProduceFromOutbox
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Return() *LomsServiceMock {
	if mmProduceFromOutbox.mock.funcProduceFromOutbox != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by Set")
	}

	if mmProduceFromOutbox.defaultExpectation == nil {
		mmProduceFromOutbox.defaultExpectation = &LomsServiceMockProduceFromOutboxExpectation{mock: mmProduceFromOutbox.mock}
	}

	mmProduceFromOutbox.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProduceFromOutbox.mock
}

// Set uses given function f to mock the LomsService.ProduceFromOutbox method
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Set(f func(ctx context.Context)) *LomsServiceMock {
	if mmProduceFromOutbox.defaultExpectation != nil {
		mmProduceFromOutbox.mock.t.Fatalf("Default expectation is already set for the LomsService.ProduceFromOutbox method")
	}

	if len(mmProduceFromOutbox.expectations) > 0 {
		mmProduceFromOutbox.mock.t.Fatalf("Some expectations are already set for the LomsService.ProduceFromOutbox method")
	}

	mmProduceFromOutbox.mock.funcProduceFromOutbox = f
	mmProduceFromOutbox.mock.funcProduceFromOutboxOrigin = minimock.CallerInfo(1)
	return mmProduceFromOutbox.mock
}

// When sets expectation for the LomsService.ProduceFromOutbox which will trigger the result defined by the following
// Then helper
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) When(ctx context.Context) *LomsServiceMockProduceFromOutboxExpectation {
	if mmProduceFromOutbox.mock.funcProduceFromOutbox != nil {
		mmProduceFromOutbox.mock.t.Fatalf("LomsServiceMock.ProduceFromOutbox mock is already set by Set")
	}

	expectation := &LomsServiceMockProduceFromOutboxExpectation{
		mock:               mmProduceFromOutbox.mock,
		params:             &LomsServiceMockProduceFromOutboxParams{ctx},
		expectationOrigins: LomsServiceMockProduceFromOutboxExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProduceFromOutbox.expectations = append(mmProduceFromOutbox.expectations, expectation)
	return expectation
}

// Then sets up LomsService.ProduceFromOutbox return parameters for the expectation previously defined by the When method

func (e *LomsServiceMockProduceFromOutboxExpectation) Then() *LomsServiceMock {
	return e.mock
}

// Times sets number of times LomsService.ProduceFromOutbox should be invoked
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Times(n uint64) *mLomsServiceMockProduceFromOutbox {
	if n == 0 {
		mmProduceFromOutbox.mock.t.Fatalf("Times of LomsServiceMock.ProduceFromOutbox mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProduceFromOutbox.expectedInvocations, n)
	mmProduceFromOutbox.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProduceFromOutbox
}

func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) invocationsDone() bool {
	if len(mmProduceFromOutbox.expectations) == 0 && mmProduceFromOutbox.defaultExpectation == nil && mmProduceFromOutbox.mock.funcProduceFromOutbox == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProduceFromOutbox.mock.afterProduceFromOutboxCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProduceFromOutbox.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProduceFromOutbox implements mm_server.LomsService
func (mmProduceFromOutbox *LomsServiceMock) ProduceFromOutbox(ctx context.Context) {
	mm_atomic.AddUint64(&mmProduceFromOutbox.beforeProduceFromOutboxCounter, 1)
	defer mm_atomic.AddUint64(&mmProduceFromOutbox.afterProduceFromOutboxCounter, 1)

	mmProduceFromOutbox.t.Helper()

	if mmProduceFromOutbox.inspectFuncProduceFromOutbox != nil {
		mmProduceFromOutbox.inspectFuncProduceFromOutbox(ctx)
	}

	mm_params := LomsServiceMockProduceFromOutboxParams{ctx}

	// Record call args
	mmProduceFromOutbox.ProduceFromOutboxMock.mutex.Lock()
	mmProduceFromOutbox.ProduceFromOutboxMock.callArgs = append(mmProduceFromOutbox.ProduceFromOutboxMock.callArgs, &mm_params)
	mmProduceFromOutbox.ProduceFromOutboxMock.mutex.Unlock()

	for _, e := range mmProduceFromOutbox.ProduceFromOutboxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation.Counter, 1)
		mm_want := mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation.params
		mm_want_ptrs := mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation.paramPtrs

		mm_got := LomsServiceMockProduceFromOutboxParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProduceFromOutbox.t.Errorf("LomsServiceMock.ProduceFromOutbox got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProduceFromOutbox.t.Errorf("LomsServiceMock.ProduceFromOutbox got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProduceFromOutbox.ProduceFromOutboxMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProduceFromOutbox.funcProduceFromOutbox != nil {
		mmProduceFromOutbox.funcProduceFromOutbox(ctx)
		return
	}
	mmProduceFromOutbox.t.Fatalf("Unexpected call to LomsServiceMock.ProduceFromOutbox. %v", ctx)

}

// ProduceFromOutboxAfterCounter returns a count of finished LomsServiceMock.ProduceFromOutbox invocations
func (mmProduceFromOutbox *LomsServiceMock) ProduceFromOutboxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProduceFromOutbox.afterProduceFromOutboxCounter)
}

// ProduceFromOutboxBeforeCounter returns a count of LomsServiceMock.ProduceFromOutbox invocations
func (mmProduceFromOutbox *LomsServiceMock) ProduceFromOutboxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProduceFromOutbox.beforeProduceFromOutboxCounter)
}

// Calls returns a list of arguments used in each call to LomsServiceMock.ProduceFromOutbox.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProduceFromOutbox *mLomsServiceMockProduceFromOutbox) Calls() []*LomsServiceMockProduceFromOutboxParams {
	mmProduceFromOutbox.mutex.RLock()

	argCopy := make([]*LomsServiceMockProduceFromOutboxParams, len(mmProduceFromOutbox.callArgs))
	copy(argCopy, mmProduceFromOutbox.callArgs)

	mmProduceFromOutbox.mutex.RUnlock()

	return argCopy
}

// MinimockProduceFromOutboxDone returns true if the count of the ProduceFromOutbox invocations corresponds
// the number of defined expectations
func (m *LomsServiceMock) MinimockProduceFromOutboxDone() bool {
	if m.ProduceFromOutboxMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProduceFromOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProduceFromOutboxMock.invocationsDone()
}

// MinimockProduceFromOutboxInspect logs each unmet expectation
func (m *LomsServiceMock) MinimockProduceFromOutboxInspect() {
	for _, e := range m.ProduceFromOutboxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServiceMock.ProduceFromOutbox at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProduceFromOutboxCounter := mm_atomic.LoadUint64(&m.afterProduceFromOutboxCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProduceFromOutboxMock.defaultExpectation != nil && afterProduceFromOutboxCounter < 1 {
		if m.ProduceFromOutboxMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsServiceMock.ProduceFromOutbox at\n%s", m.ProduceFromOutboxMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsServiceMock.ProduceFromOutbox at\n%s with params: %#v", m.ProduceFromOutboxMock.defaultExpectation.expectationOrigins.origin, *m.ProduceFromOutboxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProduceFromOutbox != nil && afterProduceFromOutboxCounter < 1 {
		m.t.Errorf("Expected call to LomsServiceMock.ProduceFromOutbox at\n%s", m.funcProduceFromOutboxOrigin)
	}

	if !m.ProduceFromOutboxMock.invocationsDone() && afterProduceFromOutboxCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServiceMock.ProduceFromOutbox at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProduceFromOutboxMock.expectedInvocations), m.ProduceFromOutboxMock.expectedInvocationsOrigin, afterProduceFromOutboxCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetStocksBySkuInspect()

			m.MinimockOrderCancelInspect()

			m.MinimockOrderCreateInspect()

			m.MinimockOrderInfoInspect()

			m.MinimockOrderPayInspect()

			m.MinimockProduceFromOutboxInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetStocksBySkuDone() &&
		m.MinimockOrderCancelDone() &&
		m.MinimockOrderCreateDone() &&
		m.MinimockOrderInfoDone() &&
		m.MinimockOrderPayDone() &&
		m.MinimockProduceFromOutboxDone()
}
