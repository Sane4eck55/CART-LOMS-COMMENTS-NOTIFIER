// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/comments/internal/service.IRepository -o i_repository_mock.go -n IRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/comments/internal/model"
	"github.com/gojuno/minimock/v3"
)

// IRepositoryMock implements mm_service.IRepository
type IRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddComment          func(ctx context.Context, comment model.Comment) (i1 int64, err error)
	funcAddCommentOrigin    string
	inspectFuncAddComment   func(ctx context.Context, comment model.Comment)
	afterAddCommentCounter  uint64
	beforeAddCommentCounter uint64
	AddCommentMock          mIRepositoryMockAddComment

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mIRepositoryMockClose

	funcCommentListBySku          func(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error)
	funcCommentListBySkuOrigin    string
	inspectFuncCommentListBySku   func(ctx context.Context, sku int64, cursor *model.Cursor)
	afterCommentListBySkuCounter  uint64
	beforeCommentListBySkuCounter uint64
	CommentListBySkuMock          mIRepositoryMockCommentListBySku

	funcCommentListByUser          func(ctx context.Context, userID int64) (ca1 []model.Comment, err error)
	funcCommentListByUserOrigin    string
	inspectFuncCommentListByUser   func(ctx context.Context, userID int64)
	afterCommentListByUserCounter  uint64
	beforeCommentListByUserCounter uint64
	CommentListByUserMock          mIRepositoryMockCommentListByUser

	funcEditComment          func(ctx context.Context, comment model.Comment) (err error)
	funcEditCommentOrigin    string
	inspectFuncEditComment   func(ctx context.Context, comment model.Comment)
	afterEditCommentCounter  uint64
	beforeEditCommentCounter uint64
	EditCommentMock          mIRepositoryMockEditComment

	funcGetCommentByID          func(ctx context.Context, commentID int64) (cp1 *model.Comment, err error)
	funcGetCommentByIDOrigin    string
	inspectFuncGetCommentByID   func(ctx context.Context, commentID int64)
	afterGetCommentByIDCounter  uint64
	beforeGetCommentByIDCounter uint64
	GetCommentByIDMock          mIRepositoryMockGetCommentByID
}

// NewIRepositoryMock returns a mock for mm_service.IRepository
func NewIRepositoryMock(t minimock.Tester) *IRepositoryMock {
	m := &IRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCommentMock = mIRepositoryMockAddComment{mock: m}
	m.AddCommentMock.callArgs = []*IRepositoryMockAddCommentParams{}

	m.CloseMock = mIRepositoryMockClose{mock: m}

	m.CommentListBySkuMock = mIRepositoryMockCommentListBySku{mock: m}
	m.CommentListBySkuMock.callArgs = []*IRepositoryMockCommentListBySkuParams{}

	m.CommentListByUserMock = mIRepositoryMockCommentListByUser{mock: m}
	m.CommentListByUserMock.callArgs = []*IRepositoryMockCommentListByUserParams{}

	m.EditCommentMock = mIRepositoryMockEditComment{mock: m}
	m.EditCommentMock.callArgs = []*IRepositoryMockEditCommentParams{}

	m.GetCommentByIDMock = mIRepositoryMockGetCommentByID{mock: m}
	m.GetCommentByIDMock.callArgs = []*IRepositoryMockGetCommentByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIRepositoryMockAddComment struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockAddCommentExpectation
	expectations       []*IRepositoryMockAddCommentExpectation

	callArgs []*IRepositoryMockAddCommentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockAddCommentExpectation specifies expectation struct of the IRepository.AddComment
type IRepositoryMockAddCommentExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockAddCommentParams
	paramPtrs          *IRepositoryMockAddCommentParamPtrs
	expectationOrigins IRepositoryMockAddCommentExpectationOrigins
	results            *IRepositoryMockAddCommentResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockAddCommentParams contains parameters of the IRepository.AddComment
type IRepositoryMockAddCommentParams struct {
	ctx     context.Context
	comment model.Comment
}

// IRepositoryMockAddCommentParamPtrs contains pointers to parameters of the IRepository.AddComment
type IRepositoryMockAddCommentParamPtrs struct {
	ctx     *context.Context
	comment *model.Comment
}

// IRepositoryMockAddCommentResults contains results of the IRepository.AddComment
type IRepositoryMockAddCommentResults struct {
	i1  int64
	err error
}

// IRepositoryMockAddCommentOrigins contains origins of expectations of the IRepository.AddComment
type IRepositoryMockAddCommentExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddComment *mIRepositoryMockAddComment) Optional() *mIRepositoryMockAddComment {
	mmAddComment.optional = true
	return mmAddComment
}

// Expect sets up expected params for IRepository.AddComment
func (mmAddComment *mIRepositoryMockAddComment) Expect(ctx context.Context, comment model.Comment) *mIRepositoryMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &IRepositoryMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.paramPtrs != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by ExpectParams functions")
	}

	mmAddComment.defaultExpectation.params = &IRepositoryMockAddCommentParams{ctx, comment}
	mmAddComment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddComment.expectations {
		if minimock.Equal(e.params, mmAddComment.defaultExpectation.params) {
			mmAddComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddComment.defaultExpectation.params)
		}
	}

	return mmAddComment
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.AddComment
func (mmAddComment *mIRepositoryMockAddComment) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &IRepositoryMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &IRepositoryMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddComment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddComment
}

// ExpectCommentParam2 sets up expected param comment for IRepository.AddComment
func (mmAddComment *mIRepositoryMockAddComment) ExpectCommentParam2(comment model.Comment) *mIRepositoryMockAddComment {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &IRepositoryMockAddCommentExpectation{}
	}

	if mmAddComment.defaultExpectation.params != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Expect")
	}

	if mmAddComment.defaultExpectation.paramPtrs == nil {
		mmAddComment.defaultExpectation.paramPtrs = &IRepositoryMockAddCommentParamPtrs{}
	}
	mmAddComment.defaultExpectation.paramPtrs.comment = &comment
	mmAddComment.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmAddComment
}

// Inspect accepts an inspector function that has same arguments as the IRepository.AddComment
func (mmAddComment *mIRepositoryMockAddComment) Inspect(f func(ctx context.Context, comment model.Comment)) *mIRepositoryMockAddComment {
	if mmAddComment.mock.inspectFuncAddComment != nil {
		mmAddComment.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.AddComment")
	}

	mmAddComment.mock.inspectFuncAddComment = f

	return mmAddComment
}

// Return sets up results that will be returned by IRepository.AddComment
func (mmAddComment *mIRepositoryMockAddComment) Return(i1 int64, err error) *IRepositoryMock {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Set")
	}

	if mmAddComment.defaultExpectation == nil {
		mmAddComment.defaultExpectation = &IRepositoryMockAddCommentExpectation{mock: mmAddComment.mock}
	}
	mmAddComment.defaultExpectation.results = &IRepositoryMockAddCommentResults{i1, err}
	mmAddComment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddComment.mock
}

// Set uses given function f to mock the IRepository.AddComment method
func (mmAddComment *mIRepositoryMockAddComment) Set(f func(ctx context.Context, comment model.Comment) (i1 int64, err error)) *IRepositoryMock {
	if mmAddComment.defaultExpectation != nil {
		mmAddComment.mock.t.Fatalf("Default expectation is already set for the IRepository.AddComment method")
	}

	if len(mmAddComment.expectations) > 0 {
		mmAddComment.mock.t.Fatalf("Some expectations are already set for the IRepository.AddComment method")
	}

	mmAddComment.mock.funcAddComment = f
	mmAddComment.mock.funcAddCommentOrigin = minimock.CallerInfo(1)
	return mmAddComment.mock
}

// When sets expectation for the IRepository.AddComment which will trigger the result defined by the following
// Then helper
func (mmAddComment *mIRepositoryMockAddComment) When(ctx context.Context, comment model.Comment) *IRepositoryMockAddCommentExpectation {
	if mmAddComment.mock.funcAddComment != nil {
		mmAddComment.mock.t.Fatalf("IRepositoryMock.AddComment mock is already set by Set")
	}

	expectation := &IRepositoryMockAddCommentExpectation{
		mock:               mmAddComment.mock,
		params:             &IRepositoryMockAddCommentParams{ctx, comment},
		expectationOrigins: IRepositoryMockAddCommentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddComment.expectations = append(mmAddComment.expectations, expectation)
	return expectation
}

// Then sets up IRepository.AddComment return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockAddCommentExpectation) Then(i1 int64, err error) *IRepositoryMock {
	e.results = &IRepositoryMockAddCommentResults{i1, err}
	return e.mock
}

// Times sets number of times IRepository.AddComment should be invoked
func (mmAddComment *mIRepositoryMockAddComment) Times(n uint64) *mIRepositoryMockAddComment {
	if n == 0 {
		mmAddComment.mock.t.Fatalf("Times of IRepositoryMock.AddComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddComment.expectedInvocations, n)
	mmAddComment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddComment
}

func (mmAddComment *mIRepositoryMockAddComment) invocationsDone() bool {
	if len(mmAddComment.expectations) == 0 && mmAddComment.defaultExpectation == nil && mmAddComment.mock.funcAddComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddComment.mock.afterAddCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddComment implements mm_service.IRepository
func (mmAddComment *IRepositoryMock) AddComment(ctx context.Context, comment model.Comment) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddComment.beforeAddCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmAddComment.afterAddCommentCounter, 1)

	mmAddComment.t.Helper()

	if mmAddComment.inspectFuncAddComment != nil {
		mmAddComment.inspectFuncAddComment(ctx, comment)
	}

	mm_params := IRepositoryMockAddCommentParams{ctx, comment}

	// Record call args
	mmAddComment.AddCommentMock.mutex.Lock()
	mmAddComment.AddCommentMock.callArgs = append(mmAddComment.AddCommentMock.callArgs, &mm_params)
	mmAddComment.AddCommentMock.mutex.Unlock()

	for _, e := range mmAddComment.AddCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddComment.AddCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddComment.AddCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmAddComment.AddCommentMock.defaultExpectation.params
		mm_want_ptrs := mmAddComment.AddCommentMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockAddCommentParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddComment.t.Errorf("IRepositoryMock.AddComment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComment.AddCommentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmAddComment.t.Errorf("IRepositoryMock.AddComment got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddComment.AddCommentMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddComment.t.Errorf("IRepositoryMock.AddComment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddComment.AddCommentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddComment.AddCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmAddComment.t.Fatal("No results are set for the IRepositoryMock.AddComment")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddComment.funcAddComment != nil {
		return mmAddComment.funcAddComment(ctx, comment)
	}
	mmAddComment.t.Fatalf("Unexpected call to IRepositoryMock.AddComment. %v %v", ctx, comment)
	return
}

// AddCommentAfterCounter returns a count of finished IRepositoryMock.AddComment invocations
func (mmAddComment *IRepositoryMock) AddCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.afterAddCommentCounter)
}

// AddCommentBeforeCounter returns a count of IRepositoryMock.AddComment invocations
func (mmAddComment *IRepositoryMock) AddCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddComment.beforeAddCommentCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.AddComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddComment *mIRepositoryMockAddComment) Calls() []*IRepositoryMockAddCommentParams {
	mmAddComment.mutex.RLock()

	argCopy := make([]*IRepositoryMockAddCommentParams, len(mmAddComment.callArgs))
	copy(argCopy, mmAddComment.callArgs)

	mmAddComment.mutex.RUnlock()

	return argCopy
}

// MinimockAddCommentDone returns true if the count of the AddComment invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockAddCommentDone() bool {
	if m.AddCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCommentMock.invocationsDone()
}

// MinimockAddCommentInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockAddCommentInspect() {
	for _, e := range m.AddCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.AddComment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCommentCounter := mm_atomic.LoadUint64(&m.afterAddCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCommentMock.defaultExpectation != nil && afterAddCommentCounter < 1 {
		if m.AddCommentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.AddComment at\n%s", m.AddCommentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.AddComment at\n%s with params: %#v", m.AddCommentMock.defaultExpectation.expectationOrigins.origin, *m.AddCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddComment != nil && afterAddCommentCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.AddComment at\n%s", m.funcAddCommentOrigin)
	}

	if !m.AddCommentMock.invocationsDone() && afterAddCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.AddComment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCommentMock.expectedInvocations), m.AddCommentMock.expectedInvocationsOrigin, afterAddCommentCounter)
	}
}

type mIRepositoryMockClose struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockCloseExpectation
	expectations       []*IRepositoryMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockCloseExpectation specifies expectation struct of the IRepository.Close
type IRepositoryMockCloseExpectation struct {
	mock *IRepositoryMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mIRepositoryMockClose) Optional() *mIRepositoryMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for IRepository.Close
func (mmClose *mIRepositoryMockClose) Expect() *mIRepositoryMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("IRepositoryMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &IRepositoryMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the IRepository.Close
func (mmClose *mIRepositoryMockClose) Inspect(f func()) *mIRepositoryMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by IRepository.Close
func (mmClose *mIRepositoryMockClose) Return() *IRepositoryMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("IRepositoryMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &IRepositoryMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the IRepository.Close method
func (mmClose *mIRepositoryMockClose) Set(f func()) *IRepositoryMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the IRepository.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the IRepository.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times IRepository.Close should be invoked
func (mmClose *mIRepositoryMockClose) Times(n uint64) *mIRepositoryMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of IRepositoryMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mIRepositoryMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_service.IRepository
func (mmClose *IRepositoryMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to IRepositoryMock.Close.")

}

// CloseAfterCounter returns a count of finished IRepositoryMock.Close invocations
func (mmClose *IRepositoryMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of IRepositoryMock.Close invocations
func (mmClose *IRepositoryMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IRepositoryMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mIRepositoryMockCommentListBySku struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockCommentListBySkuExpectation
	expectations       []*IRepositoryMockCommentListBySkuExpectation

	callArgs []*IRepositoryMockCommentListBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockCommentListBySkuExpectation specifies expectation struct of the IRepository.CommentListBySku
type IRepositoryMockCommentListBySkuExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockCommentListBySkuParams
	paramPtrs          *IRepositoryMockCommentListBySkuParamPtrs
	expectationOrigins IRepositoryMockCommentListBySkuExpectationOrigins
	results            *IRepositoryMockCommentListBySkuResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockCommentListBySkuParams contains parameters of the IRepository.CommentListBySku
type IRepositoryMockCommentListBySkuParams struct {
	ctx    context.Context
	sku    int64
	cursor *model.Cursor
}

// IRepositoryMockCommentListBySkuParamPtrs contains pointers to parameters of the IRepository.CommentListBySku
type IRepositoryMockCommentListBySkuParamPtrs struct {
	ctx    *context.Context
	sku    *int64
	cursor **model.Cursor
}

// IRepositoryMockCommentListBySkuResults contains results of the IRepository.CommentListBySku
type IRepositoryMockCommentListBySkuResults struct {
	ca1 []model.Comment
	cp1 *model.Cursor
	err error
}

// IRepositoryMockCommentListBySkuOrigins contains origins of expectations of the IRepository.CommentListBySku
type IRepositoryMockCommentListBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originSku    string
	originCursor string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Optional() *mIRepositoryMockCommentListBySku {
	mmCommentListBySku.optional = true
	return mmCommentListBySku
}

// Expect sets up expected params for IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Expect(ctx context.Context, sku int64, cursor *model.Cursor) *mIRepositoryMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &IRepositoryMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by ExpectParams functions")
	}

	mmCommentListBySku.defaultExpectation.params = &IRepositoryMockCommentListBySkuParams{ctx, sku, cursor}
	mmCommentListBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentListBySku.expectations {
		if minimock.Equal(e.params, mmCommentListBySku.defaultExpectation.params) {
			mmCommentListBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentListBySku.defaultExpectation.params)
		}
	}

	return mmCommentListBySku
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &IRepositoryMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &IRepositoryMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentListBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// ExpectSkuParam2 sets up expected param sku for IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) ExpectSkuParam2(sku int64) *mIRepositoryMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &IRepositoryMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &IRepositoryMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.sku = &sku
	mmCommentListBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// ExpectCursorParam3 sets up expected param cursor for IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) ExpectCursorParam3(cursor *model.Cursor) *mIRepositoryMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &IRepositoryMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &IRepositoryMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.cursor = &cursor
	mmCommentListBySku.defaultExpectation.expectationOrigins.originCursor = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// Inspect accepts an inspector function that has same arguments as the IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Inspect(f func(ctx context.Context, sku int64, cursor *model.Cursor)) *mIRepositoryMockCommentListBySku {
	if mmCommentListBySku.mock.inspectFuncCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.CommentListBySku")
	}

	mmCommentListBySku.mock.inspectFuncCommentListBySku = f

	return mmCommentListBySku
}

// Return sets up results that will be returned by IRepository.CommentListBySku
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Return(ca1 []model.Comment, cp1 *model.Cursor, err error) *IRepositoryMock {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &IRepositoryMockCommentListBySkuExpectation{mock: mmCommentListBySku.mock}
	}
	mmCommentListBySku.defaultExpectation.results = &IRepositoryMockCommentListBySkuResults{ca1, cp1, err}
	mmCommentListBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku.mock
}

// Set uses given function f to mock the IRepository.CommentListBySku method
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Set(f func(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error)) *IRepositoryMock {
	if mmCommentListBySku.defaultExpectation != nil {
		mmCommentListBySku.mock.t.Fatalf("Default expectation is already set for the IRepository.CommentListBySku method")
	}

	if len(mmCommentListBySku.expectations) > 0 {
		mmCommentListBySku.mock.t.Fatalf("Some expectations are already set for the IRepository.CommentListBySku method")
	}

	mmCommentListBySku.mock.funcCommentListBySku = f
	mmCommentListBySku.mock.funcCommentListBySkuOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku.mock
}

// When sets expectation for the IRepository.CommentListBySku which will trigger the result defined by the following
// Then helper
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) When(ctx context.Context, sku int64, cursor *model.Cursor) *IRepositoryMockCommentListBySkuExpectation {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("IRepositoryMock.CommentListBySku mock is already set by Set")
	}

	expectation := &IRepositoryMockCommentListBySkuExpectation{
		mock:               mmCommentListBySku.mock,
		params:             &IRepositoryMockCommentListBySkuParams{ctx, sku, cursor},
		expectationOrigins: IRepositoryMockCommentListBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentListBySku.expectations = append(mmCommentListBySku.expectations, expectation)
	return expectation
}

// Then sets up IRepository.CommentListBySku return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockCommentListBySkuExpectation) Then(ca1 []model.Comment, cp1 *model.Cursor, err error) *IRepositoryMock {
	e.results = &IRepositoryMockCommentListBySkuResults{ca1, cp1, err}
	return e.mock
}

// Times sets number of times IRepository.CommentListBySku should be invoked
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Times(n uint64) *mIRepositoryMockCommentListBySku {
	if n == 0 {
		mmCommentListBySku.mock.t.Fatalf("Times of IRepositoryMock.CommentListBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentListBySku.expectedInvocations, n)
	mmCommentListBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku
}

func (mmCommentListBySku *mIRepositoryMockCommentListBySku) invocationsDone() bool {
	if len(mmCommentListBySku.expectations) == 0 && mmCommentListBySku.defaultExpectation == nil && mmCommentListBySku.mock.funcCommentListBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentListBySku.mock.afterCommentListBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentListBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentListBySku implements mm_service.IRepository
func (mmCommentListBySku *IRepositoryMock) CommentListBySku(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error) {
	mm_atomic.AddUint64(&mmCommentListBySku.beforeCommentListBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentListBySku.afterCommentListBySkuCounter, 1)

	mmCommentListBySku.t.Helper()

	if mmCommentListBySku.inspectFuncCommentListBySku != nil {
		mmCommentListBySku.inspectFuncCommentListBySku(ctx, sku, cursor)
	}

	mm_params := IRepositoryMockCommentListBySkuParams{ctx, sku, cursor}

	// Record call args
	mmCommentListBySku.CommentListBySkuMock.mutex.Lock()
	mmCommentListBySku.CommentListBySkuMock.callArgs = append(mmCommentListBySku.CommentListBySkuMock.callArgs, &mm_params)
	mmCommentListBySku.CommentListBySkuMock.mutex.Unlock()

	for _, e := range mmCommentListBySku.CommentListBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.cp1, e.results.err
		}
	}

	if mmCommentListBySku.CommentListBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentListBySku.CommentListBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockCommentListBySkuParams{ctx, sku, cursor}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentListBySku.t.Errorf("IRepositoryMock.CommentListBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmCommentListBySku.t.Errorf("IRepositoryMock.CommentListBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.cursor != nil && !minimock.Equal(*mm_want_ptrs.cursor, mm_got.cursor) {
				mmCommentListBySku.t.Errorf("IRepositoryMock.CommentListBySku got unexpected parameter cursor, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originCursor, *mm_want_ptrs.cursor, mm_got.cursor, minimock.Diff(*mm_want_ptrs.cursor, mm_got.cursor))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentListBySku.t.Errorf("IRepositoryMock.CommentListBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentListBySku.t.Fatal("No results are set for the IRepositoryMock.CommentListBySku")
		}
		return (*mm_results).ca1, (*mm_results).cp1, (*mm_results).err
	}
	if mmCommentListBySku.funcCommentListBySku != nil {
		return mmCommentListBySku.funcCommentListBySku(ctx, sku, cursor)
	}
	mmCommentListBySku.t.Fatalf("Unexpected call to IRepositoryMock.CommentListBySku. %v %v %v", ctx, sku, cursor)
	return
}

// CommentListBySkuAfterCounter returns a count of finished IRepositoryMock.CommentListBySku invocations
func (mmCommentListBySku *IRepositoryMock) CommentListBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListBySku.afterCommentListBySkuCounter)
}

// CommentListBySkuBeforeCounter returns a count of IRepositoryMock.CommentListBySku invocations
func (mmCommentListBySku *IRepositoryMock) CommentListBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListBySku.beforeCommentListBySkuCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.CommentListBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentListBySku *mIRepositoryMockCommentListBySku) Calls() []*IRepositoryMockCommentListBySkuParams {
	mmCommentListBySku.mutex.RLock()

	argCopy := make([]*IRepositoryMockCommentListBySkuParams, len(mmCommentListBySku.callArgs))
	copy(argCopy, mmCommentListBySku.callArgs)

	mmCommentListBySku.mutex.RUnlock()

	return argCopy
}

// MinimockCommentListBySkuDone returns true if the count of the CommentListBySku invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockCommentListBySkuDone() bool {
	if m.CommentListBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentListBySkuMock.invocationsDone()
}

// MinimockCommentListBySkuInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockCommentListBySkuInspect() {
	for _, e := range m.CommentListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentListBySkuCounter := mm_atomic.LoadUint64(&m.afterCommentListBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentListBySkuMock.defaultExpectation != nil && afterCommentListBySkuCounter < 1 {
		if m.CommentListBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListBySku at\n%s", m.CommentListBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListBySku at\n%s with params: %#v", m.CommentListBySkuMock.defaultExpectation.expectationOrigins.origin, *m.CommentListBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentListBySku != nil && afterCommentListBySkuCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.CommentListBySku at\n%s", m.funcCommentListBySkuOrigin)
	}

	if !m.CommentListBySkuMock.invocationsDone() && afterCommentListBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.CommentListBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentListBySkuMock.expectedInvocations), m.CommentListBySkuMock.expectedInvocationsOrigin, afterCommentListBySkuCounter)
	}
}

type mIRepositoryMockCommentListByUser struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockCommentListByUserExpectation
	expectations       []*IRepositoryMockCommentListByUserExpectation

	callArgs []*IRepositoryMockCommentListByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockCommentListByUserExpectation specifies expectation struct of the IRepository.CommentListByUser
type IRepositoryMockCommentListByUserExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockCommentListByUserParams
	paramPtrs          *IRepositoryMockCommentListByUserParamPtrs
	expectationOrigins IRepositoryMockCommentListByUserExpectationOrigins
	results            *IRepositoryMockCommentListByUserResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockCommentListByUserParams contains parameters of the IRepository.CommentListByUser
type IRepositoryMockCommentListByUserParams struct {
	ctx    context.Context
	userID int64
}

// IRepositoryMockCommentListByUserParamPtrs contains pointers to parameters of the IRepository.CommentListByUser
type IRepositoryMockCommentListByUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// IRepositoryMockCommentListByUserResults contains results of the IRepository.CommentListByUser
type IRepositoryMockCommentListByUserResults struct {
	ca1 []model.Comment
	err error
}

// IRepositoryMockCommentListByUserOrigins contains origins of expectations of the IRepository.CommentListByUser
type IRepositoryMockCommentListByUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Optional() *mIRepositoryMockCommentListByUser {
	mmCommentListByUser.optional = true
	return mmCommentListByUser
}

// Expect sets up expected params for IRepository.CommentListByUser
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Expect(ctx context.Context, userID int64) *mIRepositoryMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &IRepositoryMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by ExpectParams functions")
	}

	mmCommentListByUser.defaultExpectation.params = &IRepositoryMockCommentListByUserParams{ctx, userID}
	mmCommentListByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentListByUser.expectations {
		if minimock.Equal(e.params, mmCommentListByUser.defaultExpectation.params) {
			mmCommentListByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentListByUser.defaultExpectation.params)
		}
	}

	return mmCommentListByUser
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.CommentListByUser
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &IRepositoryMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.params != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Expect")
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs == nil {
		mmCommentListByUser.defaultExpectation.paramPtrs = &IRepositoryMockCommentListByUserParamPtrs{}
	}
	mmCommentListByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentListByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentListByUser
}

// ExpectUserIDParam2 sets up expected param userID for IRepository.CommentListByUser
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) ExpectUserIDParam2(userID int64) *mIRepositoryMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &IRepositoryMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.params != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Expect")
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs == nil {
		mmCommentListByUser.defaultExpectation.paramPtrs = &IRepositoryMockCommentListByUserParamPtrs{}
	}
	mmCommentListByUser.defaultExpectation.paramPtrs.userID = &userID
	mmCommentListByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCommentListByUser
}

// Inspect accepts an inspector function that has same arguments as the IRepository.CommentListByUser
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Inspect(f func(ctx context.Context, userID int64)) *mIRepositoryMockCommentListByUser {
	if mmCommentListByUser.mock.inspectFuncCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.CommentListByUser")
	}

	mmCommentListByUser.mock.inspectFuncCommentListByUser = f

	return mmCommentListByUser
}

// Return sets up results that will be returned by IRepository.CommentListByUser
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Return(ca1 []model.Comment, err error) *IRepositoryMock {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &IRepositoryMockCommentListByUserExpectation{mock: mmCommentListByUser.mock}
	}
	mmCommentListByUser.defaultExpectation.results = &IRepositoryMockCommentListByUserResults{ca1, err}
	mmCommentListByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser.mock
}

// Set uses given function f to mock the IRepository.CommentListByUser method
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Set(f func(ctx context.Context, userID int64) (ca1 []model.Comment, err error)) *IRepositoryMock {
	if mmCommentListByUser.defaultExpectation != nil {
		mmCommentListByUser.mock.t.Fatalf("Default expectation is already set for the IRepository.CommentListByUser method")
	}

	if len(mmCommentListByUser.expectations) > 0 {
		mmCommentListByUser.mock.t.Fatalf("Some expectations are already set for the IRepository.CommentListByUser method")
	}

	mmCommentListByUser.mock.funcCommentListByUser = f
	mmCommentListByUser.mock.funcCommentListByUserOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser.mock
}

// When sets expectation for the IRepository.CommentListByUser which will trigger the result defined by the following
// Then helper
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) When(ctx context.Context, userID int64) *IRepositoryMockCommentListByUserExpectation {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("IRepositoryMock.CommentListByUser mock is already set by Set")
	}

	expectation := &IRepositoryMockCommentListByUserExpectation{
		mock:               mmCommentListByUser.mock,
		params:             &IRepositoryMockCommentListByUserParams{ctx, userID},
		expectationOrigins: IRepositoryMockCommentListByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentListByUser.expectations = append(mmCommentListByUser.expectations, expectation)
	return expectation
}

// Then sets up IRepository.CommentListByUser return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockCommentListByUserExpectation) Then(ca1 []model.Comment, err error) *IRepositoryMock {
	e.results = &IRepositoryMockCommentListByUserResults{ca1, err}
	return e.mock
}

// Times sets number of times IRepository.CommentListByUser should be invoked
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Times(n uint64) *mIRepositoryMockCommentListByUser {
	if n == 0 {
		mmCommentListByUser.mock.t.Fatalf("Times of IRepositoryMock.CommentListByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentListByUser.expectedInvocations, n)
	mmCommentListByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser
}

func (mmCommentListByUser *mIRepositoryMockCommentListByUser) invocationsDone() bool {
	if len(mmCommentListByUser.expectations) == 0 && mmCommentListByUser.defaultExpectation == nil && mmCommentListByUser.mock.funcCommentListByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentListByUser.mock.afterCommentListByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentListByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentListByUser implements mm_service.IRepository
func (mmCommentListByUser *IRepositoryMock) CommentListByUser(ctx context.Context, userID int64) (ca1 []model.Comment, err error) {
	mm_atomic.AddUint64(&mmCommentListByUser.beforeCommentListByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentListByUser.afterCommentListByUserCounter, 1)

	mmCommentListByUser.t.Helper()

	if mmCommentListByUser.inspectFuncCommentListByUser != nil {
		mmCommentListByUser.inspectFuncCommentListByUser(ctx, userID)
	}

	mm_params := IRepositoryMockCommentListByUserParams{ctx, userID}

	// Record call args
	mmCommentListByUser.CommentListByUserMock.mutex.Lock()
	mmCommentListByUser.CommentListByUserMock.callArgs = append(mmCommentListByUser.CommentListByUserMock.callArgs, &mm_params)
	mmCommentListByUser.CommentListByUserMock.mutex.Unlock()

	for _, e := range mmCommentListByUser.CommentListByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmCommentListByUser.CommentListByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentListByUser.CommentListByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentListByUser.CommentListByUserMock.defaultExpectation.params
		mm_want_ptrs := mmCommentListByUser.CommentListByUserMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockCommentListByUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentListByUser.t.Errorf("IRepositoryMock.CommentListByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCommentListByUser.t.Errorf("IRepositoryMock.CommentListByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentListByUser.t.Errorf("IRepositoryMock.CommentListByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentListByUser.CommentListByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentListByUser.t.Fatal("No results are set for the IRepositoryMock.CommentListByUser")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmCommentListByUser.funcCommentListByUser != nil {
		return mmCommentListByUser.funcCommentListByUser(ctx, userID)
	}
	mmCommentListByUser.t.Fatalf("Unexpected call to IRepositoryMock.CommentListByUser. %v %v", ctx, userID)
	return
}

// CommentListByUserAfterCounter returns a count of finished IRepositoryMock.CommentListByUser invocations
func (mmCommentListByUser *IRepositoryMock) CommentListByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListByUser.afterCommentListByUserCounter)
}

// CommentListByUserBeforeCounter returns a count of IRepositoryMock.CommentListByUser invocations
func (mmCommentListByUser *IRepositoryMock) CommentListByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListByUser.beforeCommentListByUserCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.CommentListByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentListByUser *mIRepositoryMockCommentListByUser) Calls() []*IRepositoryMockCommentListByUserParams {
	mmCommentListByUser.mutex.RLock()

	argCopy := make([]*IRepositoryMockCommentListByUserParams, len(mmCommentListByUser.callArgs))
	copy(argCopy, mmCommentListByUser.callArgs)

	mmCommentListByUser.mutex.RUnlock()

	return argCopy
}

// MinimockCommentListByUserDone returns true if the count of the CommentListByUser invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockCommentListByUserDone() bool {
	if m.CommentListByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentListByUserMock.invocationsDone()
}

// MinimockCommentListByUserInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockCommentListByUserInspect() {
	for _, e := range m.CommentListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentListByUserCounter := mm_atomic.LoadUint64(&m.afterCommentListByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentListByUserMock.defaultExpectation != nil && afterCommentListByUserCounter < 1 {
		if m.CommentListByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListByUser at\n%s", m.CommentListByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.CommentListByUser at\n%s with params: %#v", m.CommentListByUserMock.defaultExpectation.expectationOrigins.origin, *m.CommentListByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentListByUser != nil && afterCommentListByUserCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.CommentListByUser at\n%s", m.funcCommentListByUserOrigin)
	}

	if !m.CommentListByUserMock.invocationsDone() && afterCommentListByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.CommentListByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentListByUserMock.expectedInvocations), m.CommentListByUserMock.expectedInvocationsOrigin, afterCommentListByUserCounter)
	}
}

type mIRepositoryMockEditComment struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockEditCommentExpectation
	expectations       []*IRepositoryMockEditCommentExpectation

	callArgs []*IRepositoryMockEditCommentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockEditCommentExpectation specifies expectation struct of the IRepository.EditComment
type IRepositoryMockEditCommentExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockEditCommentParams
	paramPtrs          *IRepositoryMockEditCommentParamPtrs
	expectationOrigins IRepositoryMockEditCommentExpectationOrigins
	results            *IRepositoryMockEditCommentResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockEditCommentParams contains parameters of the IRepository.EditComment
type IRepositoryMockEditCommentParams struct {
	ctx     context.Context
	comment model.Comment
}

// IRepositoryMockEditCommentParamPtrs contains pointers to parameters of the IRepository.EditComment
type IRepositoryMockEditCommentParamPtrs struct {
	ctx     *context.Context
	comment *model.Comment
}

// IRepositoryMockEditCommentResults contains results of the IRepository.EditComment
type IRepositoryMockEditCommentResults struct {
	err error
}

// IRepositoryMockEditCommentOrigins contains origins of expectations of the IRepository.EditComment
type IRepositoryMockEditCommentExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmEditComment *mIRepositoryMockEditComment) Optional() *mIRepositoryMockEditComment {
	mmEditComment.optional = true
	return mmEditComment
}

// Expect sets up expected params for IRepository.EditComment
func (mmEditComment *mIRepositoryMockEditComment) Expect(ctx context.Context, comment model.Comment) *mIRepositoryMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &IRepositoryMockEditCommentExpectation{}
	}

	if mmEditComment.defaultExpectation.paramPtrs != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by ExpectParams functions")
	}

	mmEditComment.defaultExpectation.params = &IRepositoryMockEditCommentParams{ctx, comment}
	mmEditComment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmEditComment.expectations {
		if minimock.Equal(e.params, mmEditComment.defaultExpectation.params) {
			mmEditComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmEditComment.defaultExpectation.params)
		}
	}

	return mmEditComment
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.EditComment
func (mmEditComment *mIRepositoryMockEditComment) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &IRepositoryMockEditCommentExpectation{}
	}

	if mmEditComment.defaultExpectation.params != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Expect")
	}

	if mmEditComment.defaultExpectation.paramPtrs == nil {
		mmEditComment.defaultExpectation.paramPtrs = &IRepositoryMockEditCommentParamPtrs{}
	}
	mmEditComment.defaultExpectation.paramPtrs.ctx = &ctx
	mmEditComment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmEditComment
}

// ExpectCommentParam2 sets up expected param comment for IRepository.EditComment
func (mmEditComment *mIRepositoryMockEditComment) ExpectCommentParam2(comment model.Comment) *mIRepositoryMockEditComment {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &IRepositoryMockEditCommentExpectation{}
	}

	if mmEditComment.defaultExpectation.params != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Expect")
	}

	if mmEditComment.defaultExpectation.paramPtrs == nil {
		mmEditComment.defaultExpectation.paramPtrs = &IRepositoryMockEditCommentParamPtrs{}
	}
	mmEditComment.defaultExpectation.paramPtrs.comment = &comment
	mmEditComment.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmEditComment
}

// Inspect accepts an inspector function that has same arguments as the IRepository.EditComment
func (mmEditComment *mIRepositoryMockEditComment) Inspect(f func(ctx context.Context, comment model.Comment)) *mIRepositoryMockEditComment {
	if mmEditComment.mock.inspectFuncEditComment != nil {
		mmEditComment.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.EditComment")
	}

	mmEditComment.mock.inspectFuncEditComment = f

	return mmEditComment
}

// Return sets up results that will be returned by IRepository.EditComment
func (mmEditComment *mIRepositoryMockEditComment) Return(err error) *IRepositoryMock {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Set")
	}

	if mmEditComment.defaultExpectation == nil {
		mmEditComment.defaultExpectation = &IRepositoryMockEditCommentExpectation{mock: mmEditComment.mock}
	}
	mmEditComment.defaultExpectation.results = &IRepositoryMockEditCommentResults{err}
	mmEditComment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmEditComment.mock
}

// Set uses given function f to mock the IRepository.EditComment method
func (mmEditComment *mIRepositoryMockEditComment) Set(f func(ctx context.Context, comment model.Comment) (err error)) *IRepositoryMock {
	if mmEditComment.defaultExpectation != nil {
		mmEditComment.mock.t.Fatalf("Default expectation is already set for the IRepository.EditComment method")
	}

	if len(mmEditComment.expectations) > 0 {
		mmEditComment.mock.t.Fatalf("Some expectations are already set for the IRepository.EditComment method")
	}

	mmEditComment.mock.funcEditComment = f
	mmEditComment.mock.funcEditCommentOrigin = minimock.CallerInfo(1)
	return mmEditComment.mock
}

// When sets expectation for the IRepository.EditComment which will trigger the result defined by the following
// Then helper
func (mmEditComment *mIRepositoryMockEditComment) When(ctx context.Context, comment model.Comment) *IRepositoryMockEditCommentExpectation {
	if mmEditComment.mock.funcEditComment != nil {
		mmEditComment.mock.t.Fatalf("IRepositoryMock.EditComment mock is already set by Set")
	}

	expectation := &IRepositoryMockEditCommentExpectation{
		mock:               mmEditComment.mock,
		params:             &IRepositoryMockEditCommentParams{ctx, comment},
		expectationOrigins: IRepositoryMockEditCommentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmEditComment.expectations = append(mmEditComment.expectations, expectation)
	return expectation
}

// Then sets up IRepository.EditComment return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockEditCommentExpectation) Then(err error) *IRepositoryMock {
	e.results = &IRepositoryMockEditCommentResults{err}
	return e.mock
}

// Times sets number of times IRepository.EditComment should be invoked
func (mmEditComment *mIRepositoryMockEditComment) Times(n uint64) *mIRepositoryMockEditComment {
	if n == 0 {
		mmEditComment.mock.t.Fatalf("Times of IRepositoryMock.EditComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmEditComment.expectedInvocations, n)
	mmEditComment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmEditComment
}

func (mmEditComment *mIRepositoryMockEditComment) invocationsDone() bool {
	if len(mmEditComment.expectations) == 0 && mmEditComment.defaultExpectation == nil && mmEditComment.mock.funcEditComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmEditComment.mock.afterEditCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmEditComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// EditComment implements mm_service.IRepository
func (mmEditComment *IRepositoryMock) EditComment(ctx context.Context, comment model.Comment) (err error) {
	mm_atomic.AddUint64(&mmEditComment.beforeEditCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmEditComment.afterEditCommentCounter, 1)

	mmEditComment.t.Helper()

	if mmEditComment.inspectFuncEditComment != nil {
		mmEditComment.inspectFuncEditComment(ctx, comment)
	}

	mm_params := IRepositoryMockEditCommentParams{ctx, comment}

	// Record call args
	mmEditComment.EditCommentMock.mutex.Lock()
	mmEditComment.EditCommentMock.callArgs = append(mmEditComment.EditCommentMock.callArgs, &mm_params)
	mmEditComment.EditCommentMock.mutex.Unlock()

	for _, e := range mmEditComment.EditCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmEditComment.EditCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEditComment.EditCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmEditComment.EditCommentMock.defaultExpectation.params
		mm_want_ptrs := mmEditComment.EditCommentMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockEditCommentParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmEditComment.t.Errorf("IRepositoryMock.EditComment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEditComment.EditCommentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmEditComment.t.Errorf("IRepositoryMock.EditComment got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmEditComment.EditCommentMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmEditComment.t.Errorf("IRepositoryMock.EditComment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmEditComment.EditCommentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmEditComment.EditCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmEditComment.t.Fatal("No results are set for the IRepositoryMock.EditComment")
		}
		return (*mm_results).err
	}
	if mmEditComment.funcEditComment != nil {
		return mmEditComment.funcEditComment(ctx, comment)
	}
	mmEditComment.t.Fatalf("Unexpected call to IRepositoryMock.EditComment. %v %v", ctx, comment)
	return
}

// EditCommentAfterCounter returns a count of finished IRepositoryMock.EditComment invocations
func (mmEditComment *IRepositoryMock) EditCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.afterEditCommentCounter)
}

// EditCommentBeforeCounter returns a count of IRepositoryMock.EditComment invocations
func (mmEditComment *IRepositoryMock) EditCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEditComment.beforeEditCommentCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.EditComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmEditComment *mIRepositoryMockEditComment) Calls() []*IRepositoryMockEditCommentParams {
	mmEditComment.mutex.RLock()

	argCopy := make([]*IRepositoryMockEditCommentParams, len(mmEditComment.callArgs))
	copy(argCopy, mmEditComment.callArgs)

	mmEditComment.mutex.RUnlock()

	return argCopy
}

// MinimockEditCommentDone returns true if the count of the EditComment invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockEditCommentDone() bool {
	if m.EditCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.EditCommentMock.invocationsDone()
}

// MinimockEditCommentInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockEditCommentInspect() {
	for _, e := range m.EditCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.EditComment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterEditCommentCounter := mm_atomic.LoadUint64(&m.afterEditCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.EditCommentMock.defaultExpectation != nil && afterEditCommentCounter < 1 {
		if m.EditCommentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.EditComment at\n%s", m.EditCommentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.EditComment at\n%s with params: %#v", m.EditCommentMock.defaultExpectation.expectationOrigins.origin, *m.EditCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEditComment != nil && afterEditCommentCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.EditComment at\n%s", m.funcEditCommentOrigin)
	}

	if !m.EditCommentMock.invocationsDone() && afterEditCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.EditComment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.EditCommentMock.expectedInvocations), m.EditCommentMock.expectedInvocationsOrigin, afterEditCommentCounter)
	}
}

type mIRepositoryMockGetCommentByID struct {
	optional           bool
	mock               *IRepositoryMock
	defaultExpectation *IRepositoryMockGetCommentByIDExpectation
	expectations       []*IRepositoryMockGetCommentByIDExpectation

	callArgs []*IRepositoryMockGetCommentByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IRepositoryMockGetCommentByIDExpectation specifies expectation struct of the IRepository.GetCommentByID
type IRepositoryMockGetCommentByIDExpectation struct {
	mock               *IRepositoryMock
	params             *IRepositoryMockGetCommentByIDParams
	paramPtrs          *IRepositoryMockGetCommentByIDParamPtrs
	expectationOrigins IRepositoryMockGetCommentByIDExpectationOrigins
	results            *IRepositoryMockGetCommentByIDResults
	returnOrigin       string
	Counter            uint64
}

// IRepositoryMockGetCommentByIDParams contains parameters of the IRepository.GetCommentByID
type IRepositoryMockGetCommentByIDParams struct {
	ctx       context.Context
	commentID int64
}

// IRepositoryMockGetCommentByIDParamPtrs contains pointers to parameters of the IRepository.GetCommentByID
type IRepositoryMockGetCommentByIDParamPtrs struct {
	ctx       *context.Context
	commentID *int64
}

// IRepositoryMockGetCommentByIDResults contains results of the IRepository.GetCommentByID
type IRepositoryMockGetCommentByIDResults struct {
	cp1 *model.Comment
	err error
}

// IRepositoryMockGetCommentByIDOrigins contains origins of expectations of the IRepository.GetCommentByID
type IRepositoryMockGetCommentByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originCommentID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Optional() *mIRepositoryMockGetCommentByID {
	mmGetCommentByID.optional = true
	return mmGetCommentByID
}

// Expect sets up expected params for IRepository.GetCommentByID
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Expect(ctx context.Context, commentID int64) *mIRepositoryMockGetCommentByID {
	if mmGetCommentByID.mock.funcGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Set")
	}

	if mmGetCommentByID.defaultExpectation == nil {
		mmGetCommentByID.defaultExpectation = &IRepositoryMockGetCommentByIDExpectation{}
	}

	if mmGetCommentByID.defaultExpectation.paramPtrs != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by ExpectParams functions")
	}

	mmGetCommentByID.defaultExpectation.params = &IRepositoryMockGetCommentByIDParams{ctx, commentID}
	mmGetCommentByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentByID.expectations {
		if minimock.Equal(e.params, mmGetCommentByID.defaultExpectation.params) {
			mmGetCommentByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentByID.defaultExpectation.params)
		}
	}

	return mmGetCommentByID
}

// ExpectCtxParam1 sets up expected param ctx for IRepository.GetCommentByID
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) ExpectCtxParam1(ctx context.Context) *mIRepositoryMockGetCommentByID {
	if mmGetCommentByID.mock.funcGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Set")
	}

	if mmGetCommentByID.defaultExpectation == nil {
		mmGetCommentByID.defaultExpectation = &IRepositoryMockGetCommentByIDExpectation{}
	}

	if mmGetCommentByID.defaultExpectation.params != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Expect")
	}

	if mmGetCommentByID.defaultExpectation.paramPtrs == nil {
		mmGetCommentByID.defaultExpectation.paramPtrs = &IRepositoryMockGetCommentByIDParamPtrs{}
	}
	mmGetCommentByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentByID
}

// ExpectCommentIDParam2 sets up expected param commentID for IRepository.GetCommentByID
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) ExpectCommentIDParam2(commentID int64) *mIRepositoryMockGetCommentByID {
	if mmGetCommentByID.mock.funcGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Set")
	}

	if mmGetCommentByID.defaultExpectation == nil {
		mmGetCommentByID.defaultExpectation = &IRepositoryMockGetCommentByIDExpectation{}
	}

	if mmGetCommentByID.defaultExpectation.params != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Expect")
	}

	if mmGetCommentByID.defaultExpectation.paramPtrs == nil {
		mmGetCommentByID.defaultExpectation.paramPtrs = &IRepositoryMockGetCommentByIDParamPtrs{}
	}
	mmGetCommentByID.defaultExpectation.paramPtrs.commentID = &commentID
	mmGetCommentByID.defaultExpectation.expectationOrigins.originCommentID = minimock.CallerInfo(1)

	return mmGetCommentByID
}

// Inspect accepts an inspector function that has same arguments as the IRepository.GetCommentByID
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Inspect(f func(ctx context.Context, commentID int64)) *mIRepositoryMockGetCommentByID {
	if mmGetCommentByID.mock.inspectFuncGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("Inspect function is already set for IRepositoryMock.GetCommentByID")
	}

	mmGetCommentByID.mock.inspectFuncGetCommentByID = f

	return mmGetCommentByID
}

// Return sets up results that will be returned by IRepository.GetCommentByID
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Return(cp1 *model.Comment, err error) *IRepositoryMock {
	if mmGetCommentByID.mock.funcGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Set")
	}

	if mmGetCommentByID.defaultExpectation == nil {
		mmGetCommentByID.defaultExpectation = &IRepositoryMockGetCommentByIDExpectation{mock: mmGetCommentByID.mock}
	}
	mmGetCommentByID.defaultExpectation.results = &IRepositoryMockGetCommentByIDResults{cp1, err}
	mmGetCommentByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentByID.mock
}

// Set uses given function f to mock the IRepository.GetCommentByID method
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Set(f func(ctx context.Context, commentID int64) (cp1 *model.Comment, err error)) *IRepositoryMock {
	if mmGetCommentByID.defaultExpectation != nil {
		mmGetCommentByID.mock.t.Fatalf("Default expectation is already set for the IRepository.GetCommentByID method")
	}

	if len(mmGetCommentByID.expectations) > 0 {
		mmGetCommentByID.mock.t.Fatalf("Some expectations are already set for the IRepository.GetCommentByID method")
	}

	mmGetCommentByID.mock.funcGetCommentByID = f
	mmGetCommentByID.mock.funcGetCommentByIDOrigin = minimock.CallerInfo(1)
	return mmGetCommentByID.mock
}

// When sets expectation for the IRepository.GetCommentByID which will trigger the result defined by the following
// Then helper
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) When(ctx context.Context, commentID int64) *IRepositoryMockGetCommentByIDExpectation {
	if mmGetCommentByID.mock.funcGetCommentByID != nil {
		mmGetCommentByID.mock.t.Fatalf("IRepositoryMock.GetCommentByID mock is already set by Set")
	}

	expectation := &IRepositoryMockGetCommentByIDExpectation{
		mock:               mmGetCommentByID.mock,
		params:             &IRepositoryMockGetCommentByIDParams{ctx, commentID},
		expectationOrigins: IRepositoryMockGetCommentByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentByID.expectations = append(mmGetCommentByID.expectations, expectation)
	return expectation
}

// Then sets up IRepository.GetCommentByID return parameters for the expectation previously defined by the When method
func (e *IRepositoryMockGetCommentByIDExpectation) Then(cp1 *model.Comment, err error) *IRepositoryMock {
	e.results = &IRepositoryMockGetCommentByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times IRepository.GetCommentByID should be invoked
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Times(n uint64) *mIRepositoryMockGetCommentByID {
	if n == 0 {
		mmGetCommentByID.mock.t.Fatalf("Times of IRepositoryMock.GetCommentByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentByID.expectedInvocations, n)
	mmGetCommentByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentByID
}

func (mmGetCommentByID *mIRepositoryMockGetCommentByID) invocationsDone() bool {
	if len(mmGetCommentByID.expectations) == 0 && mmGetCommentByID.defaultExpectation == nil && mmGetCommentByID.mock.funcGetCommentByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentByID.mock.afterGetCommentByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentByID implements mm_service.IRepository
func (mmGetCommentByID *IRepositoryMock) GetCommentByID(ctx context.Context, commentID int64) (cp1 *model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetCommentByID.beforeGetCommentByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentByID.afterGetCommentByIDCounter, 1)

	mmGetCommentByID.t.Helper()

	if mmGetCommentByID.inspectFuncGetCommentByID != nil {
		mmGetCommentByID.inspectFuncGetCommentByID(ctx, commentID)
	}

	mm_params := IRepositoryMockGetCommentByIDParams{ctx, commentID}

	// Record call args
	mmGetCommentByID.GetCommentByIDMock.mutex.Lock()
	mmGetCommentByID.GetCommentByIDMock.callArgs = append(mmGetCommentByID.GetCommentByIDMock.callArgs, &mm_params)
	mmGetCommentByID.GetCommentByIDMock.mutex.Unlock()

	for _, e := range mmGetCommentByID.GetCommentByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCommentByID.GetCommentByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentByID.GetCommentByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentByID.GetCommentByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentByID.GetCommentByIDMock.defaultExpectation.paramPtrs

		mm_got := IRepositoryMockGetCommentByIDParams{ctx, commentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentByID.t.Errorf("IRepositoryMock.GetCommentByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentByID.GetCommentByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.commentID != nil && !minimock.Equal(*mm_want_ptrs.commentID, mm_got.commentID) {
				mmGetCommentByID.t.Errorf("IRepositoryMock.GetCommentByID got unexpected parameter commentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentByID.GetCommentByIDMock.defaultExpectation.expectationOrigins.originCommentID, *mm_want_ptrs.commentID, mm_got.commentID, minimock.Diff(*mm_want_ptrs.commentID, mm_got.commentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentByID.t.Errorf("IRepositoryMock.GetCommentByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentByID.GetCommentByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentByID.GetCommentByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentByID.t.Fatal("No results are set for the IRepositoryMock.GetCommentByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCommentByID.funcGetCommentByID != nil {
		return mmGetCommentByID.funcGetCommentByID(ctx, commentID)
	}
	mmGetCommentByID.t.Fatalf("Unexpected call to IRepositoryMock.GetCommentByID. %v %v", ctx, commentID)
	return
}

// GetCommentByIDAfterCounter returns a count of finished IRepositoryMock.GetCommentByID invocations
func (mmGetCommentByID *IRepositoryMock) GetCommentByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentByID.afterGetCommentByIDCounter)
}

// GetCommentByIDBeforeCounter returns a count of IRepositoryMock.GetCommentByID invocations
func (mmGetCommentByID *IRepositoryMock) GetCommentByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentByID.beforeGetCommentByIDCounter)
}

// Calls returns a list of arguments used in each call to IRepositoryMock.GetCommentByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentByID *mIRepositoryMockGetCommentByID) Calls() []*IRepositoryMockGetCommentByIDParams {
	mmGetCommentByID.mutex.RLock()

	argCopy := make([]*IRepositoryMockGetCommentByIDParams, len(mmGetCommentByID.callArgs))
	copy(argCopy, mmGetCommentByID.callArgs)

	mmGetCommentByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentByIDDone returns true if the count of the GetCommentByID invocations corresponds
// the number of defined expectations
func (m *IRepositoryMock) MinimockGetCommentByIDDone() bool {
	if m.GetCommentByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentByIDMock.invocationsDone()
}

// MinimockGetCommentByIDInspect logs each unmet expectation
func (m *IRepositoryMock) MinimockGetCommentByIDInspect() {
	for _, e := range m.GetCommentByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IRepositoryMock.GetCommentByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentByIDCounter := mm_atomic.LoadUint64(&m.afterGetCommentByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentByIDMock.defaultExpectation != nil && afterGetCommentByIDCounter < 1 {
		if m.GetCommentByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IRepositoryMock.GetCommentByID at\n%s", m.GetCommentByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IRepositoryMock.GetCommentByID at\n%s with params: %#v", m.GetCommentByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentByID != nil && afterGetCommentByIDCounter < 1 {
		m.t.Errorf("Expected call to IRepositoryMock.GetCommentByID at\n%s", m.funcGetCommentByIDOrigin)
	}

	if !m.GetCommentByIDMock.invocationsDone() && afterGetCommentByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to IRepositoryMock.GetCommentByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentByIDMock.expectedInvocations), m.GetCommentByIDMock.expectedInvocationsOrigin, afterGetCommentByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCommentInspect()

			m.MinimockCloseInspect()

			m.MinimockCommentListBySkuInspect()

			m.MinimockCommentListByUserInspect()

			m.MinimockEditCommentInspect()

			m.MinimockGetCommentByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCommentDone() &&
		m.MinimockCloseDone() &&
		m.MinimockCommentListBySkuDone() &&
		m.MinimockCommentListByUserDone() &&
		m.MinimockEditCommentDone() &&
		m.MinimockGetCommentByIDDone()
}
