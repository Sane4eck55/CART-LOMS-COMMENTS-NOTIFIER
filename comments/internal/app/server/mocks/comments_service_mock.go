// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/comments/internal/app/server.CommentsService -o comments_service_mock.go -n CommentsServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Sane4eck55/CART-LOMS-COMMENTS-NOTIFIER/comments/internal/model"
	"github.com/gojuno/minimock/v3"
)

// CommentsServiceMock implements mm_server.CommentsService
type CommentsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCommentAdd          func(ctx context.Context, comment model.Comment) (i1 int64, err error)
	funcCommentAddOrigin    string
	inspectFuncCommentAdd   func(ctx context.Context, comment model.Comment)
	afterCommentAddCounter  uint64
	beforeCommentAddCounter uint64
	CommentAddMock          mCommentsServiceMockCommentAdd

	funcCommentEdit          func(ctx context.Context, comment model.Comment) (err error)
	funcCommentEditOrigin    string
	inspectFuncCommentEdit   func(ctx context.Context, comment model.Comment)
	afterCommentEditCounter  uint64
	beforeCommentEditCounter uint64
	CommentEditMock          mCommentsServiceMockCommentEdit

	funcCommentGetByID          func(ctx context.Context, commentID int64) (cp1 *model.Comment, err error)
	funcCommentGetByIDOrigin    string
	inspectFuncCommentGetByID   func(ctx context.Context, commentID int64)
	afterCommentGetByIDCounter  uint64
	beforeCommentGetByIDCounter uint64
	CommentGetByIDMock          mCommentsServiceMockCommentGetByID

	funcCommentListBySku          func(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error)
	funcCommentListBySkuOrigin    string
	inspectFuncCommentListBySku   func(ctx context.Context, sku int64, cursor *model.Cursor)
	afterCommentListBySkuCounter  uint64
	beforeCommentListBySkuCounter uint64
	CommentListBySkuMock          mCommentsServiceMockCommentListBySku

	funcCommentListByUser          func(ctx context.Context, userID int64) (ca1 []model.Comment, err error)
	funcCommentListByUserOrigin    string
	inspectFuncCommentListByUser   func(ctx context.Context, userID int64)
	afterCommentListByUserCounter  uint64
	beforeCommentListByUserCounter uint64
	CommentListByUserMock          mCommentsServiceMockCommentListByUser
}

// NewCommentsServiceMock returns a mock for mm_server.CommentsService
func NewCommentsServiceMock(t minimock.Tester) *CommentsServiceMock {
	m := &CommentsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CommentAddMock = mCommentsServiceMockCommentAdd{mock: m}
	m.CommentAddMock.callArgs = []*CommentsServiceMockCommentAddParams{}

	m.CommentEditMock = mCommentsServiceMockCommentEdit{mock: m}
	m.CommentEditMock.callArgs = []*CommentsServiceMockCommentEditParams{}

	m.CommentGetByIDMock = mCommentsServiceMockCommentGetByID{mock: m}
	m.CommentGetByIDMock.callArgs = []*CommentsServiceMockCommentGetByIDParams{}

	m.CommentListBySkuMock = mCommentsServiceMockCommentListBySku{mock: m}
	m.CommentListBySkuMock.callArgs = []*CommentsServiceMockCommentListBySkuParams{}

	m.CommentListByUserMock = mCommentsServiceMockCommentListByUser{mock: m}
	m.CommentListByUserMock.callArgs = []*CommentsServiceMockCommentListByUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommentsServiceMockCommentAdd struct {
	optional           bool
	mock               *CommentsServiceMock
	defaultExpectation *CommentsServiceMockCommentAddExpectation
	expectations       []*CommentsServiceMockCommentAddExpectation

	callArgs []*CommentsServiceMockCommentAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentsServiceMockCommentAddExpectation specifies expectation struct of the CommentsService.CommentAdd
type CommentsServiceMockCommentAddExpectation struct {
	mock               *CommentsServiceMock
	params             *CommentsServiceMockCommentAddParams
	paramPtrs          *CommentsServiceMockCommentAddParamPtrs
	expectationOrigins CommentsServiceMockCommentAddExpectationOrigins
	results            *CommentsServiceMockCommentAddResults
	returnOrigin       string
	Counter            uint64
}

// CommentsServiceMockCommentAddParams contains parameters of the CommentsService.CommentAdd
type CommentsServiceMockCommentAddParams struct {
	ctx     context.Context
	comment model.Comment
}

// CommentsServiceMockCommentAddParamPtrs contains pointers to parameters of the CommentsService.CommentAdd
type CommentsServiceMockCommentAddParamPtrs struct {
	ctx     *context.Context
	comment *model.Comment
}

// CommentsServiceMockCommentAddResults contains results of the CommentsService.CommentAdd
type CommentsServiceMockCommentAddResults struct {
	i1  int64
	err error
}

// CommentsServiceMockCommentAddOrigins contains origins of expectations of the CommentsService.CommentAdd
type CommentsServiceMockCommentAddExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Optional() *mCommentsServiceMockCommentAdd {
	mmCommentAdd.optional = true
	return mmCommentAdd
}

// Expect sets up expected params for CommentsService.CommentAdd
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Expect(ctx context.Context, comment model.Comment) *mCommentsServiceMockCommentAdd {
	if mmCommentAdd.mock.funcCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Set")
	}

	if mmCommentAdd.defaultExpectation == nil {
		mmCommentAdd.defaultExpectation = &CommentsServiceMockCommentAddExpectation{}
	}

	if mmCommentAdd.defaultExpectation.paramPtrs != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by ExpectParams functions")
	}

	mmCommentAdd.defaultExpectation.params = &CommentsServiceMockCommentAddParams{ctx, comment}
	mmCommentAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentAdd.expectations {
		if minimock.Equal(e.params, mmCommentAdd.defaultExpectation.params) {
			mmCommentAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentAdd.defaultExpectation.params)
		}
	}

	return mmCommentAdd
}

// ExpectCtxParam1 sets up expected param ctx for CommentsService.CommentAdd
func (mmCommentAdd *mCommentsServiceMockCommentAdd) ExpectCtxParam1(ctx context.Context) *mCommentsServiceMockCommentAdd {
	if mmCommentAdd.mock.funcCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Set")
	}

	if mmCommentAdd.defaultExpectation == nil {
		mmCommentAdd.defaultExpectation = &CommentsServiceMockCommentAddExpectation{}
	}

	if mmCommentAdd.defaultExpectation.params != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Expect")
	}

	if mmCommentAdd.defaultExpectation.paramPtrs == nil {
		mmCommentAdd.defaultExpectation.paramPtrs = &CommentsServiceMockCommentAddParamPtrs{}
	}
	mmCommentAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentAdd
}

// ExpectCommentParam2 sets up expected param comment for CommentsService.CommentAdd
func (mmCommentAdd *mCommentsServiceMockCommentAdd) ExpectCommentParam2(comment model.Comment) *mCommentsServiceMockCommentAdd {
	if mmCommentAdd.mock.funcCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Set")
	}

	if mmCommentAdd.defaultExpectation == nil {
		mmCommentAdd.defaultExpectation = &CommentsServiceMockCommentAddExpectation{}
	}

	if mmCommentAdd.defaultExpectation.params != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Expect")
	}

	if mmCommentAdd.defaultExpectation.paramPtrs == nil {
		mmCommentAdd.defaultExpectation.paramPtrs = &CommentsServiceMockCommentAddParamPtrs{}
	}
	mmCommentAdd.defaultExpectation.paramPtrs.comment = &comment
	mmCommentAdd.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmCommentAdd
}

// Inspect accepts an inspector function that has same arguments as the CommentsService.CommentAdd
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Inspect(f func(ctx context.Context, comment model.Comment)) *mCommentsServiceMockCommentAdd {
	if mmCommentAdd.mock.inspectFuncCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("Inspect function is already set for CommentsServiceMock.CommentAdd")
	}

	mmCommentAdd.mock.inspectFuncCommentAdd = f

	return mmCommentAdd
}

// Return sets up results that will be returned by CommentsService.CommentAdd
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Return(i1 int64, err error) *CommentsServiceMock {
	if mmCommentAdd.mock.funcCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Set")
	}

	if mmCommentAdd.defaultExpectation == nil {
		mmCommentAdd.defaultExpectation = &CommentsServiceMockCommentAddExpectation{mock: mmCommentAdd.mock}
	}
	mmCommentAdd.defaultExpectation.results = &CommentsServiceMockCommentAddResults{i1, err}
	mmCommentAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentAdd.mock
}

// Set uses given function f to mock the CommentsService.CommentAdd method
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Set(f func(ctx context.Context, comment model.Comment) (i1 int64, err error)) *CommentsServiceMock {
	if mmCommentAdd.defaultExpectation != nil {
		mmCommentAdd.mock.t.Fatalf("Default expectation is already set for the CommentsService.CommentAdd method")
	}

	if len(mmCommentAdd.expectations) > 0 {
		mmCommentAdd.mock.t.Fatalf("Some expectations are already set for the CommentsService.CommentAdd method")
	}

	mmCommentAdd.mock.funcCommentAdd = f
	mmCommentAdd.mock.funcCommentAddOrigin = minimock.CallerInfo(1)
	return mmCommentAdd.mock
}

// When sets expectation for the CommentsService.CommentAdd which will trigger the result defined by the following
// Then helper
func (mmCommentAdd *mCommentsServiceMockCommentAdd) When(ctx context.Context, comment model.Comment) *CommentsServiceMockCommentAddExpectation {
	if mmCommentAdd.mock.funcCommentAdd != nil {
		mmCommentAdd.mock.t.Fatalf("CommentsServiceMock.CommentAdd mock is already set by Set")
	}

	expectation := &CommentsServiceMockCommentAddExpectation{
		mock:               mmCommentAdd.mock,
		params:             &CommentsServiceMockCommentAddParams{ctx, comment},
		expectationOrigins: CommentsServiceMockCommentAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentAdd.expectations = append(mmCommentAdd.expectations, expectation)
	return expectation
}

// Then sets up CommentsService.CommentAdd return parameters for the expectation previously defined by the When method
func (e *CommentsServiceMockCommentAddExpectation) Then(i1 int64, err error) *CommentsServiceMock {
	e.results = &CommentsServiceMockCommentAddResults{i1, err}
	return e.mock
}

// Times sets number of times CommentsService.CommentAdd should be invoked
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Times(n uint64) *mCommentsServiceMockCommentAdd {
	if n == 0 {
		mmCommentAdd.mock.t.Fatalf("Times of CommentsServiceMock.CommentAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentAdd.expectedInvocations, n)
	mmCommentAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentAdd
}

func (mmCommentAdd *mCommentsServiceMockCommentAdd) invocationsDone() bool {
	if len(mmCommentAdd.expectations) == 0 && mmCommentAdd.defaultExpectation == nil && mmCommentAdd.mock.funcCommentAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentAdd.mock.afterCommentAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentAdd implements mm_server.CommentsService
func (mmCommentAdd *CommentsServiceMock) CommentAdd(ctx context.Context, comment model.Comment) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCommentAdd.beforeCommentAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentAdd.afterCommentAddCounter, 1)

	mmCommentAdd.t.Helper()

	if mmCommentAdd.inspectFuncCommentAdd != nil {
		mmCommentAdd.inspectFuncCommentAdd(ctx, comment)
	}

	mm_params := CommentsServiceMockCommentAddParams{ctx, comment}

	// Record call args
	mmCommentAdd.CommentAddMock.mutex.Lock()
	mmCommentAdd.CommentAddMock.callArgs = append(mmCommentAdd.CommentAddMock.callArgs, &mm_params)
	mmCommentAdd.CommentAddMock.mutex.Unlock()

	for _, e := range mmCommentAdd.CommentAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCommentAdd.CommentAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentAdd.CommentAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentAdd.CommentAddMock.defaultExpectation.params
		mm_want_ptrs := mmCommentAdd.CommentAddMock.defaultExpectation.paramPtrs

		mm_got := CommentsServiceMockCommentAddParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentAdd.t.Errorf("CommentsServiceMock.CommentAdd got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentAdd.CommentAddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmCommentAdd.t.Errorf("CommentsServiceMock.CommentAdd got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentAdd.CommentAddMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentAdd.t.Errorf("CommentsServiceMock.CommentAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentAdd.CommentAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentAdd.CommentAddMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentAdd.t.Fatal("No results are set for the CommentsServiceMock.CommentAdd")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCommentAdd.funcCommentAdd != nil {
		return mmCommentAdd.funcCommentAdd(ctx, comment)
	}
	mmCommentAdd.t.Fatalf("Unexpected call to CommentsServiceMock.CommentAdd. %v %v", ctx, comment)
	return
}

// CommentAddAfterCounter returns a count of finished CommentsServiceMock.CommentAdd invocations
func (mmCommentAdd *CommentsServiceMock) CommentAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentAdd.afterCommentAddCounter)
}

// CommentAddBeforeCounter returns a count of CommentsServiceMock.CommentAdd invocations
func (mmCommentAdd *CommentsServiceMock) CommentAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentAdd.beforeCommentAddCounter)
}

// Calls returns a list of arguments used in each call to CommentsServiceMock.CommentAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentAdd *mCommentsServiceMockCommentAdd) Calls() []*CommentsServiceMockCommentAddParams {
	mmCommentAdd.mutex.RLock()

	argCopy := make([]*CommentsServiceMockCommentAddParams, len(mmCommentAdd.callArgs))
	copy(argCopy, mmCommentAdd.callArgs)

	mmCommentAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCommentAddDone returns true if the count of the CommentAdd invocations corresponds
// the number of defined expectations
func (m *CommentsServiceMock) MinimockCommentAddDone() bool {
	if m.CommentAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentAddMock.invocationsDone()
}

// MinimockCommentAddInspect logs each unmet expectation
func (m *CommentsServiceMock) MinimockCommentAddInspect() {
	for _, e := range m.CommentAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentAddCounter := mm_atomic.LoadUint64(&m.afterCommentAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentAddMock.defaultExpectation != nil && afterCommentAddCounter < 1 {
		if m.CommentAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentAdd at\n%s", m.CommentAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentAdd at\n%s with params: %#v", m.CommentAddMock.defaultExpectation.expectationOrigins.origin, *m.CommentAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentAdd != nil && afterCommentAddCounter < 1 {
		m.t.Errorf("Expected call to CommentsServiceMock.CommentAdd at\n%s", m.funcCommentAddOrigin)
	}

	if !m.CommentAddMock.invocationsDone() && afterCommentAddCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentsServiceMock.CommentAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentAddMock.expectedInvocations), m.CommentAddMock.expectedInvocationsOrigin, afterCommentAddCounter)
	}
}

type mCommentsServiceMockCommentEdit struct {
	optional           bool
	mock               *CommentsServiceMock
	defaultExpectation *CommentsServiceMockCommentEditExpectation
	expectations       []*CommentsServiceMockCommentEditExpectation

	callArgs []*CommentsServiceMockCommentEditParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentsServiceMockCommentEditExpectation specifies expectation struct of the CommentsService.CommentEdit
type CommentsServiceMockCommentEditExpectation struct {
	mock               *CommentsServiceMock
	params             *CommentsServiceMockCommentEditParams
	paramPtrs          *CommentsServiceMockCommentEditParamPtrs
	expectationOrigins CommentsServiceMockCommentEditExpectationOrigins
	results            *CommentsServiceMockCommentEditResults
	returnOrigin       string
	Counter            uint64
}

// CommentsServiceMockCommentEditParams contains parameters of the CommentsService.CommentEdit
type CommentsServiceMockCommentEditParams struct {
	ctx     context.Context
	comment model.Comment
}

// CommentsServiceMockCommentEditParamPtrs contains pointers to parameters of the CommentsService.CommentEdit
type CommentsServiceMockCommentEditParamPtrs struct {
	ctx     *context.Context
	comment *model.Comment
}

// CommentsServiceMockCommentEditResults contains results of the CommentsService.CommentEdit
type CommentsServiceMockCommentEditResults struct {
	err error
}

// CommentsServiceMockCommentEditOrigins contains origins of expectations of the CommentsService.CommentEdit
type CommentsServiceMockCommentEditExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Optional() *mCommentsServiceMockCommentEdit {
	mmCommentEdit.optional = true
	return mmCommentEdit
}

// Expect sets up expected params for CommentsService.CommentEdit
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Expect(ctx context.Context, comment model.Comment) *mCommentsServiceMockCommentEdit {
	if mmCommentEdit.mock.funcCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Set")
	}

	if mmCommentEdit.defaultExpectation == nil {
		mmCommentEdit.defaultExpectation = &CommentsServiceMockCommentEditExpectation{}
	}

	if mmCommentEdit.defaultExpectation.paramPtrs != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by ExpectParams functions")
	}

	mmCommentEdit.defaultExpectation.params = &CommentsServiceMockCommentEditParams{ctx, comment}
	mmCommentEdit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentEdit.expectations {
		if minimock.Equal(e.params, mmCommentEdit.defaultExpectation.params) {
			mmCommentEdit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentEdit.defaultExpectation.params)
		}
	}

	return mmCommentEdit
}

// ExpectCtxParam1 sets up expected param ctx for CommentsService.CommentEdit
func (mmCommentEdit *mCommentsServiceMockCommentEdit) ExpectCtxParam1(ctx context.Context) *mCommentsServiceMockCommentEdit {
	if mmCommentEdit.mock.funcCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Set")
	}

	if mmCommentEdit.defaultExpectation == nil {
		mmCommentEdit.defaultExpectation = &CommentsServiceMockCommentEditExpectation{}
	}

	if mmCommentEdit.defaultExpectation.params != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Expect")
	}

	if mmCommentEdit.defaultExpectation.paramPtrs == nil {
		mmCommentEdit.defaultExpectation.paramPtrs = &CommentsServiceMockCommentEditParamPtrs{}
	}
	mmCommentEdit.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentEdit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentEdit
}

// ExpectCommentParam2 sets up expected param comment for CommentsService.CommentEdit
func (mmCommentEdit *mCommentsServiceMockCommentEdit) ExpectCommentParam2(comment model.Comment) *mCommentsServiceMockCommentEdit {
	if mmCommentEdit.mock.funcCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Set")
	}

	if mmCommentEdit.defaultExpectation == nil {
		mmCommentEdit.defaultExpectation = &CommentsServiceMockCommentEditExpectation{}
	}

	if mmCommentEdit.defaultExpectation.params != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Expect")
	}

	if mmCommentEdit.defaultExpectation.paramPtrs == nil {
		mmCommentEdit.defaultExpectation.paramPtrs = &CommentsServiceMockCommentEditParamPtrs{}
	}
	mmCommentEdit.defaultExpectation.paramPtrs.comment = &comment
	mmCommentEdit.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmCommentEdit
}

// Inspect accepts an inspector function that has same arguments as the CommentsService.CommentEdit
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Inspect(f func(ctx context.Context, comment model.Comment)) *mCommentsServiceMockCommentEdit {
	if mmCommentEdit.mock.inspectFuncCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("Inspect function is already set for CommentsServiceMock.CommentEdit")
	}

	mmCommentEdit.mock.inspectFuncCommentEdit = f

	return mmCommentEdit
}

// Return sets up results that will be returned by CommentsService.CommentEdit
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Return(err error) *CommentsServiceMock {
	if mmCommentEdit.mock.funcCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Set")
	}

	if mmCommentEdit.defaultExpectation == nil {
		mmCommentEdit.defaultExpectation = &CommentsServiceMockCommentEditExpectation{mock: mmCommentEdit.mock}
	}
	mmCommentEdit.defaultExpectation.results = &CommentsServiceMockCommentEditResults{err}
	mmCommentEdit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentEdit.mock
}

// Set uses given function f to mock the CommentsService.CommentEdit method
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Set(f func(ctx context.Context, comment model.Comment) (err error)) *CommentsServiceMock {
	if mmCommentEdit.defaultExpectation != nil {
		mmCommentEdit.mock.t.Fatalf("Default expectation is already set for the CommentsService.CommentEdit method")
	}

	if len(mmCommentEdit.expectations) > 0 {
		mmCommentEdit.mock.t.Fatalf("Some expectations are already set for the CommentsService.CommentEdit method")
	}

	mmCommentEdit.mock.funcCommentEdit = f
	mmCommentEdit.mock.funcCommentEditOrigin = minimock.CallerInfo(1)
	return mmCommentEdit.mock
}

// When sets expectation for the CommentsService.CommentEdit which will trigger the result defined by the following
// Then helper
func (mmCommentEdit *mCommentsServiceMockCommentEdit) When(ctx context.Context, comment model.Comment) *CommentsServiceMockCommentEditExpectation {
	if mmCommentEdit.mock.funcCommentEdit != nil {
		mmCommentEdit.mock.t.Fatalf("CommentsServiceMock.CommentEdit mock is already set by Set")
	}

	expectation := &CommentsServiceMockCommentEditExpectation{
		mock:               mmCommentEdit.mock,
		params:             &CommentsServiceMockCommentEditParams{ctx, comment},
		expectationOrigins: CommentsServiceMockCommentEditExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentEdit.expectations = append(mmCommentEdit.expectations, expectation)
	return expectation
}

// Then sets up CommentsService.CommentEdit return parameters for the expectation previously defined by the When method
func (e *CommentsServiceMockCommentEditExpectation) Then(err error) *CommentsServiceMock {
	e.results = &CommentsServiceMockCommentEditResults{err}
	return e.mock
}

// Times sets number of times CommentsService.CommentEdit should be invoked
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Times(n uint64) *mCommentsServiceMockCommentEdit {
	if n == 0 {
		mmCommentEdit.mock.t.Fatalf("Times of CommentsServiceMock.CommentEdit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentEdit.expectedInvocations, n)
	mmCommentEdit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentEdit
}

func (mmCommentEdit *mCommentsServiceMockCommentEdit) invocationsDone() bool {
	if len(mmCommentEdit.expectations) == 0 && mmCommentEdit.defaultExpectation == nil && mmCommentEdit.mock.funcCommentEdit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentEdit.mock.afterCommentEditCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentEdit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentEdit implements mm_server.CommentsService
func (mmCommentEdit *CommentsServiceMock) CommentEdit(ctx context.Context, comment model.Comment) (err error) {
	mm_atomic.AddUint64(&mmCommentEdit.beforeCommentEditCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentEdit.afterCommentEditCounter, 1)

	mmCommentEdit.t.Helper()

	if mmCommentEdit.inspectFuncCommentEdit != nil {
		mmCommentEdit.inspectFuncCommentEdit(ctx, comment)
	}

	mm_params := CommentsServiceMockCommentEditParams{ctx, comment}

	// Record call args
	mmCommentEdit.CommentEditMock.mutex.Lock()
	mmCommentEdit.CommentEditMock.callArgs = append(mmCommentEdit.CommentEditMock.callArgs, &mm_params)
	mmCommentEdit.CommentEditMock.mutex.Unlock()

	for _, e := range mmCommentEdit.CommentEditMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommentEdit.CommentEditMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentEdit.CommentEditMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentEdit.CommentEditMock.defaultExpectation.params
		mm_want_ptrs := mmCommentEdit.CommentEditMock.defaultExpectation.paramPtrs

		mm_got := CommentsServiceMockCommentEditParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentEdit.t.Errorf("CommentsServiceMock.CommentEdit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentEdit.CommentEditMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmCommentEdit.t.Errorf("CommentsServiceMock.CommentEdit got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentEdit.CommentEditMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentEdit.t.Errorf("CommentsServiceMock.CommentEdit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentEdit.CommentEditMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentEdit.CommentEditMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentEdit.t.Fatal("No results are set for the CommentsServiceMock.CommentEdit")
		}
		return (*mm_results).err
	}
	if mmCommentEdit.funcCommentEdit != nil {
		return mmCommentEdit.funcCommentEdit(ctx, comment)
	}
	mmCommentEdit.t.Fatalf("Unexpected call to CommentsServiceMock.CommentEdit. %v %v", ctx, comment)
	return
}

// CommentEditAfterCounter returns a count of finished CommentsServiceMock.CommentEdit invocations
func (mmCommentEdit *CommentsServiceMock) CommentEditAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentEdit.afterCommentEditCounter)
}

// CommentEditBeforeCounter returns a count of CommentsServiceMock.CommentEdit invocations
func (mmCommentEdit *CommentsServiceMock) CommentEditBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentEdit.beforeCommentEditCounter)
}

// Calls returns a list of arguments used in each call to CommentsServiceMock.CommentEdit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentEdit *mCommentsServiceMockCommentEdit) Calls() []*CommentsServiceMockCommentEditParams {
	mmCommentEdit.mutex.RLock()

	argCopy := make([]*CommentsServiceMockCommentEditParams, len(mmCommentEdit.callArgs))
	copy(argCopy, mmCommentEdit.callArgs)

	mmCommentEdit.mutex.RUnlock()

	return argCopy
}

// MinimockCommentEditDone returns true if the count of the CommentEdit invocations corresponds
// the number of defined expectations
func (m *CommentsServiceMock) MinimockCommentEditDone() bool {
	if m.CommentEditMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentEditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentEditMock.invocationsDone()
}

// MinimockCommentEditInspect logs each unmet expectation
func (m *CommentsServiceMock) MinimockCommentEditInspect() {
	for _, e := range m.CommentEditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentEdit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentEditCounter := mm_atomic.LoadUint64(&m.afterCommentEditCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentEditMock.defaultExpectation != nil && afterCommentEditCounter < 1 {
		if m.CommentEditMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentEdit at\n%s", m.CommentEditMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentEdit at\n%s with params: %#v", m.CommentEditMock.defaultExpectation.expectationOrigins.origin, *m.CommentEditMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentEdit != nil && afterCommentEditCounter < 1 {
		m.t.Errorf("Expected call to CommentsServiceMock.CommentEdit at\n%s", m.funcCommentEditOrigin)
	}

	if !m.CommentEditMock.invocationsDone() && afterCommentEditCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentsServiceMock.CommentEdit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentEditMock.expectedInvocations), m.CommentEditMock.expectedInvocationsOrigin, afterCommentEditCounter)
	}
}

type mCommentsServiceMockCommentGetByID struct {
	optional           bool
	mock               *CommentsServiceMock
	defaultExpectation *CommentsServiceMockCommentGetByIDExpectation
	expectations       []*CommentsServiceMockCommentGetByIDExpectation

	callArgs []*CommentsServiceMockCommentGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentsServiceMockCommentGetByIDExpectation specifies expectation struct of the CommentsService.CommentGetByID
type CommentsServiceMockCommentGetByIDExpectation struct {
	mock               *CommentsServiceMock
	params             *CommentsServiceMockCommentGetByIDParams
	paramPtrs          *CommentsServiceMockCommentGetByIDParamPtrs
	expectationOrigins CommentsServiceMockCommentGetByIDExpectationOrigins
	results            *CommentsServiceMockCommentGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// CommentsServiceMockCommentGetByIDParams contains parameters of the CommentsService.CommentGetByID
type CommentsServiceMockCommentGetByIDParams struct {
	ctx       context.Context
	commentID int64
}

// CommentsServiceMockCommentGetByIDParamPtrs contains pointers to parameters of the CommentsService.CommentGetByID
type CommentsServiceMockCommentGetByIDParamPtrs struct {
	ctx       *context.Context
	commentID *int64
}

// CommentsServiceMockCommentGetByIDResults contains results of the CommentsService.CommentGetByID
type CommentsServiceMockCommentGetByIDResults struct {
	cp1 *model.Comment
	err error
}

// CommentsServiceMockCommentGetByIDOrigins contains origins of expectations of the CommentsService.CommentGetByID
type CommentsServiceMockCommentGetByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originCommentID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Optional() *mCommentsServiceMockCommentGetByID {
	mmCommentGetByID.optional = true
	return mmCommentGetByID
}

// Expect sets up expected params for CommentsService.CommentGetByID
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Expect(ctx context.Context, commentID int64) *mCommentsServiceMockCommentGetByID {
	if mmCommentGetByID.mock.funcCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Set")
	}

	if mmCommentGetByID.defaultExpectation == nil {
		mmCommentGetByID.defaultExpectation = &CommentsServiceMockCommentGetByIDExpectation{}
	}

	if mmCommentGetByID.defaultExpectation.paramPtrs != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by ExpectParams functions")
	}

	mmCommentGetByID.defaultExpectation.params = &CommentsServiceMockCommentGetByIDParams{ctx, commentID}
	mmCommentGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentGetByID.expectations {
		if minimock.Equal(e.params, mmCommentGetByID.defaultExpectation.params) {
			mmCommentGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentGetByID.defaultExpectation.params)
		}
	}

	return mmCommentGetByID
}

// ExpectCtxParam1 sets up expected param ctx for CommentsService.CommentGetByID
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) ExpectCtxParam1(ctx context.Context) *mCommentsServiceMockCommentGetByID {
	if mmCommentGetByID.mock.funcCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Set")
	}

	if mmCommentGetByID.defaultExpectation == nil {
		mmCommentGetByID.defaultExpectation = &CommentsServiceMockCommentGetByIDExpectation{}
	}

	if mmCommentGetByID.defaultExpectation.params != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Expect")
	}

	if mmCommentGetByID.defaultExpectation.paramPtrs == nil {
		mmCommentGetByID.defaultExpectation.paramPtrs = &CommentsServiceMockCommentGetByIDParamPtrs{}
	}
	mmCommentGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentGetByID
}

// ExpectCommentIDParam2 sets up expected param commentID for CommentsService.CommentGetByID
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) ExpectCommentIDParam2(commentID int64) *mCommentsServiceMockCommentGetByID {
	if mmCommentGetByID.mock.funcCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Set")
	}

	if mmCommentGetByID.defaultExpectation == nil {
		mmCommentGetByID.defaultExpectation = &CommentsServiceMockCommentGetByIDExpectation{}
	}

	if mmCommentGetByID.defaultExpectation.params != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Expect")
	}

	if mmCommentGetByID.defaultExpectation.paramPtrs == nil {
		mmCommentGetByID.defaultExpectation.paramPtrs = &CommentsServiceMockCommentGetByIDParamPtrs{}
	}
	mmCommentGetByID.defaultExpectation.paramPtrs.commentID = &commentID
	mmCommentGetByID.defaultExpectation.expectationOrigins.originCommentID = minimock.CallerInfo(1)

	return mmCommentGetByID
}

// Inspect accepts an inspector function that has same arguments as the CommentsService.CommentGetByID
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Inspect(f func(ctx context.Context, commentID int64)) *mCommentsServiceMockCommentGetByID {
	if mmCommentGetByID.mock.inspectFuncCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("Inspect function is already set for CommentsServiceMock.CommentGetByID")
	}

	mmCommentGetByID.mock.inspectFuncCommentGetByID = f

	return mmCommentGetByID
}

// Return sets up results that will be returned by CommentsService.CommentGetByID
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Return(cp1 *model.Comment, err error) *CommentsServiceMock {
	if mmCommentGetByID.mock.funcCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Set")
	}

	if mmCommentGetByID.defaultExpectation == nil {
		mmCommentGetByID.defaultExpectation = &CommentsServiceMockCommentGetByIDExpectation{mock: mmCommentGetByID.mock}
	}
	mmCommentGetByID.defaultExpectation.results = &CommentsServiceMockCommentGetByIDResults{cp1, err}
	mmCommentGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentGetByID.mock
}

// Set uses given function f to mock the CommentsService.CommentGetByID method
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Set(f func(ctx context.Context, commentID int64) (cp1 *model.Comment, err error)) *CommentsServiceMock {
	if mmCommentGetByID.defaultExpectation != nil {
		mmCommentGetByID.mock.t.Fatalf("Default expectation is already set for the CommentsService.CommentGetByID method")
	}

	if len(mmCommentGetByID.expectations) > 0 {
		mmCommentGetByID.mock.t.Fatalf("Some expectations are already set for the CommentsService.CommentGetByID method")
	}

	mmCommentGetByID.mock.funcCommentGetByID = f
	mmCommentGetByID.mock.funcCommentGetByIDOrigin = minimock.CallerInfo(1)
	return mmCommentGetByID.mock
}

// When sets expectation for the CommentsService.CommentGetByID which will trigger the result defined by the following
// Then helper
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) When(ctx context.Context, commentID int64) *CommentsServiceMockCommentGetByIDExpectation {
	if mmCommentGetByID.mock.funcCommentGetByID != nil {
		mmCommentGetByID.mock.t.Fatalf("CommentsServiceMock.CommentGetByID mock is already set by Set")
	}

	expectation := &CommentsServiceMockCommentGetByIDExpectation{
		mock:               mmCommentGetByID.mock,
		params:             &CommentsServiceMockCommentGetByIDParams{ctx, commentID},
		expectationOrigins: CommentsServiceMockCommentGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentGetByID.expectations = append(mmCommentGetByID.expectations, expectation)
	return expectation
}

// Then sets up CommentsService.CommentGetByID return parameters for the expectation previously defined by the When method
func (e *CommentsServiceMockCommentGetByIDExpectation) Then(cp1 *model.Comment, err error) *CommentsServiceMock {
	e.results = &CommentsServiceMockCommentGetByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times CommentsService.CommentGetByID should be invoked
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Times(n uint64) *mCommentsServiceMockCommentGetByID {
	if n == 0 {
		mmCommentGetByID.mock.t.Fatalf("Times of CommentsServiceMock.CommentGetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentGetByID.expectedInvocations, n)
	mmCommentGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentGetByID
}

func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) invocationsDone() bool {
	if len(mmCommentGetByID.expectations) == 0 && mmCommentGetByID.defaultExpectation == nil && mmCommentGetByID.mock.funcCommentGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentGetByID.mock.afterCommentGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentGetByID implements mm_server.CommentsService
func (mmCommentGetByID *CommentsServiceMock) CommentGetByID(ctx context.Context, commentID int64) (cp1 *model.Comment, err error) {
	mm_atomic.AddUint64(&mmCommentGetByID.beforeCommentGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentGetByID.afterCommentGetByIDCounter, 1)

	mmCommentGetByID.t.Helper()

	if mmCommentGetByID.inspectFuncCommentGetByID != nil {
		mmCommentGetByID.inspectFuncCommentGetByID(ctx, commentID)
	}

	mm_params := CommentsServiceMockCommentGetByIDParams{ctx, commentID}

	// Record call args
	mmCommentGetByID.CommentGetByIDMock.mutex.Lock()
	mmCommentGetByID.CommentGetByIDMock.callArgs = append(mmCommentGetByID.CommentGetByIDMock.callArgs, &mm_params)
	mmCommentGetByID.CommentGetByIDMock.mutex.Unlock()

	for _, e := range mmCommentGetByID.CommentGetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCommentGetByID.CommentGetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentGetByID.CommentGetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentGetByID.CommentGetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmCommentGetByID.CommentGetByIDMock.defaultExpectation.paramPtrs

		mm_got := CommentsServiceMockCommentGetByIDParams{ctx, commentID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentGetByID.t.Errorf("CommentsServiceMock.CommentGetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentGetByID.CommentGetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.commentID != nil && !minimock.Equal(*mm_want_ptrs.commentID, mm_got.commentID) {
				mmCommentGetByID.t.Errorf("CommentsServiceMock.CommentGetByID got unexpected parameter commentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentGetByID.CommentGetByIDMock.defaultExpectation.expectationOrigins.originCommentID, *mm_want_ptrs.commentID, mm_got.commentID, minimock.Diff(*mm_want_ptrs.commentID, mm_got.commentID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentGetByID.t.Errorf("CommentsServiceMock.CommentGetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentGetByID.CommentGetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentGetByID.CommentGetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentGetByID.t.Fatal("No results are set for the CommentsServiceMock.CommentGetByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCommentGetByID.funcCommentGetByID != nil {
		return mmCommentGetByID.funcCommentGetByID(ctx, commentID)
	}
	mmCommentGetByID.t.Fatalf("Unexpected call to CommentsServiceMock.CommentGetByID. %v %v", ctx, commentID)
	return
}

// CommentGetByIDAfterCounter returns a count of finished CommentsServiceMock.CommentGetByID invocations
func (mmCommentGetByID *CommentsServiceMock) CommentGetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentGetByID.afterCommentGetByIDCounter)
}

// CommentGetByIDBeforeCounter returns a count of CommentsServiceMock.CommentGetByID invocations
func (mmCommentGetByID *CommentsServiceMock) CommentGetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentGetByID.beforeCommentGetByIDCounter)
}

// Calls returns a list of arguments used in each call to CommentsServiceMock.CommentGetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentGetByID *mCommentsServiceMockCommentGetByID) Calls() []*CommentsServiceMockCommentGetByIDParams {
	mmCommentGetByID.mutex.RLock()

	argCopy := make([]*CommentsServiceMockCommentGetByIDParams, len(mmCommentGetByID.callArgs))
	copy(argCopy, mmCommentGetByID.callArgs)

	mmCommentGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockCommentGetByIDDone returns true if the count of the CommentGetByID invocations corresponds
// the number of defined expectations
func (m *CommentsServiceMock) MinimockCommentGetByIDDone() bool {
	if m.CommentGetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentGetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentGetByIDMock.invocationsDone()
}

// MinimockCommentGetByIDInspect logs each unmet expectation
func (m *CommentsServiceMock) MinimockCommentGetByIDInspect() {
	for _, e := range m.CommentGetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentGetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentGetByIDCounter := mm_atomic.LoadUint64(&m.afterCommentGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentGetByIDMock.defaultExpectation != nil && afterCommentGetByIDCounter < 1 {
		if m.CommentGetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentGetByID at\n%s", m.CommentGetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentGetByID at\n%s with params: %#v", m.CommentGetByIDMock.defaultExpectation.expectationOrigins.origin, *m.CommentGetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentGetByID != nil && afterCommentGetByIDCounter < 1 {
		m.t.Errorf("Expected call to CommentsServiceMock.CommentGetByID at\n%s", m.funcCommentGetByIDOrigin)
	}

	if !m.CommentGetByIDMock.invocationsDone() && afterCommentGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentsServiceMock.CommentGetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentGetByIDMock.expectedInvocations), m.CommentGetByIDMock.expectedInvocationsOrigin, afterCommentGetByIDCounter)
	}
}

type mCommentsServiceMockCommentListBySku struct {
	optional           bool
	mock               *CommentsServiceMock
	defaultExpectation *CommentsServiceMockCommentListBySkuExpectation
	expectations       []*CommentsServiceMockCommentListBySkuExpectation

	callArgs []*CommentsServiceMockCommentListBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentsServiceMockCommentListBySkuExpectation specifies expectation struct of the CommentsService.CommentListBySku
type CommentsServiceMockCommentListBySkuExpectation struct {
	mock               *CommentsServiceMock
	params             *CommentsServiceMockCommentListBySkuParams
	paramPtrs          *CommentsServiceMockCommentListBySkuParamPtrs
	expectationOrigins CommentsServiceMockCommentListBySkuExpectationOrigins
	results            *CommentsServiceMockCommentListBySkuResults
	returnOrigin       string
	Counter            uint64
}

// CommentsServiceMockCommentListBySkuParams contains parameters of the CommentsService.CommentListBySku
type CommentsServiceMockCommentListBySkuParams struct {
	ctx    context.Context
	sku    int64
	cursor *model.Cursor
}

// CommentsServiceMockCommentListBySkuParamPtrs contains pointers to parameters of the CommentsService.CommentListBySku
type CommentsServiceMockCommentListBySkuParamPtrs struct {
	ctx    *context.Context
	sku    *int64
	cursor **model.Cursor
}

// CommentsServiceMockCommentListBySkuResults contains results of the CommentsService.CommentListBySku
type CommentsServiceMockCommentListBySkuResults struct {
	ca1 []model.Comment
	cp1 *model.Cursor
	err error
}

// CommentsServiceMockCommentListBySkuOrigins contains origins of expectations of the CommentsService.CommentListBySku
type CommentsServiceMockCommentListBySkuExpectationOrigins struct {
	origin       string
	originCtx    string
	originSku    string
	originCursor string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Optional() *mCommentsServiceMockCommentListBySku {
	mmCommentListBySku.optional = true
	return mmCommentListBySku
}

// Expect sets up expected params for CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Expect(ctx context.Context, sku int64, cursor *model.Cursor) *mCommentsServiceMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &CommentsServiceMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by ExpectParams functions")
	}

	mmCommentListBySku.defaultExpectation.params = &CommentsServiceMockCommentListBySkuParams{ctx, sku, cursor}
	mmCommentListBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentListBySku.expectations {
		if minimock.Equal(e.params, mmCommentListBySku.defaultExpectation.params) {
			mmCommentListBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentListBySku.defaultExpectation.params)
		}
	}

	return mmCommentListBySku
}

// ExpectCtxParam1 sets up expected param ctx for CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) ExpectCtxParam1(ctx context.Context) *mCommentsServiceMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &CommentsServiceMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &CommentsServiceMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentListBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// ExpectSkuParam2 sets up expected param sku for CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) ExpectSkuParam2(sku int64) *mCommentsServiceMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &CommentsServiceMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &CommentsServiceMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.sku = &sku
	mmCommentListBySku.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// ExpectCursorParam3 sets up expected param cursor for CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) ExpectCursorParam3(cursor *model.Cursor) *mCommentsServiceMockCommentListBySku {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &CommentsServiceMockCommentListBySkuExpectation{}
	}

	if mmCommentListBySku.defaultExpectation.params != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Expect")
	}

	if mmCommentListBySku.defaultExpectation.paramPtrs == nil {
		mmCommentListBySku.defaultExpectation.paramPtrs = &CommentsServiceMockCommentListBySkuParamPtrs{}
	}
	mmCommentListBySku.defaultExpectation.paramPtrs.cursor = &cursor
	mmCommentListBySku.defaultExpectation.expectationOrigins.originCursor = minimock.CallerInfo(1)

	return mmCommentListBySku
}

// Inspect accepts an inspector function that has same arguments as the CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Inspect(f func(ctx context.Context, sku int64, cursor *model.Cursor)) *mCommentsServiceMockCommentListBySku {
	if mmCommentListBySku.mock.inspectFuncCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("Inspect function is already set for CommentsServiceMock.CommentListBySku")
	}

	mmCommentListBySku.mock.inspectFuncCommentListBySku = f

	return mmCommentListBySku
}

// Return sets up results that will be returned by CommentsService.CommentListBySku
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Return(ca1 []model.Comment, cp1 *model.Cursor, err error) *CommentsServiceMock {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	if mmCommentListBySku.defaultExpectation == nil {
		mmCommentListBySku.defaultExpectation = &CommentsServiceMockCommentListBySkuExpectation{mock: mmCommentListBySku.mock}
	}
	mmCommentListBySku.defaultExpectation.results = &CommentsServiceMockCommentListBySkuResults{ca1, cp1, err}
	mmCommentListBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku.mock
}

// Set uses given function f to mock the CommentsService.CommentListBySku method
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Set(f func(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error)) *CommentsServiceMock {
	if mmCommentListBySku.defaultExpectation != nil {
		mmCommentListBySku.mock.t.Fatalf("Default expectation is already set for the CommentsService.CommentListBySku method")
	}

	if len(mmCommentListBySku.expectations) > 0 {
		mmCommentListBySku.mock.t.Fatalf("Some expectations are already set for the CommentsService.CommentListBySku method")
	}

	mmCommentListBySku.mock.funcCommentListBySku = f
	mmCommentListBySku.mock.funcCommentListBySkuOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku.mock
}

// When sets expectation for the CommentsService.CommentListBySku which will trigger the result defined by the following
// Then helper
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) When(ctx context.Context, sku int64, cursor *model.Cursor) *CommentsServiceMockCommentListBySkuExpectation {
	if mmCommentListBySku.mock.funcCommentListBySku != nil {
		mmCommentListBySku.mock.t.Fatalf("CommentsServiceMock.CommentListBySku mock is already set by Set")
	}

	expectation := &CommentsServiceMockCommentListBySkuExpectation{
		mock:               mmCommentListBySku.mock,
		params:             &CommentsServiceMockCommentListBySkuParams{ctx, sku, cursor},
		expectationOrigins: CommentsServiceMockCommentListBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentListBySku.expectations = append(mmCommentListBySku.expectations, expectation)
	return expectation
}

// Then sets up CommentsService.CommentListBySku return parameters for the expectation previously defined by the When method
func (e *CommentsServiceMockCommentListBySkuExpectation) Then(ca1 []model.Comment, cp1 *model.Cursor, err error) *CommentsServiceMock {
	e.results = &CommentsServiceMockCommentListBySkuResults{ca1, cp1, err}
	return e.mock
}

// Times sets number of times CommentsService.CommentListBySku should be invoked
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Times(n uint64) *mCommentsServiceMockCommentListBySku {
	if n == 0 {
		mmCommentListBySku.mock.t.Fatalf("Times of CommentsServiceMock.CommentListBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentListBySku.expectedInvocations, n)
	mmCommentListBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentListBySku
}

func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) invocationsDone() bool {
	if len(mmCommentListBySku.expectations) == 0 && mmCommentListBySku.defaultExpectation == nil && mmCommentListBySku.mock.funcCommentListBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentListBySku.mock.afterCommentListBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentListBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentListBySku implements mm_server.CommentsService
func (mmCommentListBySku *CommentsServiceMock) CommentListBySku(ctx context.Context, sku int64, cursor *model.Cursor) (ca1 []model.Comment, cp1 *model.Cursor, err error) {
	mm_atomic.AddUint64(&mmCommentListBySku.beforeCommentListBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentListBySku.afterCommentListBySkuCounter, 1)

	mmCommentListBySku.t.Helper()

	if mmCommentListBySku.inspectFuncCommentListBySku != nil {
		mmCommentListBySku.inspectFuncCommentListBySku(ctx, sku, cursor)
	}

	mm_params := CommentsServiceMockCommentListBySkuParams{ctx, sku, cursor}

	// Record call args
	mmCommentListBySku.CommentListBySkuMock.mutex.Lock()
	mmCommentListBySku.CommentListBySkuMock.callArgs = append(mmCommentListBySku.CommentListBySkuMock.callArgs, &mm_params)
	mmCommentListBySku.CommentListBySkuMock.mutex.Unlock()

	for _, e := range mmCommentListBySku.CommentListBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.cp1, e.results.err
		}
	}

	if mmCommentListBySku.CommentListBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentListBySku.CommentListBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.paramPtrs

		mm_got := CommentsServiceMockCommentListBySkuParams{ctx, sku, cursor}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentListBySku.t.Errorf("CommentsServiceMock.CommentListBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmCommentListBySku.t.Errorf("CommentsServiceMock.CommentListBySku got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.cursor != nil && !minimock.Equal(*mm_want_ptrs.cursor, mm_got.cursor) {
				mmCommentListBySku.t.Errorf("CommentsServiceMock.CommentListBySku got unexpected parameter cursor, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.originCursor, *mm_want_ptrs.cursor, mm_got.cursor, minimock.Diff(*mm_want_ptrs.cursor, mm_got.cursor))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentListBySku.t.Errorf("CommentsServiceMock.CommentListBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentListBySku.CommentListBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentListBySku.CommentListBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentListBySku.t.Fatal("No results are set for the CommentsServiceMock.CommentListBySku")
		}
		return (*mm_results).ca1, (*mm_results).cp1, (*mm_results).err
	}
	if mmCommentListBySku.funcCommentListBySku != nil {
		return mmCommentListBySku.funcCommentListBySku(ctx, sku, cursor)
	}
	mmCommentListBySku.t.Fatalf("Unexpected call to CommentsServiceMock.CommentListBySku. %v %v %v", ctx, sku, cursor)
	return
}

// CommentListBySkuAfterCounter returns a count of finished CommentsServiceMock.CommentListBySku invocations
func (mmCommentListBySku *CommentsServiceMock) CommentListBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListBySku.afterCommentListBySkuCounter)
}

// CommentListBySkuBeforeCounter returns a count of CommentsServiceMock.CommentListBySku invocations
func (mmCommentListBySku *CommentsServiceMock) CommentListBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListBySku.beforeCommentListBySkuCounter)
}

// Calls returns a list of arguments used in each call to CommentsServiceMock.CommentListBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentListBySku *mCommentsServiceMockCommentListBySku) Calls() []*CommentsServiceMockCommentListBySkuParams {
	mmCommentListBySku.mutex.RLock()

	argCopy := make([]*CommentsServiceMockCommentListBySkuParams, len(mmCommentListBySku.callArgs))
	copy(argCopy, mmCommentListBySku.callArgs)

	mmCommentListBySku.mutex.RUnlock()

	return argCopy
}

// MinimockCommentListBySkuDone returns true if the count of the CommentListBySku invocations corresponds
// the number of defined expectations
func (m *CommentsServiceMock) MinimockCommentListBySkuDone() bool {
	if m.CommentListBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentListBySkuMock.invocationsDone()
}

// MinimockCommentListBySkuInspect logs each unmet expectation
func (m *CommentsServiceMock) MinimockCommentListBySkuInspect() {
	for _, e := range m.CommentListBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentListBySkuCounter := mm_atomic.LoadUint64(&m.afterCommentListBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentListBySkuMock.defaultExpectation != nil && afterCommentListBySkuCounter < 1 {
		if m.CommentListBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListBySku at\n%s", m.CommentListBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListBySku at\n%s with params: %#v", m.CommentListBySkuMock.defaultExpectation.expectationOrigins.origin, *m.CommentListBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentListBySku != nil && afterCommentListBySkuCounter < 1 {
		m.t.Errorf("Expected call to CommentsServiceMock.CommentListBySku at\n%s", m.funcCommentListBySkuOrigin)
	}

	if !m.CommentListBySkuMock.invocationsDone() && afterCommentListBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentsServiceMock.CommentListBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentListBySkuMock.expectedInvocations), m.CommentListBySkuMock.expectedInvocationsOrigin, afterCommentListBySkuCounter)
	}
}

type mCommentsServiceMockCommentListByUser struct {
	optional           bool
	mock               *CommentsServiceMock
	defaultExpectation *CommentsServiceMockCommentListByUserExpectation
	expectations       []*CommentsServiceMockCommentListByUserExpectation

	callArgs []*CommentsServiceMockCommentListByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommentsServiceMockCommentListByUserExpectation specifies expectation struct of the CommentsService.CommentListByUser
type CommentsServiceMockCommentListByUserExpectation struct {
	mock               *CommentsServiceMock
	params             *CommentsServiceMockCommentListByUserParams
	paramPtrs          *CommentsServiceMockCommentListByUserParamPtrs
	expectationOrigins CommentsServiceMockCommentListByUserExpectationOrigins
	results            *CommentsServiceMockCommentListByUserResults
	returnOrigin       string
	Counter            uint64
}

// CommentsServiceMockCommentListByUserParams contains parameters of the CommentsService.CommentListByUser
type CommentsServiceMockCommentListByUserParams struct {
	ctx    context.Context
	userID int64
}

// CommentsServiceMockCommentListByUserParamPtrs contains pointers to parameters of the CommentsService.CommentListByUser
type CommentsServiceMockCommentListByUserParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CommentsServiceMockCommentListByUserResults contains results of the CommentsService.CommentListByUser
type CommentsServiceMockCommentListByUserResults struct {
	ca1 []model.Comment
	err error
}

// CommentsServiceMockCommentListByUserOrigins contains origins of expectations of the CommentsService.CommentListByUser
type CommentsServiceMockCommentListByUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Optional() *mCommentsServiceMockCommentListByUser {
	mmCommentListByUser.optional = true
	return mmCommentListByUser
}

// Expect sets up expected params for CommentsService.CommentListByUser
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Expect(ctx context.Context, userID int64) *mCommentsServiceMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &CommentsServiceMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by ExpectParams functions")
	}

	mmCommentListByUser.defaultExpectation.params = &CommentsServiceMockCommentListByUserParams{ctx, userID}
	mmCommentListByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommentListByUser.expectations {
		if minimock.Equal(e.params, mmCommentListByUser.defaultExpectation.params) {
			mmCommentListByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommentListByUser.defaultExpectation.params)
		}
	}

	return mmCommentListByUser
}

// ExpectCtxParam1 sets up expected param ctx for CommentsService.CommentListByUser
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) ExpectCtxParam1(ctx context.Context) *mCommentsServiceMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &CommentsServiceMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.params != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Expect")
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs == nil {
		mmCommentListByUser.defaultExpectation.paramPtrs = &CommentsServiceMockCommentListByUserParamPtrs{}
	}
	mmCommentListByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommentListByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommentListByUser
}

// ExpectUserIDParam2 sets up expected param userID for CommentsService.CommentListByUser
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) ExpectUserIDParam2(userID int64) *mCommentsServiceMockCommentListByUser {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &CommentsServiceMockCommentListByUserExpectation{}
	}

	if mmCommentListByUser.defaultExpectation.params != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Expect")
	}

	if mmCommentListByUser.defaultExpectation.paramPtrs == nil {
		mmCommentListByUser.defaultExpectation.paramPtrs = &CommentsServiceMockCommentListByUserParamPtrs{}
	}
	mmCommentListByUser.defaultExpectation.paramPtrs.userID = &userID
	mmCommentListByUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCommentListByUser
}

// Inspect accepts an inspector function that has same arguments as the CommentsService.CommentListByUser
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Inspect(f func(ctx context.Context, userID int64)) *mCommentsServiceMockCommentListByUser {
	if mmCommentListByUser.mock.inspectFuncCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("Inspect function is already set for CommentsServiceMock.CommentListByUser")
	}

	mmCommentListByUser.mock.inspectFuncCommentListByUser = f

	return mmCommentListByUser
}

// Return sets up results that will be returned by CommentsService.CommentListByUser
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Return(ca1 []model.Comment, err error) *CommentsServiceMock {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Set")
	}

	if mmCommentListByUser.defaultExpectation == nil {
		mmCommentListByUser.defaultExpectation = &CommentsServiceMockCommentListByUserExpectation{mock: mmCommentListByUser.mock}
	}
	mmCommentListByUser.defaultExpectation.results = &CommentsServiceMockCommentListByUserResults{ca1, err}
	mmCommentListByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser.mock
}

// Set uses given function f to mock the CommentsService.CommentListByUser method
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Set(f func(ctx context.Context, userID int64) (ca1 []model.Comment, err error)) *CommentsServiceMock {
	if mmCommentListByUser.defaultExpectation != nil {
		mmCommentListByUser.mock.t.Fatalf("Default expectation is already set for the CommentsService.CommentListByUser method")
	}

	if len(mmCommentListByUser.expectations) > 0 {
		mmCommentListByUser.mock.t.Fatalf("Some expectations are already set for the CommentsService.CommentListByUser method")
	}

	mmCommentListByUser.mock.funcCommentListByUser = f
	mmCommentListByUser.mock.funcCommentListByUserOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser.mock
}

// When sets expectation for the CommentsService.CommentListByUser which will trigger the result defined by the following
// Then helper
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) When(ctx context.Context, userID int64) *CommentsServiceMockCommentListByUserExpectation {
	if mmCommentListByUser.mock.funcCommentListByUser != nil {
		mmCommentListByUser.mock.t.Fatalf("CommentsServiceMock.CommentListByUser mock is already set by Set")
	}

	expectation := &CommentsServiceMockCommentListByUserExpectation{
		mock:               mmCommentListByUser.mock,
		params:             &CommentsServiceMockCommentListByUserParams{ctx, userID},
		expectationOrigins: CommentsServiceMockCommentListByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommentListByUser.expectations = append(mmCommentListByUser.expectations, expectation)
	return expectation
}

// Then sets up CommentsService.CommentListByUser return parameters for the expectation previously defined by the When method
func (e *CommentsServiceMockCommentListByUserExpectation) Then(ca1 []model.Comment, err error) *CommentsServiceMock {
	e.results = &CommentsServiceMockCommentListByUserResults{ca1, err}
	return e.mock
}

// Times sets number of times CommentsService.CommentListByUser should be invoked
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Times(n uint64) *mCommentsServiceMockCommentListByUser {
	if n == 0 {
		mmCommentListByUser.mock.t.Fatalf("Times of CommentsServiceMock.CommentListByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommentListByUser.expectedInvocations, n)
	mmCommentListByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommentListByUser
}

func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) invocationsDone() bool {
	if len(mmCommentListByUser.expectations) == 0 && mmCommentListByUser.defaultExpectation == nil && mmCommentListByUser.mock.funcCommentListByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommentListByUser.mock.afterCommentListByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommentListByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommentListByUser implements mm_server.CommentsService
func (mmCommentListByUser *CommentsServiceMock) CommentListByUser(ctx context.Context, userID int64) (ca1 []model.Comment, err error) {
	mm_atomic.AddUint64(&mmCommentListByUser.beforeCommentListByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCommentListByUser.afterCommentListByUserCounter, 1)

	mmCommentListByUser.t.Helper()

	if mmCommentListByUser.inspectFuncCommentListByUser != nil {
		mmCommentListByUser.inspectFuncCommentListByUser(ctx, userID)
	}

	mm_params := CommentsServiceMockCommentListByUserParams{ctx, userID}

	// Record call args
	mmCommentListByUser.CommentListByUserMock.mutex.Lock()
	mmCommentListByUser.CommentListByUserMock.callArgs = append(mmCommentListByUser.CommentListByUserMock.callArgs, &mm_params)
	mmCommentListByUser.CommentListByUserMock.mutex.Unlock()

	for _, e := range mmCommentListByUser.CommentListByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmCommentListByUser.CommentListByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommentListByUser.CommentListByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCommentListByUser.CommentListByUserMock.defaultExpectation.params
		mm_want_ptrs := mmCommentListByUser.CommentListByUserMock.defaultExpectation.paramPtrs

		mm_got := CommentsServiceMockCommentListByUserParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommentListByUser.t.Errorf("CommentsServiceMock.CommentListByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCommentListByUser.t.Errorf("CommentsServiceMock.CommentListByUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommentListByUser.t.Errorf("CommentsServiceMock.CommentListByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommentListByUser.CommentListByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommentListByUser.CommentListByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCommentListByUser.t.Fatal("No results are set for the CommentsServiceMock.CommentListByUser")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmCommentListByUser.funcCommentListByUser != nil {
		return mmCommentListByUser.funcCommentListByUser(ctx, userID)
	}
	mmCommentListByUser.t.Fatalf("Unexpected call to CommentsServiceMock.CommentListByUser. %v %v", ctx, userID)
	return
}

// CommentListByUserAfterCounter returns a count of finished CommentsServiceMock.CommentListByUser invocations
func (mmCommentListByUser *CommentsServiceMock) CommentListByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListByUser.afterCommentListByUserCounter)
}

// CommentListByUserBeforeCounter returns a count of CommentsServiceMock.CommentListByUser invocations
func (mmCommentListByUser *CommentsServiceMock) CommentListByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommentListByUser.beforeCommentListByUserCounter)
}

// Calls returns a list of arguments used in each call to CommentsServiceMock.CommentListByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommentListByUser *mCommentsServiceMockCommentListByUser) Calls() []*CommentsServiceMockCommentListByUserParams {
	mmCommentListByUser.mutex.RLock()

	argCopy := make([]*CommentsServiceMockCommentListByUserParams, len(mmCommentListByUser.callArgs))
	copy(argCopy, mmCommentListByUser.callArgs)

	mmCommentListByUser.mutex.RUnlock()

	return argCopy
}

// MinimockCommentListByUserDone returns true if the count of the CommentListByUser invocations corresponds
// the number of defined expectations
func (m *CommentsServiceMock) MinimockCommentListByUserDone() bool {
	if m.CommentListByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommentListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommentListByUserMock.invocationsDone()
}

// MinimockCommentListByUserInspect logs each unmet expectation
func (m *CommentsServiceMock) MinimockCommentListByUserInspect() {
	for _, e := range m.CommentListByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommentListByUserCounter := mm_atomic.LoadUint64(&m.afterCommentListByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommentListByUserMock.defaultExpectation != nil && afterCommentListByUserCounter < 1 {
		if m.CommentListByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListByUser at\n%s", m.CommentListByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommentsServiceMock.CommentListByUser at\n%s with params: %#v", m.CommentListByUserMock.defaultExpectation.expectationOrigins.origin, *m.CommentListByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommentListByUser != nil && afterCommentListByUserCounter < 1 {
		m.t.Errorf("Expected call to CommentsServiceMock.CommentListByUser at\n%s", m.funcCommentListByUserOrigin)
	}

	if !m.CommentListByUserMock.invocationsDone() && afterCommentListByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CommentsServiceMock.CommentListByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommentListByUserMock.expectedInvocations), m.CommentListByUserMock.expectedInvocationsOrigin, afterCommentListByUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommentsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCommentAddInspect()

			m.MinimockCommentEditInspect()

			m.MinimockCommentGetByIDInspect()

			m.MinimockCommentListBySkuInspect()

			m.MinimockCommentListByUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommentsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommentsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommentAddDone() &&
		m.MinimockCommentEditDone() &&
		m.MinimockCommentGetByIDDone() &&
		m.MinimockCommentListBySkuDone() &&
		m.MinimockCommentListByUserDone()
}
